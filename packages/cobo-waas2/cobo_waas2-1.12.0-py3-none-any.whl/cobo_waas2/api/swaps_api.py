# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from cobo_waas2.models.create_swap_activity_request import CreateSwapActivityRequest
from cobo_waas2.models.create_swap_quote201_response import CreateSwapQuote201Response
from cobo_waas2.models.create_swap_quote_request import CreateSwapQuoteRequest
from cobo_waas2.models.list_enable_token_pairs200_response import ListEnableTokenPairs200Response
from cobo_waas2.models.list_swap_activities200_response import ListSwapActivities200Response
from cobo_waas2.models.swap_activity import SwapActivity
from cobo_waas2.models.swap_quote import SwapQuote

from cobo_waas2.api_client import ApiClient, RequestSerialized
from cobo_waas2.api_response import ApiResponse
from cobo_waas2.rest import RESTResponseType


class SwapsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def create_swap_activity(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapActivity:
        """Create Swap Activity

        This operation to create a swap activity. 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_swap_activity_with_http_info(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapActivity]:
        """Create Swap Activity

        This operation to create a swap activity. 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_swap_activity_without_preload_content(
        self,
        create_swap_activity_request: Annotated[CreateSwapActivityRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create Swap Activity

        This operation to create a swap activity. 

        :param create_swap_activity_request: The request body for creating a swap activity. (required)
        :type create_swap_activity_request: CreateSwapActivityRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_activity_serialize(
            create_swap_activity_request=create_swap_activity_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_swap_activity_serialize(
        self,
        create_swap_activity_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_swap_activity_request is not None:
            _body_params = create_swap_activity_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swaps/swap',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_swap_quote(
        self,
        create_swap_quote_request: Annotated[CreateSwapQuoteRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CreateSwapQuote201Response:
        """Create Swap Quote

        This operation retrieves a quote for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param create_swap_quote_request: The request body for creating a swap activity. (required)
        :type create_swap_quote_request: CreateSwapQuoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_quote_serialize(
            create_swap_quote_request=create_swap_quote_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateSwapQuote201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_swap_quote_with_http_info(
        self,
        create_swap_quote_request: Annotated[CreateSwapQuoteRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CreateSwapQuote201Response]:
        """Create Swap Quote

        This operation retrieves a quote for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param create_swap_quote_request: The request body for creating a swap activity. (required)
        :type create_swap_quote_request: CreateSwapQuoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_quote_serialize(
            create_swap_quote_request=create_swap_quote_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateSwapQuote201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_swap_quote_without_preload_content(
        self,
        create_swap_quote_request: Annotated[CreateSwapQuoteRequest, Field(description="The request body for creating a swap activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create Swap Quote

        This operation retrieves a quote for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param create_swap_quote_request: The request body for creating a swap activity. (required)
        :type create_swap_quote_request: CreateSwapQuoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_swap_quote_serialize(
            create_swap_quote_request=create_swap_quote_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateSwapQuote201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_swap_quote_serialize(
        self,
        create_swap_quote_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_swap_quote_request is not None:
            _body_params = create_swap_quote_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swaps/quote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_swap_activity(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique id of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapActivity:
        """Get Swap Activity Details

        This operation retrieves the details of a swap activity. 

        :param activity_id: The unique id of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_swap_activity_with_http_info(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique id of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapActivity]:
        """Get Swap Activity Details

        This operation retrieves the details of a swap activity. 

        :param activity_id: The unique id of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_swap_activity_without_preload_content(
        self,
        activity_id: Annotated[StrictStr, Field(description="The unique id of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get Swap Activity Details

        This operation retrieves the details of a swap activity. 

        :param activity_id: The unique id of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapActivity",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_swap_activity_serialize(
        self,
        activity_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if activity_id is not None:
            _path_params['activity_id'] = activity_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/activities/{activity_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_swap_quote(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="Unique id of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="Unique id of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of pay token to swap.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> SwapQuote:
        """Get Current Swap Rate

        This operation retrieves the current market exchange rate and estimated amount for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: Unique id of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: Unique id of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of pay token to swap.
        :type pay_amount: str
        :param receive_amount: The amount of token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_swap_quote_with_http_info(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="Unique id of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="Unique id of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of pay token to swap.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[SwapQuote]:
        """Get Current Swap Rate

        This operation retrieves the current market exchange rate and estimated amount for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: Unique id of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: Unique id of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of pay token to swap.
        :type pay_amount: str
        :param receive_amount: The amount of token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_swap_quote_without_preload_content(
        self,
        wallet_id: Annotated[StrictStr, Field(description="The wallet ID.")],
        pay_token_id: Annotated[StrictStr, Field(description="Unique id of the token to pay.")],
        receive_token_id: Annotated[StrictStr, Field(description="Unique id of the token to receive.")],
        pay_amount: Annotated[Optional[StrictStr], Field(description="The amount of pay token to swap.")] = None,
        receive_amount: Annotated[Optional[StrictStr], Field(description="The amount of token to receive.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get Current Swap Rate

        This operation retrieves the current market exchange rate and estimated amount for swapping between two tokens. Either pay_amount or receive_amount must be provided. 

        :param wallet_id: The wallet ID. (required)
        :type wallet_id: str
        :param pay_token_id: Unique id of the token to pay. (required)
        :type pay_token_id: str
        :param receive_token_id: Unique id of the token to receive. (required)
        :type receive_token_id: str
        :param pay_amount: The amount of pay token to swap.
        :type pay_amount: str
        :param receive_amount: The amount of token to receive.
        :type receive_amount: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_swap_quote_serialize(
            wallet_id=wallet_id,
            pay_token_id=pay_token_id,
            receive_token_id=receive_token_id,
            pay_amount=pay_amount,
            receive_amount=receive_amount,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SwapQuote",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_swap_quote_serialize(
        self,
        wallet_id,
        pay_token_id,
        receive_token_id,
        pay_amount,
        receive_amount,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wallet_id is not None:
            
            _query_params.append(('wallet_id', wallet_id))
            
        if pay_token_id is not None:
            
            _query_params.append(('pay_token_id', pay_token_id))
            
        if receive_token_id is not None:
            
            _query_params.append(('receive_token_id', receive_token_id))
            
        if pay_amount is not None:
            
            _query_params.append(('pay_amount', pay_amount))
            
        if receive_amount is not None:
            
            _query_params.append(('receive_amount', receive_amount))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/quote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_enable_token_pairs(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListEnableTokenPairs200Response:
        """List Supported Token Pairs

        This operation retrieves all supported token pairs for swaps in a specified wallet. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_enable_token_pairs_serialize(
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEnableTokenPairs200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_enable_token_pairs_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListEnableTokenPairs200Response]:
        """List Supported Token Pairs

        This operation retrieves all supported token pairs for swaps in a specified wallet. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_enable_token_pairs_serialize(
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEnableTokenPairs200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_enable_token_pairs_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List Supported Token Pairs

        This operation retrieves all supported token pairs for swaps in a specified wallet. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_enable_token_pairs_serialize(
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEnableTokenPairs200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_enable_token_pairs_serialize(
        self,
        limit,
        before,
        after,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/enabled_pairs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_swap_activities(
        self,
        status: Optional[StrictStr] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field used for sorting.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListSwapActivities200Response:
        """List Swap Activities

        This operation retrieves a list of swap activities. 

        :param status:
        :type status: str
        :param min_updated_timestamp: The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param sort_by: The field used for sorting.
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_swap_activities_with_http_info(
        self,
        status: Optional[StrictStr] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field used for sorting.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListSwapActivities200Response]:
        """List Swap Activities

        This operation retrieves a list of swap activities. 

        :param status:
        :type status: str
        :param min_updated_timestamp: The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param sort_by: The field used for sorting.
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_swap_activities_without_preload_content(
        self,
        status: Optional[StrictStr] = None,
        min_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        max_updated_timestamp: Annotated[Optional[StrictInt], Field(description="The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.")] = None,
        initiator: Annotated[Optional[StrictStr], Field(description="The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. ")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The field used for sorting.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List Swap Activities

        This operation retrieves a list of swap activities. 

        :param status:
        :type status: str
        :param min_updated_timestamp: The start time of the query. All staking activities updated after the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type min_updated_timestamp: int
        :param max_updated_timestamp: The end time of the query. All staking activities updated before the specified time will be retrieved. The time is in Unix timestamp format, measured in milliseconds.
        :type max_updated_timestamp: int
        :param initiator: The activity initiator, which is your API key by default. You can also specify the initiator when creating the activity.
        :type initiator: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: This parameter specifies an object ID as a starting point for pagination, retrieving data before the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C.  If you set `before` to the ID of Object C (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object A.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. - If you set it to `infinity`, the last page of data is returned. 
        :type before: str
        :param after: This parameter specifies an object ID as a starting point for pagination, retrieving data after the specified object relative to the current dataset.    Suppose the current data is ordered as Object A, Object B, and Object C. If you set `after` to the ID of Object A (`RqeEoTkgKG5rpzqYzg2Hd3szmPoj2cE7w5jWwShz3C1vyGSAk`), the response will include Object B and Object C.    **Notes**:   - If you set both `after` and `before`, an error will occur. - If you leave both `before` and `after` empty, the first page of data is returned. 
        :type after: str
        :param sort_by: The field used for sorting.
        :type sort_by: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_swap_activities_serialize(
            status=status,
            min_updated_timestamp=min_updated_timestamp,
            max_updated_timestamp=max_updated_timestamp,
            initiator=initiator,
            limit=limit,
            before=before,
            after=after,
            sort_by=sort_by,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSwapActivities200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_swap_activities_serialize(
        self,
        status,
        min_updated_timestamp,
        max_updated_timestamp,
        initiator,
        limit,
        before,
        after,
        sort_by,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status))
            
        if min_updated_timestamp is not None:
            
            _query_params.append(('min_updated_timestamp', min_updated_timestamp))
            
        if max_updated_timestamp is not None:
            
            _query_params.append(('max_updated_timestamp', max_updated_timestamp))
            
        if initiator is not None:
            
            _query_params.append(('initiator', initiator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swaps/activities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )
