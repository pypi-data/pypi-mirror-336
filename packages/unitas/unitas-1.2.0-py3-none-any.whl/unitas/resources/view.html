<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unitas Network Scan Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f5f8fa;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: #2c3e50;
            color: #fff;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
        }

        .initial-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            text-align: center;
        }

        .initial-screen h2 {
            margin-bottom: 2rem;
        }

        .drop-area {
            border: 3px dashed #3498db;
            border-radius: 10px;
            width: 100%;
            max-width: 600px;
            padding: 3rem;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            background-color: rgba(52, 152, 219, 0.05);
        }

        .drop-area.highlight {
            background-color: rgba(52, 152, 219, 0.15);
            border-color: #2980b9;
        }

        .drop-area p {
            margin: 0;
            font-size: 1.2rem;
            color: #7f8c8d;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 1rem;
        }

        .file-input {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .file-input-button:hover {
            background-color: #2980b9;
        }

        .error-message {
            color: #e74c3c;
            margin-top: 1rem;
            font-weight: 700;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            background-color: #fff;
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .stat-box {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #3498db;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .nav {
            display: flex;
            background-color: #fff;
            padding: 0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            margin-bottom: 1rem;
        }

        .nav-item {
            color: #34495e;
            padding: 0.8rem 1.2rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
            user-select: none;
        }

        .nav-item:hover {
            background-color: #f8f9fa;
        }

        .nav-item.active {
            border-bottom: 3px solid #3498db;
            color: #3498db;
            font-weight: 700;
        }

        .search-container {
            margin-bottom: 1rem;
        }

        #search {
            width: 100%;
            padding: 0.8rem;
            font-size: 1rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .panel {
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        td,
        th {
            border: 1px solid #eee;
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 700;
            color: #2c3e50;
            position: sticky;
            top: 0;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        #graph-container {
            height: 700px;
            background-color: #fff;
            border-radius: 5px;
            position: relative;
        }

        .badge {
            display: inline-block;
            padding: 0.25em 0.5em;
            border-radius: 3px;
            font-size: 0.75em;
            font-weight: 700;
        }

        .badge-tls {
            background-color: #3498db;
            color: #fff;
        }

        .badge-uncertain {
            background-color: #f39c12;
            color: #fff;
        }

        .table-container {
            max-height: 700px;
            overflow-y: auto;
        }

        .empty-message {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
            font-style: italic;
        }

        .port-list {
            margin: 0;
            padding: 0;
            list-style-type: none;
        }

        .port-list li {
            margin-bottom: 3px;
        }

        .status-filter {
            display: flex;
            margin-bottom: 1rem;
            gap: 10px;
        }

        .status-filter button {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background-color: #fff;
            border-radius: 3px;
            cursor: pointer;
        }

        .status-filter button.active {
            background-color: #3498db;
            color: #fff;
            border-color: #3498db;
        }

        .export-btn {
            margin-left: auto;
            padding: 0.6rem 1rem;
            background-color: #2ecc71;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
        }

        .export-btn:hover {
            background-color: #27ae60;
        }

        footer {
            text-align: center;
            padding: 1rem;
            color: #7f8c8d;
            font-size: 0.8rem;
        }

        .hidden {
            display: none;
        }

        .scan-info {
            margin-bottom: 1rem;
            color: #7f8c8d;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }

        .data-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .reload-btn {
            padding: 0.5rem 1rem;
            background-color: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .reload-btn:hover {
            background-color: #c0392b;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 140px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 150%;
            left: 50%;
            margin-left: -70px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .loading-spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .graph-flex-container {
            display: flex;
            height: 700px;
        }

        #graph-sidebar {
            width: 300px;
            border-right: 1px solid #eee;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        #graph-container {
            flex-grow: 1;
            height: 100%;
        }

        .graph-controls {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
        }

        .filter-section {
            margin-bottom: 20px;
        }

        .filter-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .tag-filter {
            margin-bottom: 10px;
        }

        .tag-filter label {
            display: block;
            margin-bottom: 5px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .range-filter {
            margin-bottom: 15px;
        }

        .range-filter label {
            display: block;
            margin-bottom: 5px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .range-inputs {
            display: flex;
            align-items: center;
        }

        .range-inputs input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .range-inputs span {
            margin: 0 10px;
        }

        .checkbox-list {
            margin: 0;
            padding: 0;
            list-style-type: none;
        }

        .checkbox-list li {
            margin-bottom: 5px;
        }

        .checkbox-list label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .checkbox-list input[type="checkbox"] {
            margin-right: 8px;
        }

        .subnet-filter {
            margin-bottom: 15px;
        }

        .subnet-filter label {
            display: block;
            margin-bottom: 5px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .subnet-filter input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .radio-list {
            margin: 0;
            padding: 0;
            list-style-type: none;
        }

        .radio-list li {
            margin-bottom: 5px;
        }

        .radio-list label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .radio-list input[type="radio"] {
            margin-right: 8px;
        }

        .filter-button {
            padding: 5px 10px;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-right: 5px;
        }

        .reset-button {
            padding: 5px 10px;
            background-color: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .node-details {
            display: none;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 5px;
            margin-top: 20px;
        }

        .node-details h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .node-details-content {
            font-size: 0.9rem;
        }

        .node-details-content dl {
            margin: 0;
            padding: 0;
        }

        .node-details-content dt {
            font-weight: 700;
            margin-top: 10px;
        }

        .node-details-content dd {
            margin-left: 0;
            margin-bottom: 5px;
            padding-left: 10px;
            border-left: 2px solid #ddd;
        }

        .graph-minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 5px;
            z-index: 100;
            overflow: hidden;
        }

        .graph-options {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .graph-option-btn {
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .graph-option-btn:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .graph-legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            z-index: 100;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .analysis-result {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 5px;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .analysis-result h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .pin-button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #9b59b6;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .node-actions {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .slider-container {
            width: 100%;
            margin-bottom: 15px;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            -webkit-transition: 0.2s;
            transition: opacity 0.2s;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .tooltip-container {
            position: absolute;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            max-width: 300px;
            display: none;
        }
    </style>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://unpkg.com/vis-data/standalone/umd/vis-data.min.js"></script>
</head>

<body>
    <header>
        <h1>Unitas Network Scan Viewer</h1>
    </header>
    <div class="container">
        <!-- Initial screen for loading data -->
        <div id="initial-screen" class="initial-screen">
            <h2>Load Unitas JSON Scan Data</h2>
            <div id="drop-area" class="drop-area">
                <p>Drag and drop a Unitas JSON file here</p>
                <p>OR</p>
                <div class="file-input-wrapper">
                    <button class="file-input-button">Select JSON File</button>
                    <input type="file" id="file-input" class="file-input" accept=".json">
                </div>
            </div>
            <p id="error-message" class="error-message hidden"></p>
            <p>Generate JSON files with: <code>unitas /path/to/scan/folder --json -o output.json</code></p>
        </div>

        <!-- Data view (initially hidden) -->
        <div id="data-view" class="hidden">
            <div class="scan-info">
                <span id="scan-date">Generated: [Date]</span>
                <span id="scan-version">Unitas [Version]</span>
            </div>

            <div class="data-controls">
                <button id="reload-btn" class="reload-btn">Load Different File</button>
                <button id="export-markdown-btn" class="export-btn">Export as Markdown</button>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="total-hosts">0</div>
                    <div class="stat-label">Total Hosts</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="total-ports">0</div>
                    <div class="stat-label">Open Ports</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="up-hosts">0</div>
                    <div class="stat-label">Hosts Up (No Ports)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="services-count">0</div>
                    <div class="stat-label">Unique Services</div>
                </div>
            </div>

            <div class="search-container">
                <input type="text" id="search" placeholder="Search for hosts, ports, services...">
            </div>

            <div class="nav">
                <div class="nav-item active" data-view="hosts-view">Hosts</div>
                <div class="nav-item" data-view="ports-view">Ports</div>
                <div class="nav-item" data-view="services-view">Services</div>
                <div class="nav-item" data-view="up-hosts-view">Up Hosts</div>
                <div class="nav-item" data-view="graph-view">Network Graph</div>
            </div>

            <div id="hosts-view" class="view active">
                <div class="panel">
                    <h2>Hosts with Open Ports</h2>
                    <div class="table-container">
                        <table id="hosts-table">
                            <thead>
                                <tr>
                                    <th>IP</th>
                                    <th>Hostname</th>
                                    <th>Open Ports</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="ports-view" class="view">
                <div class="panel">
                    <h2>Open Ports</h2>
                    <div class="status-filter">
                        <button class="status-btn active" data-status="all">All</button>
                        <button class="status-btn" data-status="tbd">TBD</button>
                        <button class="status-btn" data-status="done">Done</button>
                    </div>
                    <div class="table-container">
                        <table id="ports-table">
                            <thead>
                                <tr>
                                    <th>IP</th>
                                    <th>Hostname</th>
                                    <th>Port</th>
                                    <th>Protocol</th>
                                    <th>Service</th>
                                    <th>Status</th>
                                    <th>Comment</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="services-view" class="view">
                <div class="panel">
                    <h2>Services</h2>
                    <div class="table-container">
                        <table id="services-table">
                            <thead>
                                <tr>
                                    <th>Service</th>
                                    <th>Count</th>
                                    <th>Hosts</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="up-hosts-view" class="view">
                <div class="panel">
                    <h2>Up Hosts (No Open Ports)</h2>
                    <div class="table-container">
                        <table id="up-hosts-table">
                            <thead>
                                <tr>
                                    <th>IP</th>
                                    <th>Reason</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="graph-view" class="view">
                <div class="panel">
                    <h2>Enhanced Network Visualization</h2>
                    <div class="graph-flex-container">
                        <div id="graph-sidebar">
                            <div class="filter-section">
                                <h3>Filters</h3>
                                <div class="tag-filter">
                                    <label for="service-filter">Service Type:</label>
                                    <select id="service-filter" class="filter-select">
                                        <option value="all">All Services</option>
                                    </select>
                                </div>
                                <div class="range-filter">
                                    <label>Port Range:</label>
                                    <div class="range-inputs">
                                        <input type="number" id="port-min" min="1" max="65535" value="1">
                                        <span>to</span>
                                        <input type="number" id="port-max" min="1" max="65535" value="65535">
                                    </div>
                                </div>
                                <div class="subnet-filter">
                                    <label for="subnet-filter">Filter by Subnet:</label>
                                    <input id="subnet-filter" placeholder="e.g., 192.168.1">
                                </div>
                                <div class="filter-section">
                                    <h3>Display Options</h3>
                                    <ul class="checkbox-list">
                                        <li>
                                            <label>
                                                <input type="checkbox" id="show-up-hosts" checked> Show hosts without
                                                open ports
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="checkbox" id="show-uncertain" checked> Show uncertain
                                                services
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="checkbox" id="highlight-tls" checked> Highlight TLS
                                                services
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                                <div class="filter-section">
                                    <h3>Layout</h3>
                                    <ul class="radio-list">
                                        <li>
                                            <label>
                                                <input type="radio" name="layout" value="standard" checked>
                                                Force-directed
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="layout" value="hierarchical"> Hierarchical
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="layout" value="circular"> Circular
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                                <div class="slider-container">
                                    <label for="node-size">Node Size:</label>
                                    <input type="range" min="1" max="30" value="16" class="slider" id="node-size">
                                </div>
                                <div class="filter-actions">
                                    <button id="apply-filters" class="filter-button">Apply Filters</button>
                                    <button id="reset-filters" class="reset-button">Reset</button>
                                </div>
                            </div>
                            <div class="filter-section">
                                <h3>Analysis Tools</h3>
                                <div class="tag-filter">
                                    <label for="analysis-type">Analysis:</label>
                                    <select id="analysis-type" class="filter-select">
                                        <option value="none">Select analysis...</option>
                                        <option value="common-services">Find common services</option>
                                        <option value="segments">Identify network segments</option>
                                        <option value="unusual">Highlight unusual ports</option>
                                        <option value="connectivity">Most connected hosts</option>
                                    </select>
                                </div>
                                <button id="run-analysis" class="filter-button">Run Analysis</button>
                                <div id="analysis-result" class="analysis-result hidden">
                                    <h3>Analysis Results</h3>
                                    <div id="analysis-content"></div>
                                </div>
                            </div>
                            <div id="node-details" class="node-details">
                                <h3>Node Details</h3>
                                <div id="node-details-content" class="node-details-content"></div>
                                <div class="node-actions">
                                    <button id="pin-node" class="pin-button">Pin Node</button>
                                    <button id="focus-node" class="filter-button">Focus</button>
                                </div>
                            </div>
                        </div>
                        <div id="graph-area">
                            <div id="graph-container"></div>
                            <div class="graph-options">
                                <button id="export-png" class="graph-option-btn">Export PNG</button>
                                <button id="save-view" class="graph-option-btn">Save View</button>
                                <button id="fit-graph" class="graph-option-btn">Fit View</button>
                                <button id="toggle-minimap" class="graph-option-btn">Toggle Minimap</button>
                                <button id="toggle-physics" class="graph-option-btn">Toggle Physics</button>
                            </div>
                            <div id="graph-minimap" class="graph-minimap"></div>
                            <div id="graph-legend" class="graph-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color:#3498db;"></div>
                                    <span>Host</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color:#2ecc71;"></div>
                                    <span>Service</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color:#e67e22;"></div>
                                    <span>Host (no open ports)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color:#9b59b6;"></div>
                                    <span>Pinned Node</span>
                                </div>
                            </div>
                            <div id="graph-tooltip" class="tooltip-container"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <footer>
        Unitas Network Graph Viewer - Enhanced Visualization Tool
    </footer>

    <script>
        // Global state
        let scanData = null;
        let network = null;
        let nodesDataset = null;
        let edgesDataset = null;
        let pinnedNodes = new Set();
        let filteredItems = {
            hosts: new Set(),
            services: new Set(),
            nodes: new Set(),
            edges: new Set()
        };
        let serviceTypes = new Set();
        let minimapNetwork = null;
        let physicsEnabled = true;
        let selectedNode = null;
        let savedViews = {};
        let subnetGroups = {};

        // DOM Elements
        const initialScreen = document.getElementById('initial-screen');
        const dataView = document.getElementById('data-view');
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const errorMessage = document.getElementById('error-message');
        const reloadBtn = document.getElementById('reload-btn');
        const exportMarkdownBtn = document.getElementById('export-markdown-btn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const nodeDetails = document.getElementById('node-details');
        const nodeDetailsContent = document.getElementById('node-details-content');
        const graphMinimap = document.getElementById('graph-minimap');
        const graphTooltip = document.getElementById('graph-tooltip');

        // Setup drag and drop handlers
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropArea.classList.add('highlight');
        }

        function unhighlight() {
            dropArea.classList.remove('highlight');
        }

        // Handle file drop
        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length === 1) {
                handleFile(files[0]);
            } else {
                showError('Please drop a single JSON file.');
            }
        }

        // Handle file input
        fileInput.addEventListener('change', function () {
            if (this.files.length === 1) {
                handleFile(this.files[0]);
            } else {
                showError('Please select a single JSON file.');
            }
        });

        // Handle reload button
        reloadBtn.addEventListener('click', function () {
            initialScreen.classList.remove('hidden');
            dataView.classList.add('hidden');
            errorMessage.classList.add('hidden');
            fileInput.value = '';
            scanData = null;
            if (network) {
                network.destroy();
                network = null;
            }
            if (minimapNetwork) {
                minimapNetwork.destroy();
                minimapNetwork = null;
            }
            pinnedNodes.clear();
            filteredItems.hosts.clear();
            filteredItems.services.clear();
            filteredItems.nodes.clear();
            filteredItems.edges.clear();
        });

        // Handle export markdown button
        exportMarkdownBtn.addEventListener('click', function () {
            if (!scanData) return;

            // Generate markdown content
            let markdown = "|IP|Hostname|Port|Status|Comment|\n|--|--|--|--|---|\n";

            scanData.hosts.forEach(host => {
                host.ports.forEach(port => {
                    const ip = host.ip;
                    const hostname = host.hostname || '';
                    const portInfo = `${port.port}/${port.protocol}(${port.service})`;
                    const state = port.state || 'TBD';
                    const comment = port.comment || '';

                    markdown += `|${ip}|${hostname}|${portInfo}|${state}|${comment}|\n`;
                });
            });

            // Create and download file
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'unitas_export.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                showError('Please select a JSON file (.json)');
                return;
            }

            showLoading();

            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    scanData = JSON.parse(e.target.result);
                    validateAndDisplayData(scanData);
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    showError('Invalid JSON file. Please select a valid Unitas export file.');
                    hideLoading();
                }
            };

            reader.onerror = function () {
                showError('Error reading file');
                hideLoading();
            };

            reader.readAsText(file);
        }

        function validateAndDisplayData(data) {
            // Basic validation of data structure
            if (!data.hosts || !Array.isArray(data.hosts)) {
                showError('Invalid data format: Missing hosts array');
                hideLoading();
                return;
            }

            // Switch views
            initialScreen.classList.add('hidden');
            dataView.classList.remove('hidden');
            errorMessage.classList.add('hidden');

            // Display scan info
            if (data.metadata) {
                document.getElementById('scan-date').textContent = `Generated: ${data.metadata.generated || 'Unknown'}`;
                document.getElementById('scan-version').textContent = `Unitas ${data.metadata.version || 'Unknown'}`;
            } else {
                document.getElementById('scan-date').textContent = 'Generated: Unknown';
                document.getElementById('scan-version').textContent = 'Unitas Unknown';
            }

            // Initialize the visualization
            updateStats();
            populateTables();
            populateServiceFilter();
            setupEventHandlers();
            hideLoading();
        }

        function showLoading() {
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // Stats calculations
        function updateStats() {
            if (!scanData) return;

            document.getElementById('total-hosts').textContent = scanData.hosts.length;

            let totalPorts = 0;
            scanData.hosts.forEach(host => {
                totalPorts += host.ports.length;
            });
            document.getElementById('total-ports').textContent = totalPorts;

            document.getElementById('up-hosts').textContent = scanData.hostsUp ? scanData.hostsUp.length : 0;

            // Get unique services
            serviceTypes.clear();
            scanData.hosts.forEach(host => {
                host.ports.forEach(port => {
                    const cleanService = port.service.replace('?', '');
                    serviceTypes.add(cleanService);
                });
            });
            document.getElementById('services-count').textContent = serviceTypes.size;
        }

        // Navigation
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));

                item.classList.add('active');
                const viewId = item.getAttribute('data-view');
                document.getElementById(viewId).classList.add('active');

                if (viewId === 'graph-view' && scanData) {
                    if (!network) {
                        renderGraph();
                    }
                }
            });
        });

        // Search functionality
        document.getElementById('search').addEventListener('input', function () {
            const searchTerm = this.value.toLowerCase();
            filterTables(searchTerm);
        });

        function filterTables(searchTerm) {
            // Filter hosts table
            const hostsRows = document.querySelectorAll('#hosts-table tbody tr');
            hostsRows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });

            // Filter ports table
            const portsRows = document.querySelectorAll('#ports-table tbody tr');
            portsRows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });

            // Filter services table
            const servicesRows = document.querySelectorAll('#services-table tbody tr');
            servicesRows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });

            // Filter up hosts table
            const upHostsRows = document.querySelectorAll('#up-hosts-table tbody tr');
            upHostsRows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        }

        // Status filter for ports view
        document.querySelectorAll('.status-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.status-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const status = btn.getAttribute('data-status').toLowerCase();
                const rows = document.querySelectorAll('#ports-table tbody tr');

                rows.forEach(row => {
                    if (status === 'all') {
                        row.style.display = '';
                    } else {
                        const rowStatus = row.querySelector('td:nth-child(6)').textContent.toLowerCase();
                        row.style.display = rowStatus === status ? '' : 'none';
                    }
                });
            });
        });

        // Populate tables
        function populateTables() {
            if (!scanData) return;

            // Populate hosts table
            const hostsTable = document.querySelector('#hosts-table tbody');
            hostsTable.innerHTML = '';

            if (scanData.hosts.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 3;
                cell.className = 'empty-message';
                cell.textContent = 'No hosts with open ports found.';
                row.appendChild(cell);
                hostsTable.appendChild(row);
            } else {
                scanData.hosts.sort((a, b) => {
                    // Sort by IP address
                    const ipA = a.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');
                    const ipB = b.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');
                    return ipA.localeCompare(ipB);
                }).forEach(host => {
                    const row = document.createElement('tr');

                    const ipCell = document.createElement('td');
                    ipCell.textContent = host.ip;
                    row.appendChild(ipCell);

                    const hostnameCell = document.createElement('td');
                    hostnameCell.textContent = host.hostname || '-';
                    row.appendChild(hostnameCell);

                    const portsCell = document.createElement('td');
                    const portsList = document.createElement('ul');
                    portsList.className = 'port-list';

                    host.ports.sort((a, b) => parseInt(a.port) - parseInt(b.port)).forEach(port => {
                        const portItem = document.createElement('li');
                        let portText = `${port.port}/${port.protocol} (${port.service})`;

                        if (port.service.includes('?') || port.uncertain) {
                            portText += ' <span class="badge badge-uncertain">?</span>';
                        }

                        if (port.comment.includes('TLS') || port.tls) {
                            portText += ' <span class="badge badge-tls">TLS</span>';
                        }

                        portItem.innerHTML = portText;
                        portsList.appendChild(portItem);
                    });

                    portsCell.appendChild(portsList);
                    row.appendChild(portsCell);

                    hostsTable.appendChild(row);
                });
            }

            // Populate ports table
            const portsTable = document.querySelector('#ports-table tbody');
            portsTable.innerHTML = '';

            if (scanData.hosts.length === 0 || !scanData.hosts.some(host => host.ports.length > 0)) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 7;
                cell.className = 'empty-message';
                cell.textContent = 'No open ports found.';
                row.appendChild(cell);
                portsTable.appendChild(row);
            } else {
                const allPorts = [];

                scanData.hosts.forEach(host => {
                    host.ports.forEach(port => {
                        allPorts.push({
                            ip: host.ip,
                            hostname: host.hostname,
                            ...port
                        });
                    });
                });

                allPorts.sort((a, b) => {
                    // Sort by IP, then port number
                    const ipA = a.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');
                    const ipB = b.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');

                    if (ipA !== ipB) return ipA.localeCompare(ipB);
                    return parseInt(a.port) - parseInt(b.port);
                }).forEach(port => {
                    const row = document.createElement('tr');

                    const ipCell = document.createElement('td');
                    ipCell.textContent = port.ip;
                    row.appendChild(ipCell);

                    const hostnameCell = document.createElement('td');
                    hostnameCell.textContent = port.hostname || '-';
                    row.appendChild(hostnameCell);

                    const portCell = document.createElement('td');
                    portCell.textContent = port.port;
                    row.appendChild(portCell);

                    const protocolCell = document.createElement('td');
                    protocolCell.textContent = port.protocol;
                    row.appendChild(protocolCell);

                    const serviceCell = document.createElement('td');
                    if (port.service.includes('?') || port.uncertain) {
                        serviceCell.innerHTML = `${port.service.replace('?', '')} <span class="badge badge-uncertain">?</span>`;
                    } else {
                        serviceCell.textContent = port.service;
                    }
                    row.appendChild(serviceCell);

                    const stateCell = document.createElement('td');
                    stateCell.textContent = port.state || 'TBD';
                    row.appendChild(stateCell);

                    const commentCell = document.createElement('td');
                    if (port.comment && port.comment.includes('TLS') || port.tls) {
                        commentCell.innerHTML = `${port.comment ? port.comment.replace('TLS', '') : ''} <span class="badge badge-tls">TLS</span>`;
                    } else {
                        commentCell.textContent = port.comment || '';
                    }
                    row.appendChild(commentCell);

                    portsTable.appendChild(row);
                });
            }

            // Populate services table
            const servicesTable = document.querySelector('#services-table tbody');
            servicesTable.innerHTML = '';

            if (scanData.hosts.length === 0 || !scanData.hosts.some(host => host.ports.length > 0)) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 3;
                cell.className = 'empty-message';
                cell.textContent = 'No services found.';
                row.appendChild(cell);
                servicesTable.appendChild(row);
            } else {
                // Group by service
                const serviceGroups = {};

                scanData.hosts.forEach(host => {
                    host.ports.forEach(port => {
                        const cleanService = port.service.replace('?', '');
                        if (!serviceGroups[cleanService]) {
                            serviceGroups[cleanService] = {
                                count: 0,
                                hosts: new Set()
                            };
                        }
                        serviceGroups[cleanService].count++;
                        serviceGroups[cleanService].hosts.add(host.ip);
                    });
                });

                Object.entries(serviceGroups)
                    .sort((a, b) => b[1].count - a[1].count)
                    .forEach(([service, data]) => {
                        const row = document.createElement('tr');

                        const serviceCell = document.createElement('td');
                        serviceCell.textContent = service;
                        row.appendChild(serviceCell);

                        const countCell = document.createElement('td');
                        countCell.textContent = data.count;
                        row.appendChild(countCell);

                        const hostsCell = document.createElement('td');
                        hostsCell.textContent = Array.from(data.hosts).join(', ');
                        row.appendChild(hostsCell);

                        servicesTable.appendChild(row);
                    });
            }

            // Populate up hosts table
            const upHostsTable = document.querySelector('#up-hosts-table tbody');
            upHostsTable.innerHTML = '';

            if (!scanData.hostsUp || scanData.hostsUp.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 2;
                cell.className = 'empty-message';
                cell.textContent = 'No hosts that are up without open ports.';
                row.appendChild(cell);
                upHostsTable.appendChild(row);
            } else {
                scanData.hostsUp.sort((a, b) => {
                    const ipA = a.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');
                    const ipB = b.ip.split('.').map(num => parseInt(num.padStart(3, '0'))).join('');
                    return ipA.localeCompare(ipB);
                }).forEach(host => {
                    const row = document.createElement('tr');

                    const ipCell = document.createElement('td');
                    ipCell.textContent = host.ip;
                    row.appendChild(ipCell);

                    const reasonCell = document.createElement('td');
                    reasonCell.textContent = host.reason;
                    row.appendChild(reasonCell);

                    upHostsTable.appendChild(row);
                });
            }
        }

        function populateServiceFilter() {
            const serviceFilter = document.getElementById('service-filter');
            serviceFilter.innerHTML = '<option value="all">All Services</option>';

            Array.from(serviceTypes).sort().forEach(service => {
                const option = document.createElement('option');
                option.value = service;
                option.textContent = service;
                serviceFilter.appendChild(option);
            });
        }

        function setupEventHandlers() {
            document.getElementById('pin-node').addEventListener('click', function () {
                if (selectedNode) {
                    if (pinnedNodes.has(selectedNode.id)) {
                        pinnedNodes.delete(selectedNode.id);
                        this.textContent = "Pin Node";
                        const nodeData = { ...selectedNode };
                        delete nodeData.fixed;
                        nodesDataset.update(nodeData);
                    } else {
                        pinnedNodes.add(selectedNode.id);
                        this.textContent = "Unpin Node";
                        const position = network.getPositions([selectedNode.id])[selectedNode.id];
                        nodesDataset.update({
                            id: selectedNode.id,
                            fixed: { x: true, y: true },
                            x: position.x,
                            y: position.y
                        });
                    }
                }
            });

            document.getElementById('focus-node').addEventListener('click', function () {
                if (selectedNode) {
                    network.focus(selectedNode.id, {
                        scale: 1.5,
                        animation: true
                    });
                }
            });

            document.getElementById('apply-filters').addEventListener('click', applyFilters);
            document.getElementById('reset-filters').addEventListener('click', resetFilters);

            document.getElementById('toggle-minimap').addEventListener('click', function () {
                const minimap = document.getElementById('graph-minimap');
                if (minimap.style.display === 'none') {
                    minimap.style.display = 'block';
                    updateMinimap();
                } else {
                    minimap.style.display = 'none';
                }
            });

            document.getElementById('toggle-physics').addEventListener('click', function () {
                physicsEnabled = !physicsEnabled;
                network.setOptions({
                    physics: {
                        enabled: physicsEnabled
                    }
                });
                this.textContent = physicsEnabled ? "Disable Physics" : "Enable Physics";
            });

            document.getElementById('fit-graph').addEventListener('click', function () {
                network.fit({
                    animation: true
                });
            });

            document.getElementById('export-png').addEventListener('click', exportNetworkImage);
            document.getElementById('save-view').addEventListener('click', saveCurrentView);
            document.getElementById('run-analysis').addEventListener('click', runAnalysis);

            document.getElementById('node-size').addEventListener('input', function () {
                network.setOptions({
                    nodes: {
                        scaling: {
                            min: Math.max(5, parseInt(this.value) - 10),
                            max: parseInt(this.value) + 10
                        }
                    }
                });
            });

            document.querySelectorAll('input[name="layout"]').forEach(radio => {
                radio.addEventListener('change', function () {
                    const positions = network.getPositions();
                    network.setOptions({
                        layout: getSelectedLayout()
                    });

                    if (this.value !== 'hierarchical') {
                        pinnedNodes.forEach(nodeId => {
                            if (positions[nodeId]) {
                                nodesDataset.update({
                                    id: nodeId,
                                    fixed: { x: true, y: true },
                                    x: positions[nodeId].x,
                                    y: positions[nodeId].y
                                });
                            }
                        });
                    }
                });
            });

            document.getElementById('show-up-hosts').addEventListener('change', refreshGraph);
            document.getElementById('show-uncertain').addEventListener('change', applyFilters);
            document.getElementById('highlight-tls').addEventListener('change', highlightTlsServices);
        }

        // Render network graph
        function renderGraph() {
            if (!scanData) return;

            const container = document.getElementById('graph-container');

            // Clear previous graph
            if (network) {
                network.destroy();
                network = null;
            }

            const { nodes, edges } = createGraphData();

            nodesDataset = new vis.DataSet(nodes);
            edgesDataset = new vis.DataSet(edges);

            // Create graph data
            const data = {
                nodes: nodesDataset,
                edges: edgesDataset
            };

            // Configure graph options
            const options = createGraphOptions();

            // Create network
            network = new vis.Network(container, data, options);

            setupNetworkEvents();
            initializeMinimap(nodes, edges);
        }

        function createGraphData() {
            const nodes = [];
            const edges = [];
            let nextId = 1;
            const nodeIdMap = {};
            const servicesMap = new Map();

            processSubnets();

            // Process hosts
            scanData.hosts.forEach((host) => {
                const hostId = nextId++;
                nodeIdMap[host.ip] = hostId;

                // Calculate value based on number of ports
                const portCount = host.ports.length;

                nodes.push({
                    id: hostId,
                    label: host.hostname || host.ip,
                    title: formatNodeTooltip(host),
                    group: "host",
                    subnetGroup: getSubnetGroup(host.ip),
                    type: "host",
                    ip: host.ip,
                    hostname: host.hostname,
                    value: Math.max(10, Math.min(30, 10 + 2 * portCount)),
                    ports: portCount,
                    original: host
                });

                // Process services on this host
                const hostServices = {};

                host.ports.forEach((port) => {
                    const serviceName = port.service.replace("?", "");

                    if (!hostServices[serviceName]) {
                        hostServices[serviceName] = [];
                    }
                    hostServices[serviceName].push(port);
                });

                // Create edges between host and services
                Object.entries(hostServices).forEach(([serviceName, ports]) => {
                    let serviceId;

                    if (servicesMap.has(serviceName)) {
                        serviceId = servicesMap.get(serviceName);
                    } else {
                        serviceId = nextId++;
                        servicesMap.set(serviceName, serviceId);

                        // Count total instances of this service
                        const serviceInstances = countServiceInstances(serviceName);

                        nodes.push({
                            id: serviceId,
                            label: serviceName,
                            title: `<strong>${serviceName}</strong><br>Instances: ${serviceInstances}`,
                            group: "service",
                            type: "service",
                            value: Math.max(8, Math.min(25, 8 + serviceInstances)),
                            service: serviceName,
                            uncertain: ports.some(p => p.service.includes("?") || p.uncertain),
                            tls: ports.some(p => p.comment && p.comment.includes("TLS") || p.tls)
                        });
                    }

                    edges.push({
                        from: hostId,
                        to: serviceId,
                        title: formatEdgeTooltip(ports),
                        width: Math.max(1, Math.min(5, Math.sqrt(2 * ports.length))),
                        arrows: { to: { enabled: false } },
                        color: { color: "#999", highlight: "#3498db" },
                        smooth: { type: "continuous" },
                        ports: ports
                    });
                });
            });

            // Add hosts that are up but have no open ports
            if (scanData.hostsUp && document.getElementById("show-up-hosts").checked) {
                scanData.hostsUp.forEach((host) => {
                    nodes.push({
                        id: nextId++,
                        label: host.ip,
                        title: `<strong>${host.ip}</strong><br>Up: ${host.reason}`,
                        group: "up-only",
                        type: "up-host",
                        ip: host.ip,
                        reason: host.reason,
                        value: 8,
                        subnetGroup: getSubnetGroup(host.ip)
                    });
                });
            }

            return { nodes, edges };
        }

        function createGraphOptions() {
            const nodeSize = parseInt(document.getElementById("node-size").value);

            return {
                nodes: {
                    shape: "dot",
                    scaling: {
                        min: Math.max(5, nodeSize - 10),
                        max: nodeSize + 10,
                        label: {
                            enabled: true,
                            min: 14,
                            max: 24
                        }
                    },
                    font: { size: 14 },
                    borderWidth: 2,
                    shadow: true
                },
                edges: {
                    width: 2,
                    shadow: true,
                    smooth: { type: "continuous" }
                },
                groups: {
                    host: {
                        color: { border: "#2980b9", background: "#3498db", highlight: { border: "#2980b9", background: "#5DADF5" } },
                        shape: "dot"
                    },
                    service: {
                        color: { border: "#27ae60", background: "#2ecc71", highlight: { border: "#27ae60", background: "#58D88D" } },
                        shape: "hexagon"
                    },
                    "up-only": {
                        color: { border: "#d35400", background: "#e67e22", highlight: { border: "#d35400", background: "#EB9950" } },
                        shape: "diamond"
                    },
                    pinned: {
                        color: { border: "#8e44ad", background: "#9b59b6", highlight: { border: "#8e44ad", background: "#ac6fc6" } },
                        fixed: true
                    }
                },
                physics: {
                    enabled: physicsEnabled,
                    stabilization: true,
                    barnesHut: {
                        gravitationalConstant: -10000,
                        springConstant: 0.002,
                        springLength: 150
                    }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200,
                    hideEdgesOnDrag: true,
                    multiselect: true,
                    navigationButtons: true
                },
                layout: getSelectedLayout()
            };
        }

        function getSelectedLayout() {
            switch (document.querySelector('input[name="layout"]:checked').value) {
                case "hierarchical":
                    return {
                        hierarchical: {
                            direction: "UD",
                            sortMethod: "directed",
                            nodeSpacing: 150,
                            levelSeparation: 150
                        }
                    };
                case "circular":
                    return {
                        improvedLayout: true,
                        randomSeed: 42
                    };
                default:
                    return {
                        improvedLayout: true
                    };
            }
        }

        function setupNetworkEvents() {
            if (!network) return;

            network.on("click", function (params) {
                if (params.nodes.length === 0) {
                    nodeDetails.style.display = "none";
                    selectedNode = null;
                    return;
                }

                selectedNode = nodesDataset.get(params.nodes[0]);
                showNodeDetails(selectedNode);
                highlightConnections(params.nodes[0]);
            });

            network.on("doubleClick", function (params) {
                if (params.nodes.length === 1) {
                    network.focus(params.nodes[0], {
                        scale: 1.2,
                        animation: true
                    });
                }
            });

            network.on("hoverNode", function (params) {
                showTooltip(params.node, params.event.center);
            });

            network.on("blurNode", function () {
                hideTooltip();
            });

            network.on("hoverEdge", function (params) {
                const edgeData = edgesDataset.get(params.edge);
                showTooltip(params.edge, params.event.center, true, edgeData);
            });

            network.on("blurEdge", function () {
                hideTooltip();
            });

            network.on("stabilizationProgress", function (params) {
                const progress = Math.round(params.iterations / params.total * 100);
                console.log(`Stabilizing: ${progress}%`);
            });

            network.on("stabilizationIterationsDone", function () {
                console.log("Stabilization complete");
                if (minimapNetwork) {
                    updateMinimap();
                }
            });
        }

        function showNodeDetails(node) {
            nodeDetails.style.display = "block";
            let content = "";

            switch (node.type) {
                case "host":
                    content = `
                        <dl>
                            <dt>IP Address:</dt>
                            <dd>${node.ip}</dd>
                            ${node.hostname ? `<dt>Hostname:</dt><dd>${node.hostname}</dd>` : ""}
                            <dt>Open Ports:</dt>
                            <dd>${node.ports} port(s)</dd>
                        </dl>
                        <h4>Ports:</h4>
                        <ul>
                    `;

                    node.original.ports.forEach(port => {
                        content += `<li>${port.port}/${port.protocol} (${port.service}) - ${port.state || 'TBD'}</li>`;
                    });

                    content += "</ul>";
                    break;

                case "service":
                    content = `
                        <dl>
                            <dt>Service:</dt>
                            <dd>${node.service}</dd>
                            <dt>Status:</dt>
                            <dd>${node.uncertain ? "Uncertain" : "Confirmed"}</dd>
                            ${node.tls ? "<dt>Security:</dt><dd>TLS Enabled</dd>" : ""}
                        </dl>
                        <h4>Connected Hosts:</h4>
                        <ul>
                    `;

                    getConnectedHosts(node.id).forEach(hostId => {
                        const hostNode = nodesDataset.get(hostId);
                        content += `<li>${hostNode.ip}${hostNode.hostname ? ` (${hostNode.hostname})` : ""}</li>`;
                    });

                    content += "</ul>";
                    break;

                case "up-host":
                    content = `
                        <dl>
                            <dt>IP Address:</dt>
                            <dd>${node.ip}</dd>
                            <dt>Status:</dt>
                            <dd>Up (no open ports)</dd>
                            <dt>Reason:</dt>
                            <dd>${node.reason}</dd>
                        </dl>
                    `;
                    break;
            }

            document.getElementById("pin-node").textContent = pinnedNodes.has(node.id) ? "Unpin Node" : "Pin Node";
            nodeDetailsContent.innerHTML = content;
        }

        function initializeMinimap(nodes, edges) {
            const minimap = document.getElementById("graph-minimap");

            const minimapNodes = nodes.map(node => ({
                id: node.id,
                group: node.group
            }));

            const minimapEdges = edges.map(edge => ({
                from: edge.from,
                to: edge.to
            }));

            const minimapData = {
                nodes: new vis.DataSet(minimapNodes),
                edges: new vis.DataSet(minimapEdges)
            };

            minimapNetwork = new vis.Network(minimap, minimapData, {
                nodes: {
                    shape: "dot",
                    size: 3,
                    font: {
                        size: 0
                    },
                    borderWidth: 1
                },
                edges: {
                    width: 1,
                    smooth: false
                },
                interaction: {
                    dragNodes: false,
                    dragView: false,
                    zoomView: false,
                    selectable: false,
                    tooltipDelay: 0
                },
                physics: {
                    enabled: false
                },
                groups: {
                    host: {
                        color: "#3498db"
                    },
                    service: {
                        color: "#2ecc71"
                    },
                    "up-only": {
                        color: "#e67e22"
                    },
                    pinned: {
                        color: "#9b59b6"
                    }
                }
            });

            minimapNetwork.once("afterDrawing", function () {
                updateMinimap();
            });
        }

        function updateMinimap() {
            if (!minimapNetwork || !network) return;

            const scale = network.getScale();
            const position = network.getViewPosition();

            minimapNetwork.moveTo({
                position: position,
                scale: 0.2 * scale,
                animation: false
            });
        }

        function applyFilters() {
            const serviceFilter = document.getElementById('service-filter').value;
            const portMin = parseInt(document.getElementById('port-min').value) || 1;
            const portMax = parseInt(document.getElementById('port-max').value) || 65535;
            const subnetFilter = document.getElementById('subnet-filter').value.trim();
            const showUncertain = document.getElementById('show-uncertain').checked;

            // Clear previous filter results
            filteredItems.hosts.clear();
            filteredItems.services.clear();
            filteredItems.nodes.clear();
            filteredItems.edges.clear();

            // Filter by service
            if (serviceFilter !== "all") {
                const serviceNodes = nodesDataset.get({
                    filter: node => node.type === "service" && node.service === serviceFilter
                });

                serviceNodes.forEach(node => {
                    filteredItems.services.add(node.id);

                    // Add connected hosts to the filter list
                    getConnectedHosts(node.id).forEach(hostId => {
                        filteredItems.hosts.add(hostId);
                    });
                });
            }

            // Filter by port range
            if (portMin > 1 || portMax < 65535) {
                scanData.hosts.forEach(host => {
                    const portsInRange = host.ports.filter(port => {
                        const portNumber = parseInt(port.port);
                        return portNumber >= portMin && portNumber <= portMax;
                    });

                    if (portsInRange.length > 0) {
                        const hostNodes = nodesDataset.get({
                            filter: node => node.type === "host" && node.ip === host.ip
                        });

                        if (hostNodes.length > 0) {
                            const hostNode = hostNodes[0];
                            filteredItems.hosts.add(hostNode.id);

                            // Add connected services to filter list
                            portsInRange.forEach(port => {
                                const serviceName = port.service.replace("?", "");
                                const serviceNodes = nodesDataset.get({
                                    filter: node => node.type === "service" && node.service === serviceName
                                });

                                if (serviceNodes.length > 0) {
                                    filteredItems.services.add(serviceNodes[0].id);
                                }
                            });
                        }
                    }
                });
            }

            // Filter by subnet
            if (subnetFilter) {
                const filteredNodes = nodesDataset.get({
                    filter: node =>
                        (node.type === "host" || node.type === "up-host") &&
                        node.ip &&
                        node.ip.startsWith(subnetFilter)
                });

                filteredNodes.forEach(node => {
                    if (node.type === "host") {
                        filteredItems.hosts.add(node.id);

                        // Add connected services
                        getConnectedServices(node.id).forEach(serviceId => {
                            filteredItems.services.add(serviceId);
                        });
                    } else {
                        filteredItems.nodes.add(node.id);
                    }
                });
            }

            // Filter uncertain services
            if (!showUncertain) {
                const uncertainServices = nodesDataset.get({
                    filter: node => node.type === "service" && node.uncertain
                });

                uncertainServices.forEach(node => {
                    filteredItems.nodes.add(node.id);
                });
            }

            // Apply filters by refreshing the graph
            refreshGraph();
        }

        function resetFilters() {
            document.getElementById('service-filter').value = "all";
            document.getElementById('port-min').value = "1";
            document.getElementById('port-max').value = "65535";
            document.getElementById('subnet-filter').value = "";
            document.getElementById('show-up-hosts').checked = true;
            document.getElementById('show-uncertain').checked = true;
            document.getElementById('highlight-tls').checked = true;

            filteredItems.hosts.clear();
            filteredItems.services.clear();
            filteredItems.nodes.clear();
            filteredItems.edges.clear();

            refreshGraph();
        }

        function refreshGraph() {
            if (network) {
                network.destroy();
                network = null;
            }
            if (minimapNetwork) {
                minimapNetwork.destroy();
                minimapNetwork = null;
            }

            // Clear datasets to prevent issues with stale data
            nodesDataset = null;
            edgesDataset = null;

            renderGraph();
        }

        function highlightTlsServices() {
            const highlight = document.getElementById('highlight-tls').checked;

            nodesDataset.get({
                filter: node => node.type === "service" && node.tls
            }).forEach(node => {
                nodesDataset.update({
                    id: node.id,
                    color: highlight ? {
                        border: "#e74c3c",
                        background: "#e74c3c",
                        highlight: {
                            border: "#c0392b",
                            background: "#e74c3c"
                        }
                    } : null
                });
            });
        }

        function highlightConnections(nodeId) {
            // Reset all nodes and edges to default appearance
            nodesDataset.update(nodesDataset.get().map(node => ({
                id: node.id,
                color: undefined,
                font: undefined
            })));

            edgesDataset.update(edgesDataset.get().map(edge => ({
                id: edge.id,
                color: undefined,
                width: edge.originalWidth || edge.width
            })));

            // Get the selected node
            const node = nodesDataset.get(nodeId);
            const connectedNodes = new Set();
            const connectedEdges = new Set();

            if (node.type === "host") {
                // Find all edges from this host
                edgesDataset.get({
                    filter: edge => edge.from === nodeId
                }).forEach(edge => {
                    connectedNodes.add(edge.to);
                    connectedEdges.add(edge.id);
                });
            } else if (node.type === "service") {
                // Find all edges to this service
                edgesDataset.get({
                    filter: edge => edge.to === nodeId
                }).forEach(edge => {
                    connectedNodes.add(edge.from);
                    connectedEdges.add(edge.id);
                });
            }

            // Highlight the selected node
            nodesDataset.update({
                id: nodeId,
                color: {
                    border: "#8e44ad",
                    background: "#9b59b6"
                },
                font: {
                    color: "#000000",
                    bold: true
                }
            });

            // Highlight connected nodes
            connectedNodes.forEach(id => {
                nodesDataset.update({
                    id: id,
                    color: {
                        border: "#16a085",
                        background: "#1abc9c"
                    },
                    font: {
                        bold: true
                    }
                });
            });

            // Highlight connected edges
            connectedEdges.forEach(id => {
                const edge = edgesDataset.get(id);
                edgesDataset.update({
                    id: id,
                    color: "#16a085",
                    width: 2 * (edge.width || 1),
                    originalWidth: edge.width || 1
                });
            });
        }

        function getConnectedHosts(serviceId) {
            return edgesDataset.get({
                filter: edge => edge.to === serviceId
            }).map(edge => edge.from);
        }

        function getConnectedServices(hostId) {
            return edgesDataset.get({
                filter: edge => edge.from === hostId
            }).map(edge => edge.to);
        }

        function countServiceInstances(serviceName) {
            let count = 0;
            scanData.hosts.forEach(host => {
                host.ports.forEach(port => {
                    if (port.service.replace("?", "") === serviceName) {
                        count++;
                    }
                });
            });
            return count;
        }

        function processSubnets() {
            subnetGroups = {};

            scanData.hosts.forEach(host => {
                const subnet = getSubnet(host.ip);

                if (!subnetGroups[subnet]) {
                    subnetGroups[subnet] = {
                        hosts: new Set(),
                        services: new Set()
                    };
                }

                subnetGroups[subnet].hosts.add(host.ip);

                host.ports.forEach(port => {
                    subnetGroups[subnet].services.add(port.service.replace("?", ""));
                });
            });

            if (scanData.hostsUp) {
                scanData.hostsUp.forEach(host => {
                    const subnet = getSubnet(host.ip);

                    if (!subnetGroups[subnet]) {
                        subnetGroups[subnet] = {
                            hosts: new Set(),
                            services: new Set()
                        };
                    }

                    subnetGroups[subnet].hosts.add(host.ip);
                });
            }
        }

        function getSubnet(ip) {
            const parts = ip.split(".");
            return parts.length === 4 ? `${parts[0]}.${parts[1]}.${parts[2]}` : ip;
        }

        function getSubnetGroup(ip) {
            return getSubnet(ip);
        }

        function formatNodeTooltip(host) {
            let tooltip = `<strong>${host.ip}</strong>`;

            if (host.hostname) {
                tooltip += `<br>${host.hostname}`;
            }

            tooltip += `<br>Open Ports: ${host.ports.length}`;

            if (host.ports.length > 0) {
                tooltip += "<br><br><strong>Ports:</strong><br>";

                host.ports.slice(0, 5).forEach(port => {
                    tooltip += `${port.port}/${port.protocol} (${port.service})${port.comment ? ` - ${port.comment}` : ""}<br>`;
                });

                if (host.ports.length > 5) {
                    tooltip += `... and ${host.ports.length - 5} more`;
                }
            }

            return tooltip;
        }

        function formatEdgeTooltip(ports) {
            let tooltip = "<strong>Ports:</strong><br>";

            ports.forEach(port => {
                tooltip += `${port.port}/${port.protocol} (${port.service})${port.comment ? ` - ${port.comment}` : ""}<br>`;
            });

            return tooltip;
        }

        function showTooltip(nodeId, pointer, isEdge = false, edgeData = null) {
            const tooltip = document.getElementById("graph-tooltip");
            let content = "";

            if (isEdge && edgeData) {
                content = edgeData.title || "Connection";
            } else {
                const node = nodesDataset.get(nodeId);
                if (node) {
                    content = node.title || node.label;
                }
            }

            if (content) {
                tooltip.innerHTML = content;

                // Use vis.js network's DOM positions
                const position = network.canvasToDOM(pointer);

                tooltip.style.left = `${position.x + 10}px`;
                tooltip.style.top = `${position.y + 10}px`;
                tooltip.style.display = "block";
            }
        }

        function hideTooltip() {
            document.getElementById("graph-tooltip").style.display = "none";
        }

        function exportNetworkImage() {
            if (!network) return;

            const canvas = network.canvas.frame.canvas;
            const link = document.createElement('a');
            link.download = 'unitas-network.png';
            link.href = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function saveCurrentView() {
            if (!network) return;

            const name = prompt("Enter a name for this view:");

            if (name) {
                savedViews[name] = {
                    position: network.getViewPosition(),
                    scale: network.getScale(),
                    pinnedNodes: Array.from(pinnedNodes),
                    filter: {
                        service: document.getElementById('service-filter').value,
                        portMin: document.getElementById('port-min').value,
                        portMax: document.getElementById('port-max').value,
                        subnet: document.getElementById('subnet-filter').value,
                        showUpHosts: document.getElementById('show-up-hosts').checked,
                        showUncertain: document.getElementById('show-uncertain').checked,
                        highlightTls: document.getElementById('highlight-tls').checked
                    }
                };

                alert(`View "${name}" saved successfully!`);
            }
        }

        function runAnalysis() {
            const analysisType = document.getElementById('analysis-type').value;
            const resultContainer = document.getElementById('analysis-result');
            const contentContainer = document.getElementById('analysis-content');

            if (analysisType === "none") {
                resultContainer.classList.add("hidden");
                return;
            }

            resultContainer.classList.remove("hidden");
            let content = "";

            switch (analysisType) {
                case "common-services":
                    content = findCommonServices();
                    break;
                case "segments":
                    content = identifyNetworkSegments();
                    break;
                case "unusual":
                    content = findUnusualPorts();
                    break;
                case "connectivity":
                    content = findMostConnectedHosts();
                    break;
            }

            contentContainer.innerHTML = content;
        }

        function findCommonServices() {
            const services = {};

            scanData.hosts.forEach(host => {
                const uniqueServices = new Set();

                host.ports.forEach(port => {
                    const serviceName = port.service.replace("?", "");
                    uniqueServices.add(serviceName);
                });

                uniqueServices.forEach(service => {
                    services[service] = (services[service] || 0) + 1;
                });
            });

            const commonServices = Object.entries(services)
                .sort((a, b) => b[1] - a[1])
                .filter(([_, count]) => count > 1);

            if (commonServices.length === 0) {
                return "<p>No common services found across multiple hosts.</p>";
            }

            let result = "<p>Services found on multiple hosts:</p><ul>";

            commonServices.forEach(([service, count]) => {
                const percentage = Math.round((count / scanData.hosts.length) * 100);
                result += `<li><strong>${service}</strong>: Found on ${count} hosts (${percentage}%)</li>`;
            });

            result += "</ul>";
            return result;
        }

        function identifyNetworkSegments() {
            let result = "<p>Identified network segments:</p><ul>";

            Object.entries(subnetGroups)
                .sort((a, b) => b[1].hosts.size - a[1].hosts.size)
                .forEach(([subnet, data]) => {
                    result += `<li><strong>${subnet}.0/24</strong>: ${data.hosts.size} hosts`;

                    if (data.services.size > 0) {
                        result += `, ${data.services.size} services`;

                        const topServices = Array.from(data.services).slice(0, 3);
                        if (topServices.length > 0) {
                            result += ` (${topServices.join(", ")}${data.services.size > 3 ? "..." : ""})`;
                        }
                    }

                    result += "</li>";
                });

            result += "</ul>";
            return result;
        }

        function findUnusualPorts() {
            const portCounts = {};
            const highPorts = [];
            const nonStandardPorts = [];

            scanData.hosts.forEach(host => {
                host.ports.forEach(port => {
                    const portNum = parseInt(port.port);

                    // Count port occurrences
                    portCounts[portNum] = (portCounts[portNum] || 0) + 1;

                    // Track high ports
                    if (portNum > 10000) {
                        highPorts.push({
                            ip: host.ip,
                            hostname: host.hostname,
                            port: port.port,
                            protocol: port.protocol,
                            service: port.service
                        });
                    }

                    // Track non-standard service ports
                    const standardPorts = {
                        'http': [80, 8080],
                        'https': [443, 8443],
                        'ssh': [22],
                        'ftp': [21],
                        'smtp': [25],
                        'dns': [53],
                        'rdp': [3389]
                    };

                    const service = port.service.replace("?", "");

                    if (standardPorts[service] && !standardPorts[service].includes(portNum)) {
                        nonStandardPorts.push({
                            ip: host.ip,
                            hostname: host.hostname,
                            port: port.port,
                            protocol: port.protocol,
                            service: port.service,
                            standardPorts: standardPorts[service].join(", ")
                        });
                    }
                });
            });

            // Find ports that appear only once
            const uncommonPorts = Object.entries(portCounts)
                .filter(([_, count]) => count === 1)
                .map(([port, _]) => parseInt(port))
                .sort((a, b) => a - b);

            let result = "";

            if (highPorts.length > 0) {
                result += "<p><strong>Unusual high ports (>10000):</strong></p><ul>";

                highPorts.slice(0, 10).forEach(port => {
                    result += `<li>${port.ip} - ${port.port}/${port.protocol} (${port.service})</li>`;
                });

                if (highPorts.length > 10) {
                    result += `<li>...and ${highPorts.length - 10} more</li>`;
                }

                result += "</ul>";
            }

            if (nonStandardPorts.length > 0) {
                result += "<p><strong>Services on non-standard ports:</strong></p><ul>";

                nonStandardPorts.forEach(port => {
                    result += `<li>${port.ip} - ${port.service} on port ${port.port} (standard: ${port.standardPorts})</li>`;
                });

                result += "</ul>";
            }

            if (uncommonPorts.length > 0) {
                result += "<p><strong>Uncommon ports (found on only one host):</strong></p>";
                result += `<p>${uncommonPorts.slice(0, 20).join(", ")}${uncommonPorts.length > 20 ? "..." : ""}</p>`;
            }

            if (result === "") {
                result = "<p>No unusual ports detected.</p>";
            }

            return result;
        }

        function findMostConnectedHosts() {
            const hosts = {};

            scanData.hosts.forEach(host => {
                hosts[host.ip] = {
                    ip: host.ip,
                    hostname: host.hostname,
                    ports: host.ports.length,
                    services: new Set(host.ports.map(port => port.service.replace("?", "")))
                };
            });

            const sortedHosts = Object.values(hosts).sort((a, b) => b.ports - a.ports);

            let result = "<p><strong>Hosts by connectivity (number of open ports):</strong></p><ul>";

            sortedHosts.slice(0, 10).forEach(host => {
                result += `<li><strong>${host.ip}</strong>${host.hostname ? ` (${host.hostname})` : ""}: ${host.ports} ports, ${host.services.size} unique services</li>`;
            });

            if (sortedHosts.length > 10) {
                result += `<li>...and ${sortedHosts.length - 10} more hosts</li>`;
            }

            result += "</ul>";
            return result;
        }

        // Setup event listeners for file input
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        fileInput.addEventListener('change', function () {
            if (this.files.length === 1) {
                handleFile(this.files[0]);
            } else {
                showError('Please select a single JSON file.');
            }
        });

        reloadBtn.addEventListener('click', function () {
            initialScreen.classList.remove('hidden');
            dataView.classList.add('hidden');
            errorMessage.classList.add('hidden');
            fileInput.value = '';
            scanData = null;
            network && (network.destroy(), network = null);
            minimapNetwork && (minimapNetwork.destroy(), minimapNetwork = null);
            pinnedNodes.clear();
            filteredItems.hosts.clear();
            filteredItems.services.clear();
            filteredItems.nodes.clear();
            filteredItems.edges.clear();
        });
    </script>
</body>

</html>