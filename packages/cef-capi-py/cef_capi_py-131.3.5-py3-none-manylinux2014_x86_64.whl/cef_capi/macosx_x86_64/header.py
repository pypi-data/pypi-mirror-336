# generated by 'clang2py'
# flags '-o ../../cef_capi/macosx_x86_64/header.py -i -k cdefstu include/capi/cef_accessibility_handler_capi.h include/capi/cef_app_capi.h include/capi/cef_audio_handler_capi.h include/capi/cef_auth_callback_capi.h include/capi/cef_base_capi.h include/capi/cef_browser_capi.h include/capi/cef_browser_process_handler_capi.h include/capi/cef_callback_capi.h include/capi/cef_client_capi.h include/capi/cef_command_handler_capi.h include/capi/cef_command_line_capi.h include/capi/cef_context_menu_handler_capi.h include/capi/cef_cookie_capi.h include/capi/cef_crash_util_capi.h include/capi/cef_devtools_message_observer_capi.h include/capi/cef_dialog_handler_capi.h include/capi/cef_display_handler_capi.h include/capi/cef_dom_capi.h include/capi/cef_download_handler_capi.h include/capi/cef_download_item_capi.h include/capi/cef_drag_data_capi.h include/capi/cef_drag_handler_capi.h include/capi/cef_file_util_capi.h include/capi/cef_find_handler_capi.h include/capi/cef_focus_handler_capi.h include/capi/cef_frame_capi.h include/capi/cef_frame_handler_capi.h include/capi/cef_i18n_util_capi.h include/capi/cef_image_capi.h include/capi/cef_jsdialog_handler_capi.h include/capi/cef_keyboard_handler_capi.h include/capi/cef_life_span_handler_capi.h include/capi/cef_load_handler_capi.h include/capi/cef_media_router_capi.h include/capi/cef_menu_model_capi.h include/capi/cef_menu_model_delegate_capi.h include/capi/cef_navigation_entry_capi.h include/capi/cef_origin_whitelist_capi.h include/capi/cef_parser_capi.h include/capi/cef_path_util_capi.h include/capi/cef_permission_handler_capi.h include/capi/cef_preference_capi.h include/capi/cef_print_handler_capi.h include/capi/cef_print_settings_capi.h include/capi/cef_process_message_capi.h include/capi/cef_process_util_capi.h include/capi/cef_registration_capi.h include/capi/cef_render_handler_capi.h include/capi/cef_render_process_handler_capi.h include/capi/cef_request_capi.h include/capi/cef_request_context_capi.h include/capi/cef_request_context_handler_capi.h include/capi/cef_request_handler_capi.h include/capi/cef_resource_bundle_capi.h include/capi/cef_resource_bundle_handler_capi.h include/capi/cef_resource_handler_capi.h include/capi/cef_resource_request_handler_capi.h include/capi/cef_response_capi.h include/capi/cef_response_filter_capi.h include/capi/cef_scheme_capi.h include/capi/cef_server_capi.h include/capi/cef_shared_memory_region_capi.h include/capi/cef_shared_process_message_builder_capi.h include/capi/cef_ssl_info_capi.h include/capi/cef_ssl_status_capi.h include/capi/cef_stream_capi.h include/capi/cef_string_visitor_capi.h include/capi/cef_task_capi.h include/capi/cef_task_manager_capi.h include/capi/cef_thread_capi.h include/capi/cef_trace_capi.h include/capi/cef_unresponsive_process_callback_capi.h include/capi/cef_urlrequest_capi.h include/capi/cef_v8_capi.h include/capi/cef_values_capi.h include/capi/cef_waitable_event_capi.h include/capi/cef_x509_certificate_capi.h include/capi/cef_xml_reader_capi.h include/capi/cef_zip_reader_capi.h include/cef_version.h -r cef.* -r CEF.* --clang-args=-I.'
# -*- coding: utf-8 -*-
#
# TARGET arch is: ['-I.']
# WORD_SIZE is: 8
# POINTER_SIZE is: 8
# LONGDOUBLE_SIZE is: 16
#
import ctypes


class AsDictMixin:
    @classmethod
    def as_dict(cls, self):
        result = {}
        if not isinstance(self, AsDictMixin):
            # not a structure, assume it's already a python object
            return self
        if not hasattr(cls, "_fields_"):
            return result
        # sys.version_info >= (3, 5)
        # for (field, *_) in cls._fields_:  # noqa
        for field_tuple in cls._fields_:  # noqa
            field = field_tuple[0]
            if field.startswith('PADDING_'):
                continue
            value = getattr(self, field)
            type_ = type(value)
            if hasattr(value, "_length_") and hasattr(value, "_type_"):
                # array
                if not hasattr(type_, "as_dict"):
                    value = [v for v in value]
                else:
                    type_ = type_._type_
                    value = [type_.as_dict(v) for v in value]
            elif hasattr(value, "contents") and hasattr(value, "_type_"):
                # pointer
                try:
                    if not hasattr(type_, "as_dict"):
                        value = value.contents
                    else:
                        type_ = type_._type_
                        value = type_.as_dict(value.contents)
                except ValueError:
                    # nullptr
                    value = None
            elif isinstance(value, AsDictMixin):
                # other structure
                value = type_.as_dict(value)
            result[field] = value
        return result


class Structure(ctypes.Structure, AsDictMixin):

    def __init__(self, *args, **kwds):
        # We don't want to use positional arguments fill PADDING_* fields

        args = dict(zip(self.__class__._field_names_(), args))
        args.update(kwds)
        super(Structure, self).__init__(**args)

    @classmethod
    def _field_names_(cls):
        if hasattr(cls, '_fields_'):
            return (f[0] for f in cls._fields_ if not f[0].startswith('PADDING'))
        else:
            return ()

    @classmethod
    def get_type(cls, field):
        for f in cls._fields_:
            if f[0] == field:
                return f[1]
        return None

    @classmethod
    def bind(cls, bound_fields):
        fields = {}
        for name, type_ in cls._fields_:
            if hasattr(type_, "restype"):
                if name in bound_fields:
                    if bound_fields[name] is None:
                        fields[name] = type_()
                    else:
                        # use a closure to capture the callback from the loop scope
                        fields[name] = (
                            type_((lambda callback: lambda *args: callback(*args))(
                                bound_fields[name]))
                        )
                    del bound_fields[name]
                else:
                    # default callback implementation (does nothing)
                    try:
                        default_ = type_(0).restype().value
                    except TypeError:
                        default_ = None
                    fields[name] = type_((
                        lambda default_: lambda *args: default_)(default_))
            else:
                # not a callback function, use default initialization
                if name in bound_fields:
                    fields[name] = bound_fields[name]
                    del bound_fields[name]
                else:
                    fields[name] = type_()
        if len(bound_fields) != 0:
            raise ValueError(
                "Cannot bind the following unknown callback(s) {}.{}".format(
                    cls.__name__, bound_fields.keys()
            ))
        return cls(**fields)


class Union(ctypes.Union, AsDictMixin):
    pass



c_int128 = ctypes.c_ubyte*16
c_uint128 = c_int128
void = None
if ctypes.sizeof(ctypes.c_longdouble) == 16:
    c_long_double_t = ctypes.c_longdouble
else:
    c_long_double_t = ctypes.c_ubyte*16

def string_cast(char_pointer, encoding='utf-8', errors='strict'):
    value = ctypes.cast(char_pointer, ctypes.c_char_p).value
    if value is not None and encoding is not None:
        value = value.decode(encoding, errors=errors)
    return value


def char_pointer_cast(string, encoding='utf-8'):
    if encoding is not None:
        try:
            string = string.encode(encoding)
        except AttributeError:
            # In Python3, bytes has no encode attribute
            pass
    string = ctypes.c_char_p(string)
    return ctypes.cast(string, ctypes.POINTER(ctypes.c_char))



class FunctionFactoryStub:
    def __getattr__(self, _):
      return ctypes.CFUNCTYPE(lambda y:y)

# libraries['FIXME_STUB'] explanation
# As you did not list (-l libraryname.so) a library that exports this function
# This is a non-working stub instead. 
# You can either re-run clan2py with -l /path/to/library.so
# Or manually fix this by comment the ctypes.CDLL loading
_libraries = {}
from cef_capi import LIBCEF_PATH
_libraries['FIXME_STUB'] = ctypes.CDLL(str(LIBCEF_PATH))


# CEF string type definitions. Whomever allocates |str| is responsible for
# providing an appropriate |dtor| implementation that will free the string in
# the same memory space. When reusing an existing string structure make sure to
# call |dtor| for the old value before assigning new |str| and |dtor| values.
# Static strings will have a NULL |dtor| value. Using the below functions if you
# want this managed for you.
class struct__cef_string_wide_t(Structure):
    pass

struct__cef_string_wide_t._pack_ = 1 # source:False
struct__cef_string_wide_t._fields_ = [
    ('str', ctypes.POINTER(ctypes.c_int32)),
    ('length', ctypes.c_uint64),
    ('dtor', ctypes.CFUNCTYPE(None, ctypes.POINTER(ctypes.c_int32))),
]

# CEF string type definitions. Whomever allocates |str| is responsible for
# providing an appropriate |dtor| implementation that will free the string in
# the same memory space. When reusing an existing string structure make sure to
# call |dtor| for the old value before assigning new |str| and |dtor| values.
# Static strings will have a NULL |dtor| value. Using the below functions if you
# want this managed for you.
# CEF string type definitions. Whomever allocates |str| is responsible for
# providing an appropriate |dtor| implementation that will free the string in
# the same memory space. When reusing an existing string structure make sure to
# call |dtor| for the old value before assigning new |str| and |dtor| values.
# Static strings will have a NULL |dtor| value. Using the below functions if you
# want this managed for you.
cef_string_wide_t = struct__cef_string_wide_t
class struct__cef_string_utf8_t(Structure):
    pass

struct__cef_string_utf8_t._pack_ = 1 # source:False
struct__cef_string_utf8_t._fields_ = [
    ('str', ctypes.POINTER(ctypes.c_char)),
    ('length', ctypes.c_uint64),
    ('dtor', ctypes.CFUNCTYPE(None, ctypes.POINTER(ctypes.c_char))),
]

cef_string_utf8_t = struct__cef_string_utf8_t
class struct__cef_string_utf16_t(Structure):
    pass

struct__cef_string_utf16_t._pack_ = 1 # source:False
struct__cef_string_utf16_t._fields_ = [
    ('str', ctypes.POINTER(ctypes.c_uint16)),
    ('length', ctypes.c_uint64),
    ('dtor', ctypes.CFUNCTYPE(None, ctypes.POINTER(ctypes.c_uint16))),
]

cef_string_utf16_t = struct__cef_string_utf16_t
# These functions set string values. If |copy| is true (1) the value will be
# copied instead of referenced. It is up to the user to properly manage the
# lifespan of references.
# These functions set string values. If |copy| is true (1) the value will be
# copied instead of referenced. It is up to the user to properly manage the
# lifespan of references.
size_t = ctypes.c_uint64
cef_string_wide_set = _libraries['FIXME_STUB'].cef_string_wide_set
cef_string_wide_set.restype = ctypes.c_int32
# cef_string_wide_set(src, src_len, output, copy)
cef_string_wide_set.argtypes = [ctypes.POINTER(ctypes.c_int32), size_t, ctypes.POINTER(struct__cef_string_wide_t), ctypes.c_int32]
cef_string_utf8_set = _libraries['FIXME_STUB'].cef_string_utf8_set
cef_string_utf8_set.restype = ctypes.c_int32
# cef_string_utf8_set(src, src_len, output, copy)
cef_string_utf8_set.argtypes = [ctypes.POINTER(ctypes.c_char), size_t, ctypes.POINTER(struct__cef_string_utf8_t), ctypes.c_int32]
cef_string_utf16_set = _libraries['FIXME_STUB'].cef_string_utf16_set
cef_string_utf16_set.restype = ctypes.c_int32
# cef_string_utf16_set(src, src_len, output, copy)
cef_string_utf16_set.argtypes = [ctypes.POINTER(ctypes.c_uint16), size_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# These functions clear string values. The structure itself is not freed.
# These functions clear string values. The structure itself is not freed.
cef_string_wide_clear = _libraries['FIXME_STUB'].cef_string_wide_clear
cef_string_wide_clear.restype = None
# cef_string_wide_clear(str)
cef_string_wide_clear.argtypes = [ctypes.POINTER(struct__cef_string_wide_t)]
cef_string_utf8_clear = _libraries['FIXME_STUB'].cef_string_utf8_clear
cef_string_utf8_clear.restype = None
# cef_string_utf8_clear(str)
cef_string_utf8_clear.argtypes = [ctypes.POINTER(struct__cef_string_utf8_t)]
cef_string_utf16_clear = _libraries['FIXME_STUB'].cef_string_utf16_clear
cef_string_utf16_clear.restype = None
# cef_string_utf16_clear(str)
cef_string_utf16_clear.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# These functions compare two string values with the same results as strcmp().
# These functions compare two string values with the same results as strcmp().
cef_string_wide_cmp = _libraries['FIXME_STUB'].cef_string_wide_cmp
cef_string_wide_cmp.restype = ctypes.c_int32
# cef_string_wide_cmp(str1, str2)
cef_string_wide_cmp.argtypes = [ctypes.POINTER(struct__cef_string_wide_t), ctypes.POINTER(struct__cef_string_wide_t)]
cef_string_utf8_cmp = _libraries['FIXME_STUB'].cef_string_utf8_cmp
cef_string_utf8_cmp.restype = ctypes.c_int32
# cef_string_utf8_cmp(str1, str2)
cef_string_utf8_cmp.argtypes = [ctypes.POINTER(struct__cef_string_utf8_t), ctypes.POINTER(struct__cef_string_utf8_t)]
cef_string_utf16_cmp = _libraries['FIXME_STUB'].cef_string_utf16_cmp
cef_string_utf16_cmp.restype = ctypes.c_int32
# cef_string_utf16_cmp(str1, str2)
cef_string_utf16_cmp.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# These functions convert between UTF-8, -16, and -32 strings. They are
# potentially slow so unnecessary conversions should be avoided. The best
# possible result will always be written to |output| with the boolean return
# value indicating whether the conversion is 100% valid.
# These functions convert between UTF-8, -16, and -32 strings. They are
# potentially slow so unnecessary conversions should be avoided. The best
# possible result will always be written to |output| with the boolean return
# value indicating whether the conversion is 100% valid.
cef_string_wide_to_utf8 = _libraries['FIXME_STUB'].cef_string_wide_to_utf8
cef_string_wide_to_utf8.restype = ctypes.c_int32
# cef_string_wide_to_utf8(src, src_len, output)
cef_string_wide_to_utf8.argtypes = [ctypes.POINTER(ctypes.c_int32), size_t, ctypes.POINTER(struct__cef_string_utf8_t)]
cef_string_utf8_to_wide = _libraries['FIXME_STUB'].cef_string_utf8_to_wide
cef_string_utf8_to_wide.restype = ctypes.c_int32
# cef_string_utf8_to_wide(src, src_len, output)
cef_string_utf8_to_wide.argtypes = [ctypes.POINTER(ctypes.c_char), size_t, ctypes.POINTER(struct__cef_string_wide_t)]
cef_string_wide_to_utf16 = _libraries['FIXME_STUB'].cef_string_wide_to_utf16
cef_string_wide_to_utf16.restype = ctypes.c_int32
# cef_string_wide_to_utf16(src, src_len, output)
cef_string_wide_to_utf16.argtypes = [ctypes.POINTER(ctypes.c_int32), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
cef_string_utf16_to_wide = _libraries['FIXME_STUB'].cef_string_utf16_to_wide
cef_string_utf16_to_wide.restype = ctypes.c_int32
# cef_string_utf16_to_wide(src, src_len, output)
cef_string_utf16_to_wide.argtypes = [ctypes.POINTER(ctypes.c_uint16), size_t, ctypes.POINTER(struct__cef_string_wide_t)]
cef_string_utf8_to_utf16 = _libraries['FIXME_STUB'].cef_string_utf8_to_utf16
cef_string_utf8_to_utf16.restype = ctypes.c_int32
# cef_string_utf8_to_utf16(src, src_len, output)
cef_string_utf8_to_utf16.argtypes = [ctypes.POINTER(ctypes.c_char), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
cef_string_utf16_to_utf8 = _libraries['FIXME_STUB'].cef_string_utf16_to_utf8
cef_string_utf16_to_utf8.restype = ctypes.c_int32
# cef_string_utf16_to_utf8(src, src_len, output)
cef_string_utf16_to_utf8.argtypes = [ctypes.POINTER(ctypes.c_uint16), size_t, ctypes.POINTER(struct__cef_string_utf8_t)]
# These functions convert an ASCII string, typically a hardcoded constant, to a
# Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know the
# string is ASCII.
# These functions convert an ASCII string, typically a hardcoded constant, to a
# Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know the
# string is ASCII.
cef_string_ascii_to_wide = _libraries['FIXME_STUB'].cef_string_ascii_to_wide
cef_string_ascii_to_wide.restype = ctypes.c_int32
# cef_string_ascii_to_wide(src, src_len, output)
cef_string_ascii_to_wide.argtypes = [ctypes.POINTER(ctypes.c_char), size_t, ctypes.POINTER(struct__cef_string_wide_t)]
cef_string_ascii_to_utf16 = _libraries['FIXME_STUB'].cef_string_ascii_to_utf16
cef_string_ascii_to_utf16.restype = ctypes.c_int32
# cef_string_ascii_to_utf16(src, src_len, output)
cef_string_ascii_to_utf16.argtypes = [ctypes.POINTER(ctypes.c_char), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# It is sometimes necessary for the system to allocate string structures with
# the expectation that the user will free them. The userfree types act as a hint
# that the user is responsible for freeing the structure.
# It is sometimes necessary for the system to allocate string structures with
# the expectation that the user will free them. The userfree types act as a hint
# that the user is responsible for freeing the structure.
cef_string_userfree_wide_t = ctypes.POINTER(struct__cef_string_wide_t)
cef_string_userfree_utf8_t = ctypes.POINTER(struct__cef_string_utf8_t)
cef_string_userfree_utf16_t = ctypes.POINTER(struct__cef_string_utf16_t)
# These functions allocate a new string structure. They must be freed by calling
# the associated free function.
# These functions allocate a new string structure. They must be freed by calling
# the associated free function.
cef_string_userfree_wide_alloc = _libraries['FIXME_STUB'].cef_string_userfree_wide_alloc
cef_string_userfree_wide_alloc.restype = cef_string_userfree_wide_t
# cef_string_userfree_wide_alloc()
cef_string_userfree_wide_alloc.argtypes = []
cef_string_userfree_utf8_alloc = _libraries['FIXME_STUB'].cef_string_userfree_utf8_alloc
cef_string_userfree_utf8_alloc.restype = cef_string_userfree_utf8_t
# cef_string_userfree_utf8_alloc()
cef_string_userfree_utf8_alloc.argtypes = []
cef_string_userfree_utf16_alloc = _libraries['FIXME_STUB'].cef_string_userfree_utf16_alloc
cef_string_userfree_utf16_alloc.restype = cef_string_userfree_utf16_t
# cef_string_userfree_utf16_alloc()
cef_string_userfree_utf16_alloc.argtypes = []
# These functions free the string structure allocated by the associated alloc
# function. Any string contents will first be cleared.
# These functions free the string structure allocated by the associated alloc
# function. Any string contents will first be cleared.
cef_string_userfree_wide_free = _libraries['FIXME_STUB'].cef_string_userfree_wide_free
cef_string_userfree_wide_free.restype = None
# cef_string_userfree_wide_free(str)
cef_string_userfree_wide_free.argtypes = [cef_string_userfree_wide_t]
cef_string_userfree_utf8_free = _libraries['FIXME_STUB'].cef_string_userfree_utf8_free
cef_string_userfree_utf8_free.restype = None
# cef_string_userfree_utf8_free(str)
cef_string_userfree_utf8_free.argtypes = [cef_string_userfree_utf8_t]
cef_string_userfree_utf16_free = _libraries['FIXME_STUB'].cef_string_userfree_utf16_free
cef_string_userfree_utf16_free.restype = None
# cef_string_userfree_utf16_free(str)
cef_string_userfree_utf16_free.argtypes = [cef_string_userfree_utf16_t]
# These functions convert utf16 string case using the current ICU locale. This
# may change the length of the string in some cases.
# These functions convert utf16 string case using the current ICU locale. This
# may change the length of the string in some cases.
cef_string_utf16_to_lower = _libraries['FIXME_STUB'].cef_string_utf16_to_lower
cef_string_utf16_to_lower.restype = ctypes.c_int32
# cef_string_utf16_to_lower(src, src_len, output)
cef_string_utf16_to_lower.argtypes = [ctypes.POINTER(ctypes.c_uint16), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
cef_string_utf16_to_upper = _libraries['FIXME_STUB'].cef_string_utf16_to_upper
cef_string_utf16_to_upper.restype = ctypes.c_int32
# cef_string_utf16_to_upper(src, src_len, output)
cef_string_utf16_to_upper.argtypes = [ctypes.POINTER(ctypes.c_uint16), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
cef_char_t = ctypes.c_uint16
cef_string_userfree_t = ctypes.POINTER(struct__cef_string_utf16_t)
cef_string_t = struct__cef_string_utf16_t
class struct__cef_string_list_t(Structure):
    pass

# CEF string maps are a set of key/value string pairs.
# CEF string maps are a set of key/value string pairs.
cef_string_list_t = ctypes.POINTER(struct__cef_string_list_t)
# Allocate a new string map.
# Allocate a new string map.
cef_string_list_alloc = _libraries['FIXME_STUB'].cef_string_list_alloc
cef_string_list_alloc.restype = cef_string_list_t
# cef_string_list_alloc()
cef_string_list_alloc.argtypes = []
# Return the number of elements in the string list.
# Return the number of elements in the string list.
cef_string_list_size = _libraries['FIXME_STUB'].cef_string_list_size
cef_string_list_size.restype = size_t
# cef_string_list_size(list)
cef_string_list_size.argtypes = [cef_string_list_t]
# Retrieve the value at the specified zero-based string list index. Returns true
# (1) if the value was successfully retrieved.
# Retrieve the value at the specified zero-based string list index. Returns true
# (1) if the value was successfully retrieved.
cef_string_list_value = _libraries['FIXME_STUB'].cef_string_list_value
cef_string_list_value.restype = ctypes.c_int32
# cef_string_list_value(list, index, value)
cef_string_list_value.argtypes = [cef_string_list_t, size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Append a new value at the end of the string list.
# Append a new value at the end of the string list.
cef_string_list_append = _libraries['FIXME_STUB'].cef_string_list_append
cef_string_list_append.restype = None
# cef_string_list_append(list, value)
cef_string_list_append.argtypes = [cef_string_list_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Clear the string list.
# Clear the string list.
cef_string_list_clear = _libraries['FIXME_STUB'].cef_string_list_clear
cef_string_list_clear.restype = None
# cef_string_list_clear(list)
cef_string_list_clear.argtypes = [cef_string_list_t]
# Free the string list.
# Free the string list.
cef_string_list_free = _libraries['FIXME_STUB'].cef_string_list_free
cef_string_list_free.restype = None
# cef_string_list_free(list)
cef_string_list_free.argtypes = [cef_string_list_t]
# Creates a copy of an existing string list.
# Creates a copy of an existing string list.
cef_string_list_copy = _libraries['FIXME_STUB'].cef_string_list_copy
cef_string_list_copy.restype = cef_string_list_t
# cef_string_list_copy(list)
cef_string_list_copy.argtypes = [cef_string_list_t]
class struct__cef_string_map_t(Structure):
    pass

# CEF string maps are a set of key/value string pairs.
# CEF string maps are a set of key/value string pairs.
cef_string_map_t = ctypes.POINTER(struct__cef_string_map_t)
# Allocate a new string map.
# Allocate a new string map.
cef_string_map_alloc = _libraries['FIXME_STUB'].cef_string_map_alloc
cef_string_map_alloc.restype = cef_string_map_t
# cef_string_map_alloc()
cef_string_map_alloc.argtypes = []
# Return the number of elements in the string map.
# Return the number of elements in the string map.
cef_string_map_size = _libraries['FIXME_STUB'].cef_string_map_size
cef_string_map_size.restype = size_t
# cef_string_map_size(map)
cef_string_map_size.argtypes = [cef_string_map_t]
# Return the value assigned to the specified key.
# Return the value assigned to the specified key.
cef_string_map_find = _libraries['FIXME_STUB'].cef_string_map_find
cef_string_map_find.restype = ctypes.c_int32
# cef_string_map_find(map, key, value)
cef_string_map_find.argtypes = [cef_string_map_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Return the key at the specified zero-based string map index.
# Return the key at the specified zero-based string map index.
cef_string_map_key = _libraries['FIXME_STUB'].cef_string_map_key
cef_string_map_key.restype = ctypes.c_int32
# cef_string_map_key(map, index, key)
cef_string_map_key.argtypes = [cef_string_map_t, size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Return the value at the specified zero-based string map index.
# Return the value at the specified zero-based string map index.
cef_string_map_value = _libraries['FIXME_STUB'].cef_string_map_value
cef_string_map_value.restype = ctypes.c_int32
# cef_string_map_value(map, index, value)
cef_string_map_value.argtypes = [cef_string_map_t, size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Append a new key/value pair at the end of the string map. If the key exists,
# overwrite the existing value with a new value w/o changing the pair order.
# Append a new key/value pair at the end of the string map. If the key exists,
# overwrite the existing value with a new value w/o changing the pair order.
cef_string_map_append = _libraries['FIXME_STUB'].cef_string_map_append
cef_string_map_append.restype = ctypes.c_int32
# cef_string_map_append(map, key, value)
cef_string_map_append.argtypes = [cef_string_map_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Clear the string map.
# Clear the string map.
cef_string_map_clear = _libraries['FIXME_STUB'].cef_string_map_clear
cef_string_map_clear.restype = None
# cef_string_map_clear(map)
cef_string_map_clear.argtypes = [cef_string_map_t]
# Free the string map.
# Free the string map.
cef_string_map_free = _libraries['FIXME_STUB'].cef_string_map_free
cef_string_map_free.restype = None
# cef_string_map_free(map)
cef_string_map_free.argtypes = [cef_string_map_t]
class struct__cef_string_multimap_t(Structure):
    pass

# CEF string multimaps are a set of key/value string pairs. More than one value
# can be assigned to a single key.
# CEF string multimaps are a set of key/value string pairs. More than one value
# can be assigned to a single key.
cef_string_multimap_t = ctypes.POINTER(struct__cef_string_multimap_t)
# Allocate a new string multimap.
# Allocate a new string multimap.
cef_string_multimap_alloc = _libraries['FIXME_STUB'].cef_string_multimap_alloc
cef_string_multimap_alloc.restype = cef_string_multimap_t
# cef_string_multimap_alloc()
cef_string_multimap_alloc.argtypes = []
# Return the number of elements in the string multimap.
# Return the number of elements in the string multimap.
cef_string_multimap_size = _libraries['FIXME_STUB'].cef_string_multimap_size
cef_string_multimap_size.restype = size_t
# cef_string_multimap_size(map)
cef_string_multimap_size.argtypes = [cef_string_multimap_t]
# Return the number of values with the specified key.
# Return the number of values with the specified key.
cef_string_multimap_find_count = _libraries['FIXME_STUB'].cef_string_multimap_find_count
cef_string_multimap_find_count.restype = size_t
# cef_string_multimap_find_count(map, key)
cef_string_multimap_find_count.argtypes = [cef_string_multimap_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Return the value_index-th value with the specified key.
# Return the value_index-th value with the specified key.
cef_string_multimap_enumerate = _libraries['FIXME_STUB'].cef_string_multimap_enumerate
cef_string_multimap_enumerate.restype = ctypes.c_int32
# cef_string_multimap_enumerate(map, key, value_index, value)
cef_string_multimap_enumerate.argtypes = [cef_string_multimap_t, ctypes.POINTER(struct__cef_string_utf16_t), size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Return the key at the specified zero-based string multimap index.
# Return the key at the specified zero-based string multimap index.
cef_string_multimap_key = _libraries['FIXME_STUB'].cef_string_multimap_key
cef_string_multimap_key.restype = ctypes.c_int32
# cef_string_multimap_key(map, index, key)
cef_string_multimap_key.argtypes = [cef_string_multimap_t, size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Return the value at the specified zero-based string multimap index.
# Return the value at the specified zero-based string multimap index.
cef_string_multimap_value = _libraries['FIXME_STUB'].cef_string_multimap_value
cef_string_multimap_value.restype = ctypes.c_int32
# cef_string_multimap_value(map, index, value)
cef_string_multimap_value.argtypes = [cef_string_multimap_t, size_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Append a new key/value pair at the end of the string multimap.
# Append a new key/value pair at the end of the string multimap.
cef_string_multimap_append = _libraries['FIXME_STUB'].cef_string_multimap_append
cef_string_multimap_append.restype = ctypes.c_int32
# cef_string_multimap_append(map, key, value)
cef_string_multimap_append.argtypes = [cef_string_multimap_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Clear the string multimap.
# Clear the string multimap.
cef_string_multimap_clear = _libraries['FIXME_STUB'].cef_string_multimap_clear
cef_string_multimap_clear.restype = None
# cef_string_multimap_clear(map)
cef_string_multimap_clear.argtypes = [cef_string_multimap_t]
# Free the string multimap.
# Free the string multimap.
cef_string_multimap_free = _libraries['FIXME_STUB'].cef_string_multimap_free
cef_string_multimap_free.restype = None
# cef_string_multimap_free(map)
cef_string_multimap_free.argtypes = [cef_string_multimap_t]
# Represents a wall clock time in UTC. Values are not guaranteed to be
# monotonically non-decreasing and are subject to large amounts of skew. Time is
# stored internally as microseconds since the Windows epoch (1601).
class struct__cef_basetime_t(Structure):
    pass

struct__cef_basetime_t._pack_ = 1 # source:False
struct__cef_basetime_t._fields_ = [
    ('val', ctypes.c_int64),
]

# Represents a wall clock time in UTC. Values are not guaranteed to be
# monotonically non-decreasing and are subject to large amounts of skew. Time is
# stored internally as microseconds since the Windows epoch (1601).
# Represents a wall clock time in UTC. Values are not guaranteed to be
# monotonically non-decreasing and are subject to large amounts of skew. Time is
# stored internally as microseconds since the Windows epoch (1601).
cef_basetime_t = struct__cef_basetime_t
# Time information. Values should always be in UTC.
class struct__cef_time_t(Structure):
    pass

struct__cef_time_t._pack_ = 1 # source:False
struct__cef_time_t._fields_ = [
    ('year', ctypes.c_int32),
    ('month', ctypes.c_int32),
    ('day_of_week', ctypes.c_int32),
    ('day_of_month', ctypes.c_int32),
    ('hour', ctypes.c_int32),
    ('minute', ctypes.c_int32),
    ('second', ctypes.c_int32),
    ('millisecond', ctypes.c_int32),
]

# Time information. Values should always be in UTC.
# Time information. Values should always be in UTC.
cef_time_t = struct__cef_time_t
# Converts cef_time_t to/from time_t. Returns true (1) on success and false (0)
# on failure.
# Converts cef_time_t to/from time_t. Returns true (1) on success and false (0)
# on failure.
cef_time_to_timet = _libraries['FIXME_STUB'].cef_time_to_timet
cef_time_to_timet.restype = ctypes.c_int32
# cef_time_to_timet(cef_time, time)
cef_time_to_timet.argtypes = [ctypes.POINTER(struct__cef_time_t), ctypes.POINTER(ctypes.c_int64)]
time_t = ctypes.c_int64
cef_time_from_timet = _libraries['FIXME_STUB'].cef_time_from_timet
cef_time_from_timet.restype = ctypes.c_int32
# cef_time_from_timet(time, cef_time)
cef_time_from_timet.argtypes = [time_t, ctypes.POINTER(struct__cef_time_t)]
# Converts cef_time_t to/from a double which is the number of seconds since
# epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0
# means "not initialized". Returns true (1) on success and false (0) on failure.
# Converts cef_time_t to/from a double which is the number of seconds since
# epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0
# means "not initialized". Returns true (1) on success and false (0) on failure.
cef_time_to_doublet = _libraries['FIXME_STUB'].cef_time_to_doublet
cef_time_to_doublet.restype = ctypes.c_int32
# cef_time_to_doublet(cef_time, time)
cef_time_to_doublet.argtypes = [ctypes.POINTER(struct__cef_time_t), ctypes.POINTER(ctypes.c_double)]
cef_time_from_doublet = _libraries['FIXME_STUB'].cef_time_from_doublet
cef_time_from_doublet.restype = ctypes.c_int32
# cef_time_from_doublet(time, cef_time)
cef_time_from_doublet.argtypes = [ctypes.c_double, ctypes.POINTER(struct__cef_time_t)]
# Retrieve the current system time. Returns true (1) on success and false (0) on
# failure.
# Retrieve the current system time. Returns true (1) on success and false (0) on
# failure.
cef_time_now = _libraries['FIXME_STUB'].cef_time_now
cef_time_now.restype = ctypes.c_int32
# cef_time_now(cef_time)
cef_time_now.argtypes = [ctypes.POINTER(struct__cef_time_t)]
# Retrieve the current system time.
# Retrieve the current system time.
cef_basetime_now = _libraries['FIXME_STUB'].cef_basetime_now
cef_basetime_now.restype = cef_basetime_t
# cef_basetime_now()
cef_basetime_now.argtypes = []
# Retrieve the delta in milliseconds between two time values. Returns true (1)
# on success and false (0) on failure.
# Retrieve the delta in milliseconds between two time values. Returns true (1)
# on success and false (0) on failure.
cef_time_delta = _libraries['FIXME_STUB'].cef_time_delta
cef_time_delta.restype = ctypes.c_int32
# cef_time_delta(cef_time1, cef_time2, delta)
cef_time_delta.argtypes = [ctypes.POINTER(struct__cef_time_t), ctypes.POINTER(struct__cef_time_t), ctypes.POINTER(ctypes.c_int64)]
# Converts cef_time_t to cef_basetime_t. Returns true (1) on success and false
# (0) on failure.
# Converts cef_time_t to cef_basetime_t. Returns true (1) on success and false
# (0) on failure.
cef_time_to_basetime = _libraries['FIXME_STUB'].cef_time_to_basetime
cef_time_to_basetime.restype = ctypes.c_int32
# cef_time_to_basetime(from, to)
cef_time_to_basetime.argtypes = [ctypes.POINTER(struct__cef_time_t), ctypes.POINTER(struct__cef_basetime_t)]
# Converts cef_basetime_t to cef_time_t. Returns true (1) on success and false
# (0) on failure.
# Converts cef_basetime_t to cef_time_t. Returns true (1) on success and false
# (0) on failure.
cef_time_from_basetime = _libraries['FIXME_STUB'].cef_time_from_basetime
cef_time_from_basetime.restype = ctypes.c_int32
# cef_time_from_basetime(from, to)
cef_time_from_basetime.argtypes = [cef_basetime_t, ctypes.POINTER(struct__cef_time_t)]
# Supported content setting types. Some types are platform-specific or only
# supported with Chrome style. Should be kept in sync with Chromium's
# ContentSettingsType type.
# Supported content setting types. Some types are platform-specific or only
# supported with Chrome style. Should be kept in sync with Chromium's
# ContentSettingsType type.

# values for enumeration 'c__EA_cef_content_setting_types_t'
c__EA_cef_content_setting_types_t__enumvalues = {
    0: 'CEF_CONTENT_SETTING_TYPE_COOKIES',
    1: 'CEF_CONTENT_SETTING_TYPE_IMAGES',
    2: 'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT',
    3: 'CEF_CONTENT_SETTING_TYPE_POPUPS',
    4: 'CEF_CONTENT_SETTING_TYPE_GEOLOCATION',
    5: 'CEF_CONTENT_SETTING_TYPE_NOTIFICATIONS',
    6: 'CEF_CONTENT_SETTING_TYPE_AUTO_SELECT_CERTIFICATE',
    7: 'CEF_CONTENT_SETTING_TYPE_MIXEDSCRIPT',
    8: 'CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_MIC',
    9: 'CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_CAMERA',
    10: 'CEF_CONTENT_SETTING_TYPE_PROTOCOL_HANDLERS',
    11: 'CEF_CONTENT_SETTING_TYPE_DEPRECATED_PPAPI_BROKER',
    12: 'CEF_CONTENT_SETTING_TYPE_AUTOMATIC_DOWNLOADS',
    13: 'CEF_CONTENT_SETTING_TYPE_MIDI_SYSEX',
    14: 'CEF_CONTENT_SETTING_TYPE_SSL_CERT_DECISIONS',
    15: 'CEF_CONTENT_SETTING_TYPE_PROTECTED_MEDIA_IDENTIFIER',
    16: 'CEF_CONTENT_SETTING_TYPE_APP_BANNER',
    17: 'CEF_CONTENT_SETTING_TYPE_SITE_ENGAGEMENT',
    18: 'CEF_CONTENT_SETTING_TYPE_DURABLE_STORAGE',
    19: 'CEF_CONTENT_SETTING_TYPE_USB_CHOOSER_DATA',
    20: 'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_GUARD',
    21: 'CEF_CONTENT_SETTING_TYPE_BACKGROUND_SYNC',
    22: 'CEF_CONTENT_SETTING_TYPE_AUTOPLAY',
    23: 'CEF_CONTENT_SETTING_TYPE_IMPORTANT_SITE_INFO',
    24: 'CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOBLOCKER_DATA',
    25: 'CEF_CONTENT_SETTING_TYPE_ADS',
    26: 'CEF_CONTENT_SETTING_TYPE_ADS_DATA',
    27: 'CEF_CONTENT_SETTING_TYPE_MIDI',
    28: 'CEF_CONTENT_SETTING_TYPE_PASSWORD_PROTECTION',
    29: 'CEF_CONTENT_SETTING_TYPE_MEDIA_ENGAGEMENT',
    30: 'CEF_CONTENT_SETTING_TYPE_SOUND',
    31: 'CEF_CONTENT_SETTING_TYPE_CLIENT_HINTS',
    32: 'CEF_CONTENT_SETTING_TYPE_SENSORS',
    33: 'CEF_CONTENT_SETTING_TYPE_DEPRECATED_ACCESSIBILITY_EVENTS',
    34: 'CEF_CONTENT_SETTING_TYPE_PAYMENT_HANDLER',
    35: 'CEF_CONTENT_SETTING_TYPE_USB_GUARD',
    36: 'CEF_CONTENT_SETTING_TYPE_BACKGROUND_FETCH',
    37: 'CEF_CONTENT_SETTING_TYPE_INTENT_PICKER_DISPLAY',
    38: 'CEF_CONTENT_SETTING_TYPE_IDLE_DETECTION',
    39: 'CEF_CONTENT_SETTING_TYPE_SERIAL_GUARD',
    40: 'CEF_CONTENT_SETTING_TYPE_SERIAL_CHOOSER_DATA',
    41: 'CEF_CONTENT_SETTING_TYPE_PERIODIC_BACKGROUND_SYNC',
    42: 'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_SCANNING',
    43: 'CEF_CONTENT_SETTING_TYPE_HID_GUARD',
    44: 'CEF_CONTENT_SETTING_TYPE_HID_CHOOSER_DATA',
    45: 'CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SCREEN',
    46: 'CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SYSTEM',
    47: 'CEF_CONTENT_SETTING_TYPE_LEGACY_COOKIE_ACCESS',
    48: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_WRITE_GUARD',
    49: 'CEF_CONTENT_SETTING_TYPE_NFC',
    50: 'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_CHOOSER_DATA',
    51: 'CEF_CONTENT_SETTING_TYPE_CLIPBOARD_READ_WRITE',
    52: 'CEF_CONTENT_SETTING_TYPE_CLIPBOARD_SANITIZED_WRITE',
    53: 'CEF_CONTENT_SETTING_TYPE_SAFE_BROWSING_URL_CHECK_DATA',
    54: 'CEF_CONTENT_SETTING_TYPE_VR',
    55: 'CEF_CONTENT_SETTING_TYPE_AR',
    56: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_READ_GUARD',
    57: 'CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS',
    58: 'CEF_CONTENT_SETTING_TYPE_CAMERA_PAN_TILT_ZOOM',
    59: 'CEF_CONTENT_SETTING_TYPE_WINDOW_MANAGEMENT',
    60: 'CEF_CONTENT_SETTING_TYPE_INSECURE_PRIVATE_NETWORK',
    61: 'CEF_CONTENT_SETTING_TYPE_LOCAL_FONTS',
    62: 'CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOREVOCATION_DATA',
    63: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_LAST_PICKED_DIRECTORY',
    64: 'CEF_CONTENT_SETTING_TYPE_DISPLAY_CAPTURE',
    65: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_CHOOSER_DATA',
    66: 'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_SHARING',
    67: 'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_JIT',
    68: 'CEF_CONTENT_SETTING_TYPE_HTTP_ALLOWED',
    69: 'CEF_CONTENT_SETTING_TYPE_FORMFILL_METADATA',
    70: 'CEF_CONTENT_SETTING_TYPE_DEPRECATED_FEDERATED_IDENTITY_ACTIVE_SESSION',
    71: 'CEF_CONTENT_SETTING_TYPE_AUTO_DARK_WEB_CONTENT',
    72: 'CEF_CONTENT_SETTING_TYPE_REQUEST_DESKTOP_SITE',
    73: 'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_API',
    74: 'CEF_CONTENT_SETTING_TYPE_NOTIFICATION_INTERACTIONS',
    75: 'CEF_CONTENT_SETTING_TYPE_REDUCED_ACCEPT_LANGUAGE',
    76: 'CEF_CONTENT_SETTING_TYPE_NOTIFICATION_PERMISSION_REVIEW',
    77: 'CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_GUARD',
    78: 'CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_CHOOSER_DATA',
    79: 'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_SIGNIN_STATUS',
    80: 'CEF_CONTENT_SETTING_TYPE_REVOKED_UNUSED_SITE_PERMISSIONS',
    81: 'CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_STORAGE_ACCESS',
    82: 'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_AUTO_REAUTHN_PERMISSION',
    83: 'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_REGISTRATION',
    84: 'CEF_CONTENT_SETTING_TYPE_ANTI_ABUSE',
    85: 'CEF_CONTENT_SETTING_TYPE_THIRD_PARTY_STORAGE_PARTITIONING',
    86: 'CEF_CONTENT_SETTING_TYPE_HTTPS_ENFORCED',
    87: 'CEF_CONTENT_SETTING_TYPE_ALL_SCREEN_CAPTURE',
    88: 'CEF_CONTENT_SETTING_TYPE_COOKIE_CONTROLS_METADATA',
    89: 'CEF_CONTENT_SETTING_TYPE_TPCD_HEURISTICS_GRANTS',
    90: 'CEF_CONTENT_SETTING_TYPE_TPCD_METADATA_GRANTS',
    91: 'CEF_CONTENT_SETTING_TYPE_TPCD_TRIAL',
    92: 'CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_TPCD_TRIAL',
    93: 'CEF_CONTENT_SETTING_TOP_LEVEL_TPCD_ORIGIN_TRIAL',
    94: 'CEF_CONTENT_SETTING_TYPE_AUTO_PICTURE_IN_PICTURE',
    95: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_EXTENDED_PERMISSION',
    96: 'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_RESTORE_PERMISSION',
    97: 'CEF_CONTENT_SETTING_TYPE_CAPTURED_SURFACE_CONTROL',
    98: 'CEF_CONTENT_SETTING_TYPE_SMART_CARD_GUARD',
    99: 'CEF_CONTENT_SETTING_TYPE_SMART_CARD_DATA',
    100: 'CEF_CONTENT_SETTING_TYPE_WEB_PRINTING',
    101: 'CEF_CONTENT_SETTING_TYPE_AUTOMATIC_FULLSCREEN',
    102: 'CEF_CONTENT_SETTING_TYPE_SUB_APP_INSTALLATION_PROMPTS',
    103: 'CEF_CONTENT_SETTING_TYPE_SPEAKER_SELECTION',
    104: 'CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS',
    105: 'CEF_CONTENT_SETTING_TYPE_KEYBOARD_LOCK',
    106: 'CEF_CONTENT_SETTING_TYPE_POINTER_LOCK',
    107: 'CEF_CONTENT_SETTING_TYPE_REVOKED_ABUSIVE_NOTIFICATION_PERMISSIONS',
    108: 'CEF_CONTENT_SETTING_TYPE_TRACKING_PROTECTION',
    109: 'CEF_CONTENT_SETTING_TYPE_DISPLAY_MEDIA_SYSTEM_AUDIO',
    110: 'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_OPTIMIZER',
    111: 'CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS_HEADER_ORIGIN_TRIAL',
    112: 'CEF_CONTENT_SETTING_TYPE_HAND_TRACKING',
    113: 'CEF_CONTENT_SETTING_TYPE_WEB_APP_INSTALLATION',
    114: 'CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS_PRIVATE_NETWORK_ACCESS',
}
CEF_CONTENT_SETTING_TYPE_COOKIES = 0
CEF_CONTENT_SETTING_TYPE_IMAGES = 1
CEF_CONTENT_SETTING_TYPE_JAVASCRIPT = 2
CEF_CONTENT_SETTING_TYPE_POPUPS = 3
CEF_CONTENT_SETTING_TYPE_GEOLOCATION = 4
CEF_CONTENT_SETTING_TYPE_NOTIFICATIONS = 5
CEF_CONTENT_SETTING_TYPE_AUTO_SELECT_CERTIFICATE = 6
CEF_CONTENT_SETTING_TYPE_MIXEDSCRIPT = 7
CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_MIC = 8
CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_CAMERA = 9
CEF_CONTENT_SETTING_TYPE_PROTOCOL_HANDLERS = 10
CEF_CONTENT_SETTING_TYPE_DEPRECATED_PPAPI_BROKER = 11
CEF_CONTENT_SETTING_TYPE_AUTOMATIC_DOWNLOADS = 12
CEF_CONTENT_SETTING_TYPE_MIDI_SYSEX = 13
CEF_CONTENT_SETTING_TYPE_SSL_CERT_DECISIONS = 14
CEF_CONTENT_SETTING_TYPE_PROTECTED_MEDIA_IDENTIFIER = 15
CEF_CONTENT_SETTING_TYPE_APP_BANNER = 16
CEF_CONTENT_SETTING_TYPE_SITE_ENGAGEMENT = 17
CEF_CONTENT_SETTING_TYPE_DURABLE_STORAGE = 18
CEF_CONTENT_SETTING_TYPE_USB_CHOOSER_DATA = 19
CEF_CONTENT_SETTING_TYPE_BLUETOOTH_GUARD = 20
CEF_CONTENT_SETTING_TYPE_BACKGROUND_SYNC = 21
CEF_CONTENT_SETTING_TYPE_AUTOPLAY = 22
CEF_CONTENT_SETTING_TYPE_IMPORTANT_SITE_INFO = 23
CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOBLOCKER_DATA = 24
CEF_CONTENT_SETTING_TYPE_ADS = 25
CEF_CONTENT_SETTING_TYPE_ADS_DATA = 26
CEF_CONTENT_SETTING_TYPE_MIDI = 27
CEF_CONTENT_SETTING_TYPE_PASSWORD_PROTECTION = 28
CEF_CONTENT_SETTING_TYPE_MEDIA_ENGAGEMENT = 29
CEF_CONTENT_SETTING_TYPE_SOUND = 30
CEF_CONTENT_SETTING_TYPE_CLIENT_HINTS = 31
CEF_CONTENT_SETTING_TYPE_SENSORS = 32
CEF_CONTENT_SETTING_TYPE_DEPRECATED_ACCESSIBILITY_EVENTS = 33
CEF_CONTENT_SETTING_TYPE_PAYMENT_HANDLER = 34
CEF_CONTENT_SETTING_TYPE_USB_GUARD = 35
CEF_CONTENT_SETTING_TYPE_BACKGROUND_FETCH = 36
CEF_CONTENT_SETTING_TYPE_INTENT_PICKER_DISPLAY = 37
CEF_CONTENT_SETTING_TYPE_IDLE_DETECTION = 38
CEF_CONTENT_SETTING_TYPE_SERIAL_GUARD = 39
CEF_CONTENT_SETTING_TYPE_SERIAL_CHOOSER_DATA = 40
CEF_CONTENT_SETTING_TYPE_PERIODIC_BACKGROUND_SYNC = 41
CEF_CONTENT_SETTING_TYPE_BLUETOOTH_SCANNING = 42
CEF_CONTENT_SETTING_TYPE_HID_GUARD = 43
CEF_CONTENT_SETTING_TYPE_HID_CHOOSER_DATA = 44
CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SCREEN = 45
CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SYSTEM = 46
CEF_CONTENT_SETTING_TYPE_LEGACY_COOKIE_ACCESS = 47
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_WRITE_GUARD = 48
CEF_CONTENT_SETTING_TYPE_NFC = 49
CEF_CONTENT_SETTING_TYPE_BLUETOOTH_CHOOSER_DATA = 50
CEF_CONTENT_SETTING_TYPE_CLIPBOARD_READ_WRITE = 51
CEF_CONTENT_SETTING_TYPE_CLIPBOARD_SANITIZED_WRITE = 52
CEF_CONTENT_SETTING_TYPE_SAFE_BROWSING_URL_CHECK_DATA = 53
CEF_CONTENT_SETTING_TYPE_VR = 54
CEF_CONTENT_SETTING_TYPE_AR = 55
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_READ_GUARD = 56
CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS = 57
CEF_CONTENT_SETTING_TYPE_CAMERA_PAN_TILT_ZOOM = 58
CEF_CONTENT_SETTING_TYPE_WINDOW_MANAGEMENT = 59
CEF_CONTENT_SETTING_TYPE_INSECURE_PRIVATE_NETWORK = 60
CEF_CONTENT_SETTING_TYPE_LOCAL_FONTS = 61
CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOREVOCATION_DATA = 62
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_LAST_PICKED_DIRECTORY = 63
CEF_CONTENT_SETTING_TYPE_DISPLAY_CAPTURE = 64
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_CHOOSER_DATA = 65
CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_SHARING = 66
CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_JIT = 67
CEF_CONTENT_SETTING_TYPE_HTTP_ALLOWED = 68
CEF_CONTENT_SETTING_TYPE_FORMFILL_METADATA = 69
CEF_CONTENT_SETTING_TYPE_DEPRECATED_FEDERATED_IDENTITY_ACTIVE_SESSION = 70
CEF_CONTENT_SETTING_TYPE_AUTO_DARK_WEB_CONTENT = 71
CEF_CONTENT_SETTING_TYPE_REQUEST_DESKTOP_SITE = 72
CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_API = 73
CEF_CONTENT_SETTING_TYPE_NOTIFICATION_INTERACTIONS = 74
CEF_CONTENT_SETTING_TYPE_REDUCED_ACCEPT_LANGUAGE = 75
CEF_CONTENT_SETTING_TYPE_NOTIFICATION_PERMISSION_REVIEW = 76
CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_GUARD = 77
CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_CHOOSER_DATA = 78
CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_SIGNIN_STATUS = 79
CEF_CONTENT_SETTING_TYPE_REVOKED_UNUSED_SITE_PERMISSIONS = 80
CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_STORAGE_ACCESS = 81
CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_AUTO_REAUTHN_PERMISSION = 82
CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_REGISTRATION = 83
CEF_CONTENT_SETTING_TYPE_ANTI_ABUSE = 84
CEF_CONTENT_SETTING_TYPE_THIRD_PARTY_STORAGE_PARTITIONING = 85
CEF_CONTENT_SETTING_TYPE_HTTPS_ENFORCED = 86
CEF_CONTENT_SETTING_TYPE_ALL_SCREEN_CAPTURE = 87
CEF_CONTENT_SETTING_TYPE_COOKIE_CONTROLS_METADATA = 88
CEF_CONTENT_SETTING_TYPE_TPCD_HEURISTICS_GRANTS = 89
CEF_CONTENT_SETTING_TYPE_TPCD_METADATA_GRANTS = 90
CEF_CONTENT_SETTING_TYPE_TPCD_TRIAL = 91
CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_TPCD_TRIAL = 92
CEF_CONTENT_SETTING_TOP_LEVEL_TPCD_ORIGIN_TRIAL = 93
CEF_CONTENT_SETTING_TYPE_AUTO_PICTURE_IN_PICTURE = 94
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_EXTENDED_PERMISSION = 95
CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_RESTORE_PERMISSION = 96
CEF_CONTENT_SETTING_TYPE_CAPTURED_SURFACE_CONTROL = 97
CEF_CONTENT_SETTING_TYPE_SMART_CARD_GUARD = 98
CEF_CONTENT_SETTING_TYPE_SMART_CARD_DATA = 99
CEF_CONTENT_SETTING_TYPE_WEB_PRINTING = 100
CEF_CONTENT_SETTING_TYPE_AUTOMATIC_FULLSCREEN = 101
CEF_CONTENT_SETTING_TYPE_SUB_APP_INSTALLATION_PROMPTS = 102
CEF_CONTENT_SETTING_TYPE_SPEAKER_SELECTION = 103
CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS = 104
CEF_CONTENT_SETTING_TYPE_KEYBOARD_LOCK = 105
CEF_CONTENT_SETTING_TYPE_POINTER_LOCK = 106
CEF_CONTENT_SETTING_TYPE_REVOKED_ABUSIVE_NOTIFICATION_PERMISSIONS = 107
CEF_CONTENT_SETTING_TYPE_TRACKING_PROTECTION = 108
CEF_CONTENT_SETTING_TYPE_DISPLAY_MEDIA_SYSTEM_AUDIO = 109
CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_OPTIMIZER = 110
CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS_HEADER_ORIGIN_TRIAL = 111
CEF_CONTENT_SETTING_TYPE_HAND_TRACKING = 112
CEF_CONTENT_SETTING_TYPE_WEB_APP_INSTALLATION = 113
CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS_PRIVATE_NETWORK_ACCESS = 114
c__EA_cef_content_setting_types_t = ctypes.c_uint32 # enum
# Supported content setting types. Some types are platform-specific or only
# supported with Chrome style. Should be kept in sync with Chromium's
# ContentSettingsType type.
# Supported content setting types. Some types are platform-specific or only
# supported with Chrome style. Should be kept in sync with Chromium's
# ContentSettingsType type.
cef_content_setting_types_t = c__EA_cef_content_setting_types_t
cef_content_setting_types_t__enumvalues = c__EA_cef_content_setting_types_t__enumvalues
# Supported content setting values. Should be kept in sync with Chromium's
# ContentSetting type.
# Supported content setting values. Should be kept in sync with Chromium's
# ContentSetting type.

# values for enumeration 'c__EA_cef_content_setting_values_t'
c__EA_cef_content_setting_values_t__enumvalues = {
    0: 'CEF_CONTENT_SETTING_VALUE_DEFAULT',
    1: 'CEF_CONTENT_SETTING_VALUE_ALLOW',
    2: 'CEF_CONTENT_SETTING_VALUE_BLOCK',
    3: 'CEF_CONTENT_SETTING_VALUE_ASK',
    4: 'CEF_CONTENT_SETTING_VALUE_SESSION_ONLY',
    5: 'CEF_CONTENT_SETTING_VALUE_DETECT_IMPORTANT_CONTENT',
    6: 'CEF_CONTENT_SETTING_VALUE_NUM_VALUES',
}
CEF_CONTENT_SETTING_VALUE_DEFAULT = 0
CEF_CONTENT_SETTING_VALUE_ALLOW = 1
CEF_CONTENT_SETTING_VALUE_BLOCK = 2
CEF_CONTENT_SETTING_VALUE_ASK = 3
CEF_CONTENT_SETTING_VALUE_SESSION_ONLY = 4
CEF_CONTENT_SETTING_VALUE_DETECT_IMPORTANT_CONTENT = 5
CEF_CONTENT_SETTING_VALUE_NUM_VALUES = 6
c__EA_cef_content_setting_values_t = ctypes.c_uint32 # enum
# Supported content setting values. Should be kept in sync with Chromium's
# ContentSetting type.
# Supported content setting values. Should be kept in sync with Chromium's
# ContentSetting type.
cef_content_setting_values_t = c__EA_cef_content_setting_values_t
cef_content_setting_values_t__enumvalues = c__EA_cef_content_setting_values_t__enumvalues
# Structure representing a point.
class struct__cef_point_t(Structure):
    pass

struct__cef_point_t._pack_ = 1 # source:False
struct__cef_point_t._fields_ = [
    ('x', ctypes.c_int32),
    ('y', ctypes.c_int32),
]

# Structure representing a point.
# Structure representing a point.
cef_point_t = struct__cef_point_t
# Structure representing a rectangle.
class struct__cef_rect_t(Structure):
    pass

struct__cef_rect_t._pack_ = 1 # source:False
struct__cef_rect_t._fields_ = [
    ('x', ctypes.c_int32),
    ('y', ctypes.c_int32),
    ('width', ctypes.c_int32),
    ('height', ctypes.c_int32),
]

# Structure representing a rectangle.
# Structure representing a rectangle.
cef_rect_t = struct__cef_rect_t
# Structure representing a size.
class struct__cef_size_t(Structure):
    pass

struct__cef_size_t._pack_ = 1 # source:False
struct__cef_size_t._fields_ = [
    ('width', ctypes.c_int32),
    ('height', ctypes.c_int32),
]

# Structure representing a size.
# Structure representing a size.
cef_size_t = struct__cef_size_t
# Structure representing insets.
class struct__cef_insets_t(Structure):
    pass

struct__cef_insets_t._pack_ = 1 # source:False
struct__cef_insets_t._fields_ = [
    ('top', ctypes.c_int32),
    ('left', ctypes.c_int32),
    ('bottom', ctypes.c_int32),
    ('right', ctypes.c_int32),
]

# Structure representing insets.
# Structure representing insets.
cef_insets_t = struct__cef_insets_t
# Describes how to interpret the components of a pixel.
# Describes how to interpret the components of a pixel.

# values for enumeration 'c__EA_cef_color_type_t'
c__EA_cef_color_type_t__enumvalues = {
    0: 'CEF_COLOR_TYPE_RGBA_8888',
    1: 'CEF_COLOR_TYPE_BGRA_8888',
}
CEF_COLOR_TYPE_RGBA_8888 = 0
CEF_COLOR_TYPE_BGRA_8888 = 1
c__EA_cef_color_type_t = ctypes.c_uint32 # enum
# Describes how to interpret the components of a pixel.
# Describes how to interpret the components of a pixel.
cef_color_type_t = c__EA_cef_color_type_t
cef_color_type_t__enumvalues = c__EA_cef_color_type_t__enumvalues
# CEF supports both a Chrome runtime style (based on the Chrome UI layer) and an
# Alloy runtime style (based on the Chromium content layer). Chrome style
# provides the full Chrome UI and browser functionality whereas Alloy style
# provides less default browser functionality but adds additional client
# callbacks and support for windowless (off-screen) rendering. The style type is
# individually configured for each window/browser at creation time and different
# styles can be mixed during runtime. For additional comparative details on
# runtime styles see
# https://bitbucket.org/chromiumembedded/cef/wiki/Architecture.md#markdown-
# header-cef3
# CEF supports both a Chrome runtime style (based on the Chrome UI layer) and an
# Alloy runtime style (based on the Chromium content layer). Chrome style
# provides the full Chrome UI and browser functionality whereas Alloy style
# provides less default browser functionality but adds additional client
# callbacks and support for windowless (off-screen) rendering. The style type is
# individually configured for each window/browser at creation time and different
# styles can be mixed during runtime. For additional comparative details on
# runtime styles see
# https://bitbucket.org/chromiumembedded/cef/wiki/Architecture.md#markdown-
# header-cef3

# values for enumeration 'c__EA_cef_runtime_style_t'
c__EA_cef_runtime_style_t__enumvalues = {
    0: 'CEF_RUNTIME_STYLE_DEFAULT',
    1: 'CEF_RUNTIME_STYLE_CHROME',
    2: 'CEF_RUNTIME_STYLE_ALLOY',
}
CEF_RUNTIME_STYLE_DEFAULT = 0
CEF_RUNTIME_STYLE_CHROME = 1
CEF_RUNTIME_STYLE_ALLOY = 2
c__EA_cef_runtime_style_t = ctypes.c_uint32 # enum
# CEF supports both a Chrome runtime style (based on the Chrome UI layer) and an
# Alloy runtime style (based on the Chromium content layer). Chrome style
# provides the full Chrome UI and browser functionality whereas Alloy style
# provides less default browser functionality but adds additional client
# callbacks and support for windowless (off-screen) rendering. The style type is
# individually configured for each window/browser at creation time and different
# styles can be mixed during runtime. For additional comparative details on
# runtime styles see
# https://bitbucket.org/chromiumembedded/cef/wiki/Architecture.md#markdown-
# header-cef3
# CEF supports both a Chrome runtime style (based on the Chrome UI layer) and an
# Alloy runtime style (based on the Chromium content layer). Chrome style
# provides the full Chrome UI and browser functionality whereas Alloy style
# provides less default browser functionality but adds additional client
# callbacks and support for windowless (off-screen) rendering. The style type is
# individually configured for each window/browser at creation time and different
# styles can be mixed during runtime. For additional comparative details on
# runtime styles see
# https://bitbucket.org/chromiumembedded/cef/wiki/Architecture.md#markdown-
# header-cef3
cef_runtime_style_t = c__EA_cef_runtime_style_t
cef_runtime_style_t__enumvalues = c__EA_cef_runtime_style_t__enumvalues
# Structure representing CefExecuteProcess arguments.
class struct__cef_main_args_t(Structure):
    pass

struct__cef_main_args_t._pack_ = 1 # source:False
struct__cef_main_args_t._fields_ = [
    ('argc', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('argv', ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
]

# Structure representing CefExecuteProcess arguments.
# Structure representing CefExecuteProcess arguments.
cef_main_args_t = struct__cef_main_args_t
# Class representing window information.
class struct__cef_window_info_t(Structure):
    pass

struct__cef_window_info_t._pack_ = 1 # source:False
struct__cef_window_info_t._fields_ = [
    ('window_name', cef_string_t),
    ('bounds', cef_rect_t),
    ('hidden', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('parent_view', ctypes.POINTER(None)),
    ('windowless_rendering_enabled', ctypes.c_int32),
    ('shared_texture_enabled', ctypes.c_int32),
    ('external_begin_frame_enabled', ctypes.c_int32),
    ('PADDING_1', ctypes.c_ubyte * 4),
    ('view', ctypes.POINTER(None)),
    ('runtime_style', cef_runtime_style_t),
    ('PADDING_2', ctypes.c_ubyte * 4),
]

# Class representing window information.
# Class representing window information.
cef_window_info_t = struct__cef_window_info_t
# Structure containing shared texture information for the OnAcceleratedPaint
# callback. Resources will be released to the underlying pool for reuse when the
# callback returns from client code.
class struct__cef_accelerated_paint_info_t(Structure):
    pass

struct__cef_accelerated_paint_info_t._pack_ = 1 # source:False
struct__cef_accelerated_paint_info_t._fields_ = [
    ('shared_texture_io_surface', ctypes.POINTER(None)),
    ('format', cef_color_type_t),
    ('PADDING_0', ctypes.c_ubyte * 4),
]

# Structure containing shared texture information for the OnAcceleratedPaint
# callback. Resources will be released to the underlying pool for reuse when the
# callback returns from client code.
# Structure containing shared texture information for the OnAcceleratedPaint
# callback. Resources will be released to the underlying pool for reuse when the
# callback returns from client code.
cef_accelerated_paint_info_t = struct__cef_accelerated_paint_info_t
cef_color_t = ctypes.c_uint32
# Log severity levels.
# Log severity levels.

# values for enumeration 'c__EA_cef_log_severity_t'
c__EA_cef_log_severity_t__enumvalues = {
    0: 'LOGSEVERITY_DEFAULT',
    1: 'LOGSEVERITY_VERBOSE',
    1: 'LOGSEVERITY_DEBUG',
    2: 'LOGSEVERITY_INFO',
    3: 'LOGSEVERITY_WARNING',
    4: 'LOGSEVERITY_ERROR',
    5: 'LOGSEVERITY_FATAL',
    99: 'LOGSEVERITY_DISABLE',
}
LOGSEVERITY_DEFAULT = 0
LOGSEVERITY_VERBOSE = 1
LOGSEVERITY_DEBUG = 1
LOGSEVERITY_INFO = 2
LOGSEVERITY_WARNING = 3
LOGSEVERITY_ERROR = 4
LOGSEVERITY_FATAL = 5
LOGSEVERITY_DISABLE = 99
c__EA_cef_log_severity_t = ctypes.c_uint32 # enum
# Log severity levels.
# Log severity levels.
cef_log_severity_t = c__EA_cef_log_severity_t
cef_log_severity_t__enumvalues = c__EA_cef_log_severity_t__enumvalues
# Log items prepended to each log line.
# Log items prepended to each log line.

# values for enumeration 'c__EA_cef_log_items_t'
c__EA_cef_log_items_t__enumvalues = {
    0: 'LOG_ITEMS_DEFAULT',
    1: 'LOG_ITEMS_NONE',
    2: 'LOG_ITEMS_FLAG_PROCESS_ID',
    4: 'LOG_ITEMS_FLAG_THREAD_ID',
    8: 'LOG_ITEMS_FLAG_TIME_STAMP',
    16: 'LOG_ITEMS_FLAG_TICK_COUNT',
}
LOG_ITEMS_DEFAULT = 0
LOG_ITEMS_NONE = 1
LOG_ITEMS_FLAG_PROCESS_ID = 2
LOG_ITEMS_FLAG_THREAD_ID = 4
LOG_ITEMS_FLAG_TIME_STAMP = 8
LOG_ITEMS_FLAG_TICK_COUNT = 16
c__EA_cef_log_items_t = ctypes.c_uint32 # enum
# Log items prepended to each log line.
# Log items prepended to each log line.
cef_log_items_t = c__EA_cef_log_items_t
cef_log_items_t__enumvalues = c__EA_cef_log_items_t__enumvalues
# Represents the state of a setting.
# Represents the state of a setting.

# values for enumeration 'c__EA_cef_state_t'
c__EA_cef_state_t__enumvalues = {
    0: 'STATE_DEFAULT',
    1: 'STATE_ENABLED',
    2: 'STATE_DISABLED',
}
STATE_DEFAULT = 0
STATE_ENABLED = 1
STATE_DISABLED = 2
c__EA_cef_state_t = ctypes.c_uint32 # enum
# Represents the state of a setting.
# Represents the state of a setting.
cef_state_t = c__EA_cef_state_t
cef_state_t__enumvalues = c__EA_cef_state_t__enumvalues
# Initialization settings. Specify NULL or 0 to get the recommended default
# values. Many of these and other settings can also configured using command-
# line switches.
class struct__cef_settings_t(Structure):
    pass

struct__cef_settings_t._pack_ = 1 # source:False
struct__cef_settings_t._fields_ = [
    ('size', ctypes.c_uint64),
    ('no_sandbox', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('browser_subprocess_path', cef_string_t),
    ('framework_dir_path', cef_string_t),
    ('main_bundle_path', cef_string_t),
    ('multi_threaded_message_loop', ctypes.c_int32),
    ('external_message_pump', ctypes.c_int32),
    ('windowless_rendering_enabled', ctypes.c_int32),
    ('command_line_args_disabled', ctypes.c_int32),
    ('cache_path', cef_string_t),
    ('root_cache_path', cef_string_t),
    ('persist_session_cookies', ctypes.c_int32),
    ('PADDING_1', ctypes.c_ubyte * 4),
    ('user_agent', cef_string_t),
    ('user_agent_product', cef_string_t),
    ('locale', cef_string_t),
    ('log_file', cef_string_t),
    ('log_severity', cef_log_severity_t),
    ('log_items', cef_log_items_t),
    ('javascript_flags', cef_string_t),
    ('resources_dir_path', cef_string_t),
    ('locales_dir_path', cef_string_t),
    ('remote_debugging_port', ctypes.c_int32),
    ('uncaught_exception_stack_size', ctypes.c_int32),
    ('background_color', ctypes.c_uint32),
    ('PADDING_2', ctypes.c_ubyte * 4),
    ('accept_language_list', cef_string_t),
    ('cookieable_schemes_list', cef_string_t),
    ('cookieable_schemes_exclude_defaults', ctypes.c_int32),
    ('PADDING_3', ctypes.c_ubyte * 4),
    ('chrome_policy_id', cef_string_t),
    ('chrome_app_icon_id', ctypes.c_int32),
    ('disable_signal_handlers', ctypes.c_int32),
]

# Initialization settings. Specify NULL or 0 to get the recommended default
# values. Many of these and other settings can also configured using command-
# line switches.
# Initialization settings. Specify NULL or 0 to get the recommended default
# values. Many of these and other settings can also configured using command-
# line switches.
cef_settings_t = struct__cef_settings_t
# Request context initialization settings. Specify NULL or 0 to get the
# recommended default values.
class struct__cef_request_context_settings_t(Structure):
    pass

struct__cef_request_context_settings_t._pack_ = 1 # source:False
struct__cef_request_context_settings_t._fields_ = [
    ('size', ctypes.c_uint64),
    ('cache_path', cef_string_t),
    ('persist_session_cookies', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('accept_language_list', cef_string_t),
    ('cookieable_schemes_list', cef_string_t),
    ('cookieable_schemes_exclude_defaults', ctypes.c_int32),
    ('PADDING_1', ctypes.c_ubyte * 4),
]

# Request context initialization settings. Specify NULL or 0 to get the
# recommended default values.
# Request context initialization settings. Specify NULL or 0 to get the
# recommended default values.
cef_request_context_settings_t = struct__cef_request_context_settings_t
# Browser initialization settings. Specify NULL or 0 to get the recommended
# default values. The consequences of using custom values may not be well
# tested. Many of these and other settings can also configured using command-
# line switches.
class struct__cef_browser_settings_t(Structure):
    pass

struct__cef_browser_settings_t._pack_ = 1 # source:False
struct__cef_browser_settings_t._fields_ = [
    ('size', ctypes.c_uint64),
    ('windowless_frame_rate', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('standard_font_family', cef_string_t),
    ('fixed_font_family', cef_string_t),
    ('serif_font_family', cef_string_t),
    ('sans_serif_font_family', cef_string_t),
    ('cursive_font_family', cef_string_t),
    ('fantasy_font_family', cef_string_t),
    ('default_font_size', ctypes.c_int32),
    ('default_fixed_font_size', ctypes.c_int32),
    ('minimum_font_size', ctypes.c_int32),
    ('minimum_logical_font_size', ctypes.c_int32),
    ('default_encoding', cef_string_t),
    ('remote_fonts', cef_state_t),
    ('javascript', cef_state_t),
    ('javascript_close_windows', cef_state_t),
    ('javascript_access_clipboard', cef_state_t),
    ('javascript_dom_paste', cef_state_t),
    ('image_loading', cef_state_t),
    ('image_shrink_standalone_to_fit', cef_state_t),
    ('text_area_resize', cef_state_t),
    ('tab_to_links', cef_state_t),
    ('local_storage', cef_state_t),
    ('databases', cef_state_t),
    ('webgl', cef_state_t),
    ('background_color', ctypes.c_uint32),
    ('chrome_status_bubble', cef_state_t),
    ('chrome_zoom_bubble', cef_state_t),
    ('PADDING_1', ctypes.c_ubyte * 4),
]

# Browser initialization settings. Specify NULL or 0 to get the recommended
# default values. The consequences of using custom values may not be well
# tested. Many of these and other settings can also configured using command-
# line switches.
# Browser initialization settings. Specify NULL or 0 to get the recommended
# default values. The consequences of using custom values may not be well
# tested. Many of these and other settings can also configured using command-
# line switches.
cef_browser_settings_t = struct__cef_browser_settings_t
# Return value types.
# Return value types.

# values for enumeration 'c__EA_cef_return_value_t'
c__EA_cef_return_value_t__enumvalues = {
    0: 'RV_CANCEL',
    1: 'RV_CONTINUE',
    2: 'RV_CONTINUE_ASYNC',
}
RV_CANCEL = 0
RV_CONTINUE = 1
RV_CONTINUE_ASYNC = 2
c__EA_cef_return_value_t = ctypes.c_uint32 # enum
# Return value types.
# Return value types.
cef_return_value_t = c__EA_cef_return_value_t
cef_return_value_t__enumvalues = c__EA_cef_return_value_t__enumvalues
# URL component parts.
class struct__cef_urlparts_t(Structure):
    _pack_ = 1 # source:False
    _fields_ = [
    ('spec', cef_string_t),
    ('scheme', cef_string_t),
    ('username', cef_string_t),
    ('password', cef_string_t),
    ('host', cef_string_t),
    ('port', cef_string_t),
    ('origin', cef_string_t),
    ('path', cef_string_t),
    ('query', cef_string_t),
    ('fragment', cef_string_t),
     ]

# URL component parts.
# URL component parts.
cef_urlparts_t = struct__cef_urlparts_t
# Cookie priority values.
# Cookie priority values.

# values for enumeration 'c__EA_cef_cookie_priority_t'
c__EA_cef_cookie_priority_t__enumvalues = {
    -1: 'CEF_COOKIE_PRIORITY_LOW',
    0: 'CEF_COOKIE_PRIORITY_MEDIUM',
    1: 'CEF_COOKIE_PRIORITY_HIGH',
}
CEF_COOKIE_PRIORITY_LOW = -1
CEF_COOKIE_PRIORITY_MEDIUM = 0
CEF_COOKIE_PRIORITY_HIGH = 1
c__EA_cef_cookie_priority_t = ctypes.c_int32 # enum
# Cookie priority values.
# Cookie priority values.
cef_cookie_priority_t = c__EA_cef_cookie_priority_t
cef_cookie_priority_t__enumvalues = c__EA_cef_cookie_priority_t__enumvalues
# Cookie same site values.
# Cookie same site values.

# values for enumeration 'c__EA_cef_cookie_same_site_t'
c__EA_cef_cookie_same_site_t__enumvalues = {
    0: 'CEF_COOKIE_SAME_SITE_UNSPECIFIED',
    1: 'CEF_COOKIE_SAME_SITE_NO_RESTRICTION',
    2: 'CEF_COOKIE_SAME_SITE_LAX_MODE',
    3: 'CEF_COOKIE_SAME_SITE_STRICT_MODE',
}
CEF_COOKIE_SAME_SITE_UNSPECIFIED = 0
CEF_COOKIE_SAME_SITE_NO_RESTRICTION = 1
CEF_COOKIE_SAME_SITE_LAX_MODE = 2
CEF_COOKIE_SAME_SITE_STRICT_MODE = 3
c__EA_cef_cookie_same_site_t = ctypes.c_uint32 # enum
# Cookie same site values.
# Cookie same site values.
cef_cookie_same_site_t = c__EA_cef_cookie_same_site_t
cef_cookie_same_site_t__enumvalues = c__EA_cef_cookie_same_site_t__enumvalues
# Cookie information.
class struct__cef_cookie_t(Structure):
    pass

struct__cef_cookie_t._pack_ = 1 # source:False
struct__cef_cookie_t._fields_ = [
    ('name', cef_string_t),
    ('value', cef_string_t),
    ('domain', cef_string_t),
    ('path', cef_string_t),
    ('secure', ctypes.c_int32),
    ('httponly', ctypes.c_int32),
    ('creation', cef_basetime_t),
    ('last_access', cef_basetime_t),
    ('has_expires', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('expires', cef_basetime_t),
    ('same_site', cef_cookie_same_site_t),
    ('priority', cef_cookie_priority_t),
]

# Cookie information.
# Cookie information.
cef_cookie_t = struct__cef_cookie_t
# Process termination status values.
# Process termination status values.

# values for enumeration 'c__EA_cef_termination_status_t'
c__EA_cef_termination_status_t__enumvalues = {
    0: 'TS_ABNORMAL_TERMINATION',
    1: 'TS_PROCESS_WAS_KILLED',
    2: 'TS_PROCESS_CRASHED',
    3: 'TS_PROCESS_OOM',
    4: 'TS_LAUNCH_FAILED',
    5: 'TS_INTEGRITY_FAILURE',
}
TS_ABNORMAL_TERMINATION = 0
TS_PROCESS_WAS_KILLED = 1
TS_PROCESS_CRASHED = 2
TS_PROCESS_OOM = 3
TS_LAUNCH_FAILED = 4
TS_INTEGRITY_FAILURE = 5
c__EA_cef_termination_status_t = ctypes.c_uint32 # enum
# Process termination status values.
# Process termination status values.
cef_termination_status_t = c__EA_cef_termination_status_t
cef_termination_status_t__enumvalues = c__EA_cef_termination_status_t__enumvalues
# Path key values.
# Path key values.

# values for enumeration 'c__EA_cef_path_key_t'
c__EA_cef_path_key_t__enumvalues = {
    0: 'PK_DIR_CURRENT',
    1: 'PK_DIR_EXE',
    2: 'PK_DIR_MODULE',
    3: 'PK_DIR_TEMP',
    4: 'PK_FILE_EXE',
    5: 'PK_FILE_MODULE',
    6: 'PK_LOCAL_APP_DATA',
    7: 'PK_USER_DATA',
    8: 'PK_DIR_RESOURCES',
}
PK_DIR_CURRENT = 0
PK_DIR_EXE = 1
PK_DIR_MODULE = 2
PK_DIR_TEMP = 3
PK_FILE_EXE = 4
PK_FILE_MODULE = 5
PK_LOCAL_APP_DATA = 6
PK_USER_DATA = 7
PK_DIR_RESOURCES = 8
c__EA_cef_path_key_t = ctypes.c_uint32 # enum
# Path key values.
# Path key values.
cef_path_key_t = c__EA_cef_path_key_t
cef_path_key_t__enumvalues = c__EA_cef_path_key_t__enumvalues
# Storage types.
# Storage types.

# values for enumeration 'c__EA_cef_storage_type_t'
c__EA_cef_storage_type_t__enumvalues = {
    0: 'ST_LOCALSTORAGE',
    1: 'ST_SESSIONSTORAGE',
}
ST_LOCALSTORAGE = 0
ST_SESSIONSTORAGE = 1
c__EA_cef_storage_type_t = ctypes.c_uint32 # enum
# Storage types.
# Storage types.
cef_storage_type_t = c__EA_cef_storage_type_t
cef_storage_type_t__enumvalues = c__EA_cef_storage_type_t__enumvalues
# Supported error code values. For the complete list of error values see
# "include/base/internal/cef_net_error_list.h".
# Supported error code values. For the complete list of error values see
# "include/base/internal/cef_net_error_list.h".

# values for enumeration 'c__EA_cef_errorcode_t'
c__EA_cef_errorcode_t__enumvalues = {
    0: 'ERR_NONE',
    -1: 'ERR_IO_PENDING',
    -2: 'ERR_FAILED',
    -3: 'ERR_ABORTED',
    -4: 'ERR_INVALID_ARGUMENT',
    -5: 'ERR_INVALID_HANDLE',
    -6: 'ERR_FILE_NOT_FOUND',
    -7: 'ERR_TIMED_OUT',
    -8: 'ERR_FILE_TOO_BIG',
    -9: 'ERR_UNEXPECTED',
    -10: 'ERR_ACCESS_DENIED',
    -11: 'ERR_NOT_IMPLEMENTED',
    -12: 'ERR_INSUFFICIENT_RESOURCES',
    -13: 'ERR_OUT_OF_MEMORY',
    -14: 'ERR_UPLOAD_FILE_CHANGED',
    -15: 'ERR_SOCKET_NOT_CONNECTED',
    -16: 'ERR_FILE_EXISTS',
    -17: 'ERR_FILE_PATH_TOO_LONG',
    -18: 'ERR_FILE_NO_SPACE',
    -19: 'ERR_FILE_VIRUS_INFECTED',
    -20: 'ERR_BLOCKED_BY_CLIENT',
    -21: 'ERR_NETWORK_CHANGED',
    -22: 'ERR_BLOCKED_BY_ADMINISTRATOR',
    -23: 'ERR_SOCKET_IS_CONNECTED',
    -25: 'ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED',
    -26: 'ERR_CONTEXT_SHUT_DOWN',
    -27: 'ERR_BLOCKED_BY_RESPONSE',
    -29: 'ERR_CLEARTEXT_NOT_PERMITTED',
    -30: 'ERR_BLOCKED_BY_CSP',
    -31: 'ERR_H2_OR_QUIC_REQUIRED',
    -32: 'ERR_BLOCKED_BY_ORB',
    -33: 'ERR_NETWORK_ACCESS_REVOKED',
    -100: 'ERR_CONNECTION_CLOSED',
    -101: 'ERR_CONNECTION_RESET',
    -102: 'ERR_CONNECTION_REFUSED',
    -103: 'ERR_CONNECTION_ABORTED',
    -104: 'ERR_CONNECTION_FAILED',
    -105: 'ERR_NAME_NOT_RESOLVED',
    -106: 'ERR_INTERNET_DISCONNECTED',
    -107: 'ERR_SSL_PROTOCOL_ERROR',
    -108: 'ERR_ADDRESS_INVALID',
    -109: 'ERR_ADDRESS_UNREACHABLE',
    -110: 'ERR_SSL_CLIENT_AUTH_CERT_NEEDED',
    -111: 'ERR_TUNNEL_CONNECTION_FAILED',
    -112: 'ERR_NO_SSL_VERSIONS_ENABLED',
    -113: 'ERR_SSL_VERSION_OR_CIPHER_MISMATCH',
    -114: 'ERR_SSL_RENEGOTIATION_REQUESTED',
    -115: 'ERR_PROXY_AUTH_UNSUPPORTED',
    -117: 'ERR_BAD_SSL_CLIENT_AUTH_CERT',
    -118: 'ERR_CONNECTION_TIMED_OUT',
    -119: 'ERR_HOST_RESOLVER_QUEUE_TOO_LARGE',
    -120: 'ERR_SOCKS_CONNECTION_FAILED',
    -121: 'ERR_SOCKS_CONNECTION_HOST_UNREACHABLE',
    -122: 'ERR_ALPN_NEGOTIATION_FAILED',
    -123: 'ERR_SSL_NO_RENEGOTIATION',
    -124: 'ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES',
    -125: 'ERR_SSL_DECOMPRESSION_FAILURE_ALERT',
    -126: 'ERR_SSL_BAD_RECORD_MAC_ALERT',
    -127: 'ERR_PROXY_AUTH_REQUESTED',
    -130: 'ERR_PROXY_CONNECTION_FAILED',
    -131: 'ERR_MANDATORY_PROXY_CONFIGURATION_FAILED',
    -133: 'ERR_PRECONNECT_MAX_SOCKET_LIMIT',
    -134: 'ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED',
    -135: 'ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY',
    -136: 'ERR_PROXY_CERTIFICATE_INVALID',
    -137: 'ERR_NAME_RESOLUTION_FAILED',
    -138: 'ERR_NETWORK_ACCESS_DENIED',
    -139: 'ERR_TEMPORARILY_THROTTLED',
    -140: 'ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT',
    -141: 'ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED',
    -142: 'ERR_MSG_TOO_BIG',
    -145: 'ERR_WS_PROTOCOL_ERROR',
    -147: 'ERR_ADDRESS_IN_USE',
    -148: 'ERR_SSL_HANDSHAKE_NOT_COMPLETED',
    -149: 'ERR_SSL_BAD_PEER_PUBLIC_KEY',
    -150: 'ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN',
    -151: 'ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED',
    -153: 'ERR_SSL_DECRYPT_ERROR_ALERT',
    -154: 'ERR_WS_THROTTLE_QUEUE_TOO_LARGE',
    -156: 'ERR_SSL_SERVER_CERT_CHANGED',
    -159: 'ERR_SSL_UNRECOGNIZED_NAME_ALERT',
    -160: 'ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR',
    -161: 'ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR',
    -162: 'ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE',
    -163: 'ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE',
    -164: 'ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT',
    -166: 'ERR_ICANN_NAME_COLLISION',
    -167: 'ERR_SSL_SERVER_CERT_BAD_FORMAT',
    -168: 'ERR_CT_STH_PARSING_FAILED',
    -169: 'ERR_CT_STH_INCOMPLETE',
    -170: 'ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH',
    -171: 'ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED',
    -172: 'ERR_SSL_OBSOLETE_CIPHER',
    -173: 'ERR_WS_UPGRADE',
    -174: 'ERR_READ_IF_READY_NOT_IMPLEMENTED',
    -176: 'ERR_NO_BUFFER_SPACE',
    -177: 'ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS',
    -178: 'ERR_EARLY_DATA_REJECTED',
    -179: 'ERR_WRONG_VERSION_ON_EARLY_DATA',
    -180: 'ERR_TLS13_DOWNGRADE_DETECTED',
    -181: 'ERR_SSL_KEY_USAGE_INCOMPATIBLE',
    -182: 'ERR_INVALID_ECH_CONFIG_LIST',
    -183: 'ERR_ECH_NOT_NEGOTIATED',
    -184: 'ERR_ECH_FALLBACK_CERTIFICATE_INVALID',
    -200: 'ERR_CERT_COMMON_NAME_INVALID',
    -201: 'ERR_CERT_DATE_INVALID',
    -202: 'ERR_CERT_AUTHORITY_INVALID',
    -203: 'ERR_CERT_CONTAINS_ERRORS',
    -204: 'ERR_CERT_NO_REVOCATION_MECHANISM',
    -205: 'ERR_CERT_UNABLE_TO_CHECK_REVOCATION',
    -206: 'ERR_CERT_REVOKED',
    -207: 'ERR_CERT_INVALID',
    -208: 'ERR_CERT_WEAK_SIGNATURE_ALGORITHM',
    -210: 'ERR_CERT_NON_UNIQUE_NAME',
    -211: 'ERR_CERT_WEAK_KEY',
    -212: 'ERR_CERT_NAME_CONSTRAINT_VIOLATION',
    -213: 'ERR_CERT_VALIDITY_TOO_LONG',
    -214: 'ERR_CERTIFICATE_TRANSPARENCY_REQUIRED',
    -215: 'ERR_CERT_SYMANTEC_LEGACY',
    -217: 'ERR_CERT_KNOWN_INTERCEPTION_BLOCKED',
    -219: 'ERR_CERT_END',
    -300: 'ERR_INVALID_URL',
    -301: 'ERR_DISALLOWED_URL_SCHEME',
    -302: 'ERR_UNKNOWN_URL_SCHEME',
    -303: 'ERR_INVALID_REDIRECT',
    -310: 'ERR_TOO_MANY_REDIRECTS',
    -311: 'ERR_UNSAFE_REDIRECT',
    -312: 'ERR_UNSAFE_PORT',
    -320: 'ERR_INVALID_RESPONSE',
    -321: 'ERR_INVALID_CHUNKED_ENCODING',
    -322: 'ERR_METHOD_NOT_SUPPORTED',
    -323: 'ERR_UNEXPECTED_PROXY_AUTH',
    -324: 'ERR_EMPTY_RESPONSE',
    -325: 'ERR_RESPONSE_HEADERS_TOO_BIG',
    -327: 'ERR_PAC_SCRIPT_FAILED',
    -328: 'ERR_REQUEST_RANGE_NOT_SATISFIABLE',
    -329: 'ERR_MALFORMED_IDENTITY',
    -330: 'ERR_CONTENT_DECODING_FAILED',
    -331: 'ERR_NETWORK_IO_SUSPENDED',
    -332: 'ERR_SYN_REPLY_NOT_RECEIVED',
    -333: 'ERR_ENCODING_CONVERSION_FAILED',
    -334: 'ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT',
    -336: 'ERR_NO_SUPPORTED_PROXIES',
    -337: 'ERR_HTTP2_PROTOCOL_ERROR',
    -338: 'ERR_INVALID_AUTH_CREDENTIALS',
    -339: 'ERR_UNSUPPORTED_AUTH_SCHEME',
    -340: 'ERR_ENCODING_DETECTION_FAILED',
    -341: 'ERR_MISSING_AUTH_CREDENTIALS',
    -342: 'ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS',
    -343: 'ERR_MISCONFIGURED_AUTH_ENVIRONMENT',
    -344: 'ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS',
    -345: 'ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN',
    -346: 'ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH',
    -347: 'ERR_INCOMPLETE_HTTP2_HEADERS',
    -348: 'ERR_PAC_NOT_IN_DHCP',
    -349: 'ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION',
    -350: 'ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION',
    -351: 'ERR_HTTP2_SERVER_REFUSED_STREAM',
    -352: 'ERR_HTTP2_PING_FAILED',
    -354: 'ERR_CONTENT_LENGTH_MISMATCH',
    -355: 'ERR_INCOMPLETE_CHUNKED_ENCODING',
    -356: 'ERR_QUIC_PROTOCOL_ERROR',
    -357: 'ERR_RESPONSE_HEADERS_TRUNCATED',
    -358: 'ERR_QUIC_HANDSHAKE_FAILED',
    -360: 'ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY',
    -361: 'ERR_HTTP2_FLOW_CONTROL_ERROR',
    -362: 'ERR_HTTP2_FRAME_SIZE_ERROR',
    -363: 'ERR_HTTP2_COMPRESSION_ERROR',
    -364: 'ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION',
    -365: 'ERR_HTTP_1_1_REQUIRED',
    -366: 'ERR_PROXY_HTTP_1_1_REQUIRED',
    -367: 'ERR_PAC_SCRIPT_TERMINATED',
    -370: 'ERR_INVALID_HTTP_RESPONSE',
    -371: 'ERR_CONTENT_DECODING_INIT_FAILED',
    -372: 'ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED',
    -375: 'ERR_TOO_MANY_RETRIES',
    -376: 'ERR_HTTP2_STREAM_CLOSED',
    -379: 'ERR_HTTP_RESPONSE_CODE_FAILURE',
    -380: 'ERR_QUIC_CERT_ROOT_NOT_KNOWN',
    -381: 'ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED',
    -382: 'ERR_TOO_MANY_ACCEPT_CH_RESTARTS',
    -383: 'ERR_INCONSISTENT_IP_ADDRESS_SPACE',
    -384: 'ERR_CACHED_IP_ADDRESS_SPACE_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_POLICY',
    -385: 'ERR_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_CHECKS',
    -386: 'ERR_ZSTD_WINDOW_SIZE_TOO_BIG',
    -387: 'ERR_DICTIONARY_LOAD_FAILED',
    -388: 'ERR_UNEXPECTED_CONTENT_DICTIONARY_HEADER',
    -400: 'ERR_CACHE_MISS',
    -401: 'ERR_CACHE_READ_FAILURE',
    -402: 'ERR_CACHE_WRITE_FAILURE',
    -403: 'ERR_CACHE_OPERATION_NOT_SUPPORTED',
    -404: 'ERR_CACHE_OPEN_FAILURE',
    -405: 'ERR_CACHE_CREATE_FAILURE',
    -406: 'ERR_CACHE_RACE',
    -407: 'ERR_CACHE_CHECKSUM_READ_FAILURE',
    -408: 'ERR_CACHE_CHECKSUM_MISMATCH',
    -409: 'ERR_CACHE_LOCK_TIMEOUT',
    -410: 'ERR_CACHE_AUTH_FAILURE_AFTER_READ',
    -411: 'ERR_CACHE_ENTRY_NOT_SUITABLE',
    -412: 'ERR_CACHE_DOOM_FAILURE',
    -413: 'ERR_CACHE_OPEN_OR_CREATE_FAILURE',
    -501: 'ERR_INSECURE_RESPONSE',
    -502: 'ERR_NO_PRIVATE_KEY_FOR_CERT',
    -503: 'ERR_ADD_USER_CERT_FAILED',
    -504: 'ERR_INVALID_SIGNED_EXCHANGE',
    -505: 'ERR_INVALID_WEB_BUNDLE',
    -506: 'ERR_TRUST_TOKEN_OPERATION_FAILED',
    -507: 'ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST',
    -701: 'ERR_PKCS12_IMPORT_BAD_PASSWORD',
    -702: 'ERR_PKCS12_IMPORT_FAILED',
    -703: 'ERR_IMPORT_CA_CERT_NOT_CA',
    -704: 'ERR_IMPORT_CERT_ALREADY_EXISTS',
    -705: 'ERR_IMPORT_CA_CERT_FAILED',
    -706: 'ERR_IMPORT_SERVER_CERT_FAILED',
    -707: 'ERR_PKCS12_IMPORT_INVALID_MAC',
    -708: 'ERR_PKCS12_IMPORT_INVALID_FILE',
    -709: 'ERR_PKCS12_IMPORT_UNSUPPORTED',
    -710: 'ERR_KEY_GENERATION_FAILED',
    -712: 'ERR_PRIVATE_KEY_EXPORT_FAILED',
    -713: 'ERR_SELF_SIGNED_CERT_GENERATION_FAILED',
    -714: 'ERR_CERT_DATABASE_CHANGED',
    -716: 'ERR_CERT_VERIFIER_CHANGED',
    -800: 'ERR_DNS_MALFORMED_RESPONSE',
    -801: 'ERR_DNS_SERVER_REQUIRES_TCP',
    -802: 'ERR_DNS_SERVER_FAILED',
    -803: 'ERR_DNS_TIMED_OUT',
    -804: 'ERR_DNS_CACHE_MISS',
    -805: 'ERR_DNS_SEARCH_EMPTY',
    -806: 'ERR_DNS_SORT_ERROR',
    -808: 'ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED',
    -809: 'ERR_DNS_NAME_HTTPS_ONLY',
    -810: 'ERR_DNS_REQUEST_CANCELLED',
    -811: 'ERR_DNS_NO_MATCHING_SUPPORTED_ALPN',
    -814: 'ERR_DNS_SECURE_PROBE_RECORD_INVALID',
}
ERR_NONE = 0
ERR_IO_PENDING = -1
ERR_FAILED = -2
ERR_ABORTED = -3
ERR_INVALID_ARGUMENT = -4
ERR_INVALID_HANDLE = -5
ERR_FILE_NOT_FOUND = -6
ERR_TIMED_OUT = -7
ERR_FILE_TOO_BIG = -8
ERR_UNEXPECTED = -9
ERR_ACCESS_DENIED = -10
ERR_NOT_IMPLEMENTED = -11
ERR_INSUFFICIENT_RESOURCES = -12
ERR_OUT_OF_MEMORY = -13
ERR_UPLOAD_FILE_CHANGED = -14
ERR_SOCKET_NOT_CONNECTED = -15
ERR_FILE_EXISTS = -16
ERR_FILE_PATH_TOO_LONG = -17
ERR_FILE_NO_SPACE = -18
ERR_FILE_VIRUS_INFECTED = -19
ERR_BLOCKED_BY_CLIENT = -20
ERR_NETWORK_CHANGED = -21
ERR_BLOCKED_BY_ADMINISTRATOR = -22
ERR_SOCKET_IS_CONNECTED = -23
ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED = -25
ERR_CONTEXT_SHUT_DOWN = -26
ERR_BLOCKED_BY_RESPONSE = -27
ERR_CLEARTEXT_NOT_PERMITTED = -29
ERR_BLOCKED_BY_CSP = -30
ERR_H2_OR_QUIC_REQUIRED = -31
ERR_BLOCKED_BY_ORB = -32
ERR_NETWORK_ACCESS_REVOKED = -33
ERR_CONNECTION_CLOSED = -100
ERR_CONNECTION_RESET = -101
ERR_CONNECTION_REFUSED = -102
ERR_CONNECTION_ABORTED = -103
ERR_CONNECTION_FAILED = -104
ERR_NAME_NOT_RESOLVED = -105
ERR_INTERNET_DISCONNECTED = -106
ERR_SSL_PROTOCOL_ERROR = -107
ERR_ADDRESS_INVALID = -108
ERR_ADDRESS_UNREACHABLE = -109
ERR_SSL_CLIENT_AUTH_CERT_NEEDED = -110
ERR_TUNNEL_CONNECTION_FAILED = -111
ERR_NO_SSL_VERSIONS_ENABLED = -112
ERR_SSL_VERSION_OR_CIPHER_MISMATCH = -113
ERR_SSL_RENEGOTIATION_REQUESTED = -114
ERR_PROXY_AUTH_UNSUPPORTED = -115
ERR_BAD_SSL_CLIENT_AUTH_CERT = -117
ERR_CONNECTION_TIMED_OUT = -118
ERR_HOST_RESOLVER_QUEUE_TOO_LARGE = -119
ERR_SOCKS_CONNECTION_FAILED = -120
ERR_SOCKS_CONNECTION_HOST_UNREACHABLE = -121
ERR_ALPN_NEGOTIATION_FAILED = -122
ERR_SSL_NO_RENEGOTIATION = -123
ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES = -124
ERR_SSL_DECOMPRESSION_FAILURE_ALERT = -125
ERR_SSL_BAD_RECORD_MAC_ALERT = -126
ERR_PROXY_AUTH_REQUESTED = -127
ERR_PROXY_CONNECTION_FAILED = -130
ERR_MANDATORY_PROXY_CONFIGURATION_FAILED = -131
ERR_PRECONNECT_MAX_SOCKET_LIMIT = -133
ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED = -134
ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY = -135
ERR_PROXY_CERTIFICATE_INVALID = -136
ERR_NAME_RESOLUTION_FAILED = -137
ERR_NETWORK_ACCESS_DENIED = -138
ERR_TEMPORARILY_THROTTLED = -139
ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT = -140
ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED = -141
ERR_MSG_TOO_BIG = -142
ERR_WS_PROTOCOL_ERROR = -145
ERR_ADDRESS_IN_USE = -147
ERR_SSL_HANDSHAKE_NOT_COMPLETED = -148
ERR_SSL_BAD_PEER_PUBLIC_KEY = -149
ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN = -150
ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED = -151
ERR_SSL_DECRYPT_ERROR_ALERT = -153
ERR_WS_THROTTLE_QUEUE_TOO_LARGE = -154
ERR_SSL_SERVER_CERT_CHANGED = -156
ERR_SSL_UNRECOGNIZED_NAME_ALERT = -159
ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR = -160
ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR = -161
ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE = -162
ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE = -163
ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT = -164
ERR_ICANN_NAME_COLLISION = -166
ERR_SSL_SERVER_CERT_BAD_FORMAT = -167
ERR_CT_STH_PARSING_FAILED = -168
ERR_CT_STH_INCOMPLETE = -169
ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH = -170
ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED = -171
ERR_SSL_OBSOLETE_CIPHER = -172
ERR_WS_UPGRADE = -173
ERR_READ_IF_READY_NOT_IMPLEMENTED = -174
ERR_NO_BUFFER_SPACE = -176
ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS = -177
ERR_EARLY_DATA_REJECTED = -178
ERR_WRONG_VERSION_ON_EARLY_DATA = -179
ERR_TLS13_DOWNGRADE_DETECTED = -180
ERR_SSL_KEY_USAGE_INCOMPATIBLE = -181
ERR_INVALID_ECH_CONFIG_LIST = -182
ERR_ECH_NOT_NEGOTIATED = -183
ERR_ECH_FALLBACK_CERTIFICATE_INVALID = -184
ERR_CERT_COMMON_NAME_INVALID = -200
ERR_CERT_DATE_INVALID = -201
ERR_CERT_AUTHORITY_INVALID = -202
ERR_CERT_CONTAINS_ERRORS = -203
ERR_CERT_NO_REVOCATION_MECHANISM = -204
ERR_CERT_UNABLE_TO_CHECK_REVOCATION = -205
ERR_CERT_REVOKED = -206
ERR_CERT_INVALID = -207
ERR_CERT_WEAK_SIGNATURE_ALGORITHM = -208
ERR_CERT_NON_UNIQUE_NAME = -210
ERR_CERT_WEAK_KEY = -211
ERR_CERT_NAME_CONSTRAINT_VIOLATION = -212
ERR_CERT_VALIDITY_TOO_LONG = -213
ERR_CERTIFICATE_TRANSPARENCY_REQUIRED = -214
ERR_CERT_SYMANTEC_LEGACY = -215
ERR_CERT_KNOWN_INTERCEPTION_BLOCKED = -217
ERR_CERT_END = -219
ERR_INVALID_URL = -300
ERR_DISALLOWED_URL_SCHEME = -301
ERR_UNKNOWN_URL_SCHEME = -302
ERR_INVALID_REDIRECT = -303
ERR_TOO_MANY_REDIRECTS = -310
ERR_UNSAFE_REDIRECT = -311
ERR_UNSAFE_PORT = -312
ERR_INVALID_RESPONSE = -320
ERR_INVALID_CHUNKED_ENCODING = -321
ERR_METHOD_NOT_SUPPORTED = -322
ERR_UNEXPECTED_PROXY_AUTH = -323
ERR_EMPTY_RESPONSE = -324
ERR_RESPONSE_HEADERS_TOO_BIG = -325
ERR_PAC_SCRIPT_FAILED = -327
ERR_REQUEST_RANGE_NOT_SATISFIABLE = -328
ERR_MALFORMED_IDENTITY = -329
ERR_CONTENT_DECODING_FAILED = -330
ERR_NETWORK_IO_SUSPENDED = -331
ERR_SYN_REPLY_NOT_RECEIVED = -332
ERR_ENCODING_CONVERSION_FAILED = -333
ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT = -334
ERR_NO_SUPPORTED_PROXIES = -336
ERR_HTTP2_PROTOCOL_ERROR = -337
ERR_INVALID_AUTH_CREDENTIALS = -338
ERR_UNSUPPORTED_AUTH_SCHEME = -339
ERR_ENCODING_DETECTION_FAILED = -340
ERR_MISSING_AUTH_CREDENTIALS = -341
ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS = -342
ERR_MISCONFIGURED_AUTH_ENVIRONMENT = -343
ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS = -344
ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN = -345
ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH = -346
ERR_INCOMPLETE_HTTP2_HEADERS = -347
ERR_PAC_NOT_IN_DHCP = -348
ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION = -349
ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION = -350
ERR_HTTP2_SERVER_REFUSED_STREAM = -351
ERR_HTTP2_PING_FAILED = -352
ERR_CONTENT_LENGTH_MISMATCH = -354
ERR_INCOMPLETE_CHUNKED_ENCODING = -355
ERR_QUIC_PROTOCOL_ERROR = -356
ERR_RESPONSE_HEADERS_TRUNCATED = -357
ERR_QUIC_HANDSHAKE_FAILED = -358
ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY = -360
ERR_HTTP2_FLOW_CONTROL_ERROR = -361
ERR_HTTP2_FRAME_SIZE_ERROR = -362
ERR_HTTP2_COMPRESSION_ERROR = -363
ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION = -364
ERR_HTTP_1_1_REQUIRED = -365
ERR_PROXY_HTTP_1_1_REQUIRED = -366
ERR_PAC_SCRIPT_TERMINATED = -367
ERR_INVALID_HTTP_RESPONSE = -370
ERR_CONTENT_DECODING_INIT_FAILED = -371
ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED = -372
ERR_TOO_MANY_RETRIES = -375
ERR_HTTP2_STREAM_CLOSED = -376
ERR_HTTP_RESPONSE_CODE_FAILURE = -379
ERR_QUIC_CERT_ROOT_NOT_KNOWN = -380
ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED = -381
ERR_TOO_MANY_ACCEPT_CH_RESTARTS = -382
ERR_INCONSISTENT_IP_ADDRESS_SPACE = -383
ERR_CACHED_IP_ADDRESS_SPACE_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_POLICY = -384
ERR_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_CHECKS = -385
ERR_ZSTD_WINDOW_SIZE_TOO_BIG = -386
ERR_DICTIONARY_LOAD_FAILED = -387
ERR_UNEXPECTED_CONTENT_DICTIONARY_HEADER = -388
ERR_CACHE_MISS = -400
ERR_CACHE_READ_FAILURE = -401
ERR_CACHE_WRITE_FAILURE = -402
ERR_CACHE_OPERATION_NOT_SUPPORTED = -403
ERR_CACHE_OPEN_FAILURE = -404
ERR_CACHE_CREATE_FAILURE = -405
ERR_CACHE_RACE = -406
ERR_CACHE_CHECKSUM_READ_FAILURE = -407
ERR_CACHE_CHECKSUM_MISMATCH = -408
ERR_CACHE_LOCK_TIMEOUT = -409
ERR_CACHE_AUTH_FAILURE_AFTER_READ = -410
ERR_CACHE_ENTRY_NOT_SUITABLE = -411
ERR_CACHE_DOOM_FAILURE = -412
ERR_CACHE_OPEN_OR_CREATE_FAILURE = -413
ERR_INSECURE_RESPONSE = -501
ERR_NO_PRIVATE_KEY_FOR_CERT = -502
ERR_ADD_USER_CERT_FAILED = -503
ERR_INVALID_SIGNED_EXCHANGE = -504
ERR_INVALID_WEB_BUNDLE = -505
ERR_TRUST_TOKEN_OPERATION_FAILED = -506
ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST = -507
ERR_PKCS12_IMPORT_BAD_PASSWORD = -701
ERR_PKCS12_IMPORT_FAILED = -702
ERR_IMPORT_CA_CERT_NOT_CA = -703
ERR_IMPORT_CERT_ALREADY_EXISTS = -704
ERR_IMPORT_CA_CERT_FAILED = -705
ERR_IMPORT_SERVER_CERT_FAILED = -706
ERR_PKCS12_IMPORT_INVALID_MAC = -707
ERR_PKCS12_IMPORT_INVALID_FILE = -708
ERR_PKCS12_IMPORT_UNSUPPORTED = -709
ERR_KEY_GENERATION_FAILED = -710
ERR_PRIVATE_KEY_EXPORT_FAILED = -712
ERR_SELF_SIGNED_CERT_GENERATION_FAILED = -713
ERR_CERT_DATABASE_CHANGED = -714
ERR_CERT_VERIFIER_CHANGED = -716
ERR_DNS_MALFORMED_RESPONSE = -800
ERR_DNS_SERVER_REQUIRES_TCP = -801
ERR_DNS_SERVER_FAILED = -802
ERR_DNS_TIMED_OUT = -803
ERR_DNS_CACHE_MISS = -804
ERR_DNS_SEARCH_EMPTY = -805
ERR_DNS_SORT_ERROR = -806
ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED = -808
ERR_DNS_NAME_HTTPS_ONLY = -809
ERR_DNS_REQUEST_CANCELLED = -810
ERR_DNS_NO_MATCHING_SUPPORTED_ALPN = -811
ERR_DNS_SECURE_PROBE_RECORD_INVALID = -814
c__EA_cef_errorcode_t = ctypes.c_int32 # enum
# Supported error code values. For the complete list of error values see
# "include/base/internal/cef_net_error_list.h".
# Supported error code values. For the complete list of error values see
# "include/base/internal/cef_net_error_list.h".
cef_errorcode_t = c__EA_cef_errorcode_t
cef_errorcode_t__enumvalues = c__EA_cef_errorcode_t__enumvalues
# Supported certificate status code values. See net_status_flags.h for more
# information. CERT_STATUS_NONE is new in CEF because we use an enum while
# cert_status_flags.h uses a typedef and static const variables.
# Supported certificate status code values. See net_status_flags.h for more
# information. CERT_STATUS_NONE is new in CEF because we use an enum while
# cert_status_flags.h uses a typedef and static const variables.

# values for enumeration 'c__EA_cef_cert_status_t'
c__EA_cef_cert_status_t__enumvalues = {
    0: 'CERT_STATUS_NONE',
    1: 'CERT_STATUS_COMMON_NAME_INVALID',
    2: 'CERT_STATUS_DATE_INVALID',
    4: 'CERT_STATUS_AUTHORITY_INVALID',
    16: 'CERT_STATUS_NO_REVOCATION_MECHANISM',
    32: 'CERT_STATUS_UNABLE_TO_CHECK_REVOCATION',
    64: 'CERT_STATUS_REVOKED',
    128: 'CERT_STATUS_INVALID',
    256: 'CERT_STATUS_WEAK_SIGNATURE_ALGORITHM',
    1024: 'CERT_STATUS_NON_UNIQUE_NAME',
    2048: 'CERT_STATUS_WEAK_KEY',
    8192: 'CERT_STATUS_PINNED_KEY_MISSING',
    16384: 'CERT_STATUS_NAME_CONSTRAINT_VIOLATION',
    32768: 'CERT_STATUS_VALIDITY_TOO_LONG',
    65536: 'CERT_STATUS_IS_EV',
    131072: 'CERT_STATUS_REV_CHECKING_ENABLED',
    524288: 'CERT_STATUS_SHA1_SIGNATURE_PRESENT',
    1048576: 'CERT_STATUS_CT_COMPLIANCE_FAILED',
}
CERT_STATUS_NONE = 0
CERT_STATUS_COMMON_NAME_INVALID = 1
CERT_STATUS_DATE_INVALID = 2
CERT_STATUS_AUTHORITY_INVALID = 4
CERT_STATUS_NO_REVOCATION_MECHANISM = 16
CERT_STATUS_UNABLE_TO_CHECK_REVOCATION = 32
CERT_STATUS_REVOKED = 64
CERT_STATUS_INVALID = 128
CERT_STATUS_WEAK_SIGNATURE_ALGORITHM = 256
CERT_STATUS_NON_UNIQUE_NAME = 1024
CERT_STATUS_WEAK_KEY = 2048
CERT_STATUS_PINNED_KEY_MISSING = 8192
CERT_STATUS_NAME_CONSTRAINT_VIOLATION = 16384
CERT_STATUS_VALIDITY_TOO_LONG = 32768
CERT_STATUS_IS_EV = 65536
CERT_STATUS_REV_CHECKING_ENABLED = 131072
CERT_STATUS_SHA1_SIGNATURE_PRESENT = 524288
CERT_STATUS_CT_COMPLIANCE_FAILED = 1048576
c__EA_cef_cert_status_t = ctypes.c_uint32 # enum
# Supported certificate status code values. See net_status_flags.h for more
# information. CERT_STATUS_NONE is new in CEF because we use an enum while
# cert_status_flags.h uses a typedef and static const variables.
# Supported certificate status code values. See net_status_flags.h for more
# information. CERT_STATUS_NONE is new in CEF because we use an enum while
# cert_status_flags.h uses a typedef and static const variables.
cef_cert_status_t = c__EA_cef_cert_status_t
cef_cert_status_t__enumvalues = c__EA_cef_cert_status_t__enumvalues
# Process result codes. This is not a comprehensive list, as result codes might
# also include platform-specific crash values (Posix signal or Windows hardware
# exception), or internal-only implementation values.
# Process result codes. This is not a comprehensive list, as result codes might
# also include platform-specific crash values (Posix signal or Windows hardware
# exception), or internal-only implementation values.

# values for enumeration 'c__EA_cef_resultcode_t'
c__EA_cef_resultcode_t__enumvalues = {
    0: 'CEF_RESULT_CODE_NORMAL_EXIT',
    1: 'CEF_RESULT_CODE_KILLED',
    2: 'CEF_RESULT_CODE_HUNG',
    3: 'CEF_RESULT_CODE_KILLED_BAD_MESSAGE',
    4: 'CEF_RESULT_CODE_GPU_DEAD_ON_ARRIVAL',
    5: 'CEF_RESULT_CODE_CHROME_FIRST',
    7: 'CEF_RESULT_CODE_MISSING_DATA',
    13: 'CEF_RESULT_CODE_UNSUPPORTED_PARAM',
    21: 'CEF_RESULT_CODE_PROFILE_IN_USE',
    22: 'CEF_RESULT_CODE_PACK_EXTENSION_ERROR',
    24: 'CEF_RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED',
    31: 'CEF_RESULT_CODE_INVALID_SANDBOX_STATE',
    32: 'CEF_RESULT_CODE_CLOUD_POLICY_ENROLLMENT_FAILED',
    34: 'CEF_RESULT_CODE_GPU_EXIT_ON_CONTEXT_LOST',
    36: 'CEF_RESULT_CODE_NORMAL_EXIT_PACK_EXTENSION_SUCCESS',
    37: 'CEF_RESULT_CODE_SYSTEM_RESOURCE_EXHAUSTED',
    38: 'CEF_RESULT_CODE_CHROME_LAST',
    7006: 'CEF_RESULT_CODE_SANDBOX_FATAL_FIRST',
    7006: 'CEF_RESULT_CODE_SANDBOX_FATAL_INTEGRITY',
    7007: 'CEF_RESULT_CODE_SANDBOX_FATAL_DROPTOKEN',
    7008: 'CEF_RESULT_CODE_SANDBOX_FATAL_FLUSHANDLES',
    7009: 'CEF_RESULT_CODE_SANDBOX_FATAL_CACHEDISABLE',
    7010: 'CEF_RESULT_CODE_SANDBOX_FATAL_CLOSEHANDLES',
    7011: 'CEF_RESULT_CODE_SANDBOX_FATAL_MITIGATION',
    7012: 'CEF_RESULT_CODE_SANDBOX_FATAL_MEMORY_EXCEEDED',
    7013: 'CEF_RESULT_CODE_SANDBOX_FATAL_WARMUP',
    7014: 'CEF_RESULT_CODE_SANDBOX_FATAL_BROKER_SHUTDOWN_HUNG',
    7015: 'CEF_RESULT_CODE_SANDBOX_FATAL_LAST',
}
CEF_RESULT_CODE_NORMAL_EXIT = 0
CEF_RESULT_CODE_KILLED = 1
CEF_RESULT_CODE_HUNG = 2
CEF_RESULT_CODE_KILLED_BAD_MESSAGE = 3
CEF_RESULT_CODE_GPU_DEAD_ON_ARRIVAL = 4
CEF_RESULT_CODE_CHROME_FIRST = 5
CEF_RESULT_CODE_MISSING_DATA = 7
CEF_RESULT_CODE_UNSUPPORTED_PARAM = 13
CEF_RESULT_CODE_PROFILE_IN_USE = 21
CEF_RESULT_CODE_PACK_EXTENSION_ERROR = 22
CEF_RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED = 24
CEF_RESULT_CODE_INVALID_SANDBOX_STATE = 31
CEF_RESULT_CODE_CLOUD_POLICY_ENROLLMENT_FAILED = 32
CEF_RESULT_CODE_GPU_EXIT_ON_CONTEXT_LOST = 34
CEF_RESULT_CODE_NORMAL_EXIT_PACK_EXTENSION_SUCCESS = 36
CEF_RESULT_CODE_SYSTEM_RESOURCE_EXHAUSTED = 37
CEF_RESULT_CODE_CHROME_LAST = 38
CEF_RESULT_CODE_SANDBOX_FATAL_FIRST = 7006
CEF_RESULT_CODE_SANDBOX_FATAL_INTEGRITY = 7006
CEF_RESULT_CODE_SANDBOX_FATAL_DROPTOKEN = 7007
CEF_RESULT_CODE_SANDBOX_FATAL_FLUSHANDLES = 7008
CEF_RESULT_CODE_SANDBOX_FATAL_CACHEDISABLE = 7009
CEF_RESULT_CODE_SANDBOX_FATAL_CLOSEHANDLES = 7010
CEF_RESULT_CODE_SANDBOX_FATAL_MITIGATION = 7011
CEF_RESULT_CODE_SANDBOX_FATAL_MEMORY_EXCEEDED = 7012
CEF_RESULT_CODE_SANDBOX_FATAL_WARMUP = 7013
CEF_RESULT_CODE_SANDBOX_FATAL_BROKER_SHUTDOWN_HUNG = 7014
CEF_RESULT_CODE_SANDBOX_FATAL_LAST = 7015
c__EA_cef_resultcode_t = ctypes.c_uint32 # enum
# Process result codes. This is not a comprehensive list, as result codes might
# also include platform-specific crash values (Posix signal or Windows hardware
# exception), or internal-only implementation values.
# Process result codes. This is not a comprehensive list, as result codes might
# also include platform-specific crash values (Posix signal or Windows hardware
# exception), or internal-only implementation values.
cef_resultcode_t = c__EA_cef_resultcode_t
cef_resultcode_t__enumvalues = c__EA_cef_resultcode_t__enumvalues
# The manner in which a link click should be opened. These constants match their
# equivalents in Chromium's window_open_disposition.h and should not be
# renumbered.
# The manner in which a link click should be opened. These constants match their
# equivalents in Chromium's window_open_disposition.h and should not be
# renumbered.

# values for enumeration 'c__EA_cef_window_open_disposition_t'
c__EA_cef_window_open_disposition_t__enumvalues = {
    0: 'CEF_WOD_UNKNOWN',
    1: 'CEF_WOD_CURRENT_TAB',
    2: 'CEF_WOD_SINGLETON_TAB',
    3: 'CEF_WOD_NEW_FOREGROUND_TAB',
    4: 'CEF_WOD_NEW_BACKGROUND_TAB',
    5: 'CEF_WOD_NEW_POPUP',
    6: 'CEF_WOD_NEW_WINDOW',
    7: 'CEF_WOD_SAVE_TO_DISK',
    8: 'CEF_WOD_OFF_THE_RECORD',
    9: 'CEF_WOD_IGNORE_ACTION',
    10: 'CEF_WOD_SWITCH_TO_TAB',
    11: 'CEF_WOD_NEW_PICTURE_IN_PICTURE',
    11: 'CEF_WOD_MAX_VALUE',
}
CEF_WOD_UNKNOWN = 0
CEF_WOD_CURRENT_TAB = 1
CEF_WOD_SINGLETON_TAB = 2
CEF_WOD_NEW_FOREGROUND_TAB = 3
CEF_WOD_NEW_BACKGROUND_TAB = 4
CEF_WOD_NEW_POPUP = 5
CEF_WOD_NEW_WINDOW = 6
CEF_WOD_SAVE_TO_DISK = 7
CEF_WOD_OFF_THE_RECORD = 8
CEF_WOD_IGNORE_ACTION = 9
CEF_WOD_SWITCH_TO_TAB = 10
CEF_WOD_NEW_PICTURE_IN_PICTURE = 11
CEF_WOD_MAX_VALUE = 11
c__EA_cef_window_open_disposition_t = ctypes.c_uint32 # enum
# The manner in which a link click should be opened. These constants match their
# equivalents in Chromium's window_open_disposition.h and should not be
# renumbered.
# The manner in which a link click should be opened. These constants match their
# equivalents in Chromium's window_open_disposition.h and should not be
# renumbered.
cef_window_open_disposition_t = c__EA_cef_window_open_disposition_t
cef_window_open_disposition_t__enumvalues = c__EA_cef_window_open_disposition_t__enumvalues
# "Verb" of a drag-and-drop operation as negotiated between the source and
# destination. These constants match their equivalents in WebCore's
# DragActions.h and should not be renumbered.
# "Verb" of a drag-and-drop operation as negotiated between the source and
# destination. These constants match their equivalents in WebCore's
# DragActions.h and should not be renumbered.

# values for enumeration 'c__EA_cef_drag_operations_mask_t'
c__EA_cef_drag_operations_mask_t__enumvalues = {
    0: 'DRAG_OPERATION_NONE',
    1: 'DRAG_OPERATION_COPY',
    2: 'DRAG_OPERATION_LINK',
    4: 'DRAG_OPERATION_GENERIC',
    8: 'DRAG_OPERATION_PRIVATE',
    16: 'DRAG_OPERATION_MOVE',
    32: 'DRAG_OPERATION_DELETE',
    4294967295: 'DRAG_OPERATION_EVERY',
}
DRAG_OPERATION_NONE = 0
DRAG_OPERATION_COPY = 1
DRAG_OPERATION_LINK = 2
DRAG_OPERATION_GENERIC = 4
DRAG_OPERATION_PRIVATE = 8
DRAG_OPERATION_MOVE = 16
DRAG_OPERATION_DELETE = 32
DRAG_OPERATION_EVERY = 4294967295
c__EA_cef_drag_operations_mask_t = ctypes.c_uint32 # enum
# "Verb" of a drag-and-drop operation as negotiated between the source and
# destination. These constants match their equivalents in WebCore's
# DragActions.h and should not be renumbered.
# "Verb" of a drag-and-drop operation as negotiated between the source and
# destination. These constants match their equivalents in WebCore's
# DragActions.h and should not be renumbered.
cef_drag_operations_mask_t = c__EA_cef_drag_operations_mask_t
cef_drag_operations_mask_t__enumvalues = c__EA_cef_drag_operations_mask_t__enumvalues
# Input mode of a virtual keyboard. These constants match their equivalents in
# Chromium's text_input_mode.h and should not be renumbered. See
# https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute
# Input mode of a virtual keyboard. These constants match their equivalents in
# Chromium's text_input_mode.h and should not be renumbered. See
# https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute

# values for enumeration 'c__EA_cef_text_input_mode_t'
c__EA_cef_text_input_mode_t__enumvalues = {
    0: 'CEF_TEXT_INPUT_MODE_DEFAULT',
    1: 'CEF_TEXT_INPUT_MODE_NONE',
    2: 'CEF_TEXT_INPUT_MODE_TEXT',
    3: 'CEF_TEXT_INPUT_MODE_TEL',
    4: 'CEF_TEXT_INPUT_MODE_URL',
    5: 'CEF_TEXT_INPUT_MODE_EMAIL',
    6: 'CEF_TEXT_INPUT_MODE_NUMERIC',
    7: 'CEF_TEXT_INPUT_MODE_DECIMAL',
    8: 'CEF_TEXT_INPUT_MODE_SEARCH',
    8: 'CEF_TEXT_INPUT_MODE_MAX',
}
CEF_TEXT_INPUT_MODE_DEFAULT = 0
CEF_TEXT_INPUT_MODE_NONE = 1
CEF_TEXT_INPUT_MODE_TEXT = 2
CEF_TEXT_INPUT_MODE_TEL = 3
CEF_TEXT_INPUT_MODE_URL = 4
CEF_TEXT_INPUT_MODE_EMAIL = 5
CEF_TEXT_INPUT_MODE_NUMERIC = 6
CEF_TEXT_INPUT_MODE_DECIMAL = 7
CEF_TEXT_INPUT_MODE_SEARCH = 8
CEF_TEXT_INPUT_MODE_MAX = 8
c__EA_cef_text_input_mode_t = ctypes.c_uint32 # enum
# Input mode of a virtual keyboard. These constants match their equivalents in
# Chromium's text_input_mode.h and should not be renumbered. See
# https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute
# Input mode of a virtual keyboard. These constants match their equivalents in
# Chromium's text_input_mode.h and should not be renumbered. See
# https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute
cef_text_input_mode_t = c__EA_cef_text_input_mode_t
cef_text_input_mode_t__enumvalues = c__EA_cef_text_input_mode_t__enumvalues
# V8 property attribute values.
# V8 property attribute values.

# values for enumeration 'c__EA_cef_v8_propertyattribute_t'
c__EA_cef_v8_propertyattribute_t__enumvalues = {
    0: 'V8_PROPERTY_ATTRIBUTE_NONE',
    1: 'V8_PROPERTY_ATTRIBUTE_READONLY',
    2: 'V8_PROPERTY_ATTRIBUTE_DONTENUM',
    4: 'V8_PROPERTY_ATTRIBUTE_DONTDELETE',
}
V8_PROPERTY_ATTRIBUTE_NONE = 0
V8_PROPERTY_ATTRIBUTE_READONLY = 1
V8_PROPERTY_ATTRIBUTE_DONTENUM = 2
V8_PROPERTY_ATTRIBUTE_DONTDELETE = 4
c__EA_cef_v8_propertyattribute_t = ctypes.c_uint32 # enum
# V8 property attribute values.
# V8 property attribute values.
cef_v8_propertyattribute_t = c__EA_cef_v8_propertyattribute_t
cef_v8_propertyattribute_t__enumvalues = c__EA_cef_v8_propertyattribute_t__enumvalues
# Post data elements may represent either bytes or files.
# Post data elements may represent either bytes or files.

# values for enumeration 'c__EA_cef_postdataelement_type_t'
c__EA_cef_postdataelement_type_t__enumvalues = {
    0: 'PDE_TYPE_EMPTY',
    1: 'PDE_TYPE_BYTES',
    2: 'PDE_TYPE_FILE',
}
PDE_TYPE_EMPTY = 0
PDE_TYPE_BYTES = 1
PDE_TYPE_FILE = 2
c__EA_cef_postdataelement_type_t = ctypes.c_uint32 # enum
# Post data elements may represent either bytes or files.
# Post data elements may represent either bytes or files.
cef_postdataelement_type_t = c__EA_cef_postdataelement_type_t
cef_postdataelement_type_t__enumvalues = c__EA_cef_postdataelement_type_t__enumvalues
# Resource type for a request. These constants match their equivalents in
# Chromium's ResourceType and should not be renumbered.
# Resource type for a request. These constants match their equivalents in
# Chromium's ResourceType and should not be renumbered.

# values for enumeration 'c__EA_cef_resource_type_t'
c__EA_cef_resource_type_t__enumvalues = {
    0: 'RT_MAIN_FRAME',
    1: 'RT_SUB_FRAME',
    2: 'RT_STYLESHEET',
    3: 'RT_SCRIPT',
    4: 'RT_IMAGE',
    5: 'RT_FONT_RESOURCE',
    6: 'RT_SUB_RESOURCE',
    7: 'RT_OBJECT',
    8: 'RT_MEDIA',
    9: 'RT_WORKER',
    10: 'RT_SHARED_WORKER',
    11: 'RT_PREFETCH',
    12: 'RT_FAVICON',
    13: 'RT_XHR',
    14: 'RT_PING',
    15: 'RT_SERVICE_WORKER',
    16: 'RT_CSP_REPORT',
    17: 'RT_PLUGIN_RESOURCE',
    19: 'RT_NAVIGATION_PRELOAD_MAIN_FRAME',
    20: 'RT_NAVIGATION_PRELOAD_SUB_FRAME',
}
RT_MAIN_FRAME = 0
RT_SUB_FRAME = 1
RT_STYLESHEET = 2
RT_SCRIPT = 3
RT_IMAGE = 4
RT_FONT_RESOURCE = 5
RT_SUB_RESOURCE = 6
RT_OBJECT = 7
RT_MEDIA = 8
RT_WORKER = 9
RT_SHARED_WORKER = 10
RT_PREFETCH = 11
RT_FAVICON = 12
RT_XHR = 13
RT_PING = 14
RT_SERVICE_WORKER = 15
RT_CSP_REPORT = 16
RT_PLUGIN_RESOURCE = 17
RT_NAVIGATION_PRELOAD_MAIN_FRAME = 19
RT_NAVIGATION_PRELOAD_SUB_FRAME = 20
c__EA_cef_resource_type_t = ctypes.c_uint32 # enum
# Resource type for a request. These constants match their equivalents in
# Chromium's ResourceType and should not be renumbered.
# Resource type for a request. These constants match their equivalents in
# Chromium's ResourceType and should not be renumbered.
cef_resource_type_t = c__EA_cef_resource_type_t
cef_resource_type_t__enumvalues = c__EA_cef_resource_type_t__enumvalues
# Transition type for a request. Made up of one source value and 0 or more
# qualifiers.
# Transition type for a request. Made up of one source value and 0 or more
# qualifiers.

# values for enumeration 'c__EA_cef_transition_type_t'
c__EA_cef_transition_type_t__enumvalues = {
    0: 'TT_LINK',
    1: 'TT_EXPLICIT',
    2: 'TT_AUTO_BOOKMARK',
    3: 'TT_AUTO_SUBFRAME',
    4: 'TT_MANUAL_SUBFRAME',
    5: 'TT_GENERATED',
    6: 'TT_AUTO_TOPLEVEL',
    7: 'TT_FORM_SUBMIT',
    8: 'TT_RELOAD',
    9: 'TT_KEYWORD',
    10: 'TT_KEYWORD_GENERATED',
    255: 'TT_SOURCE_MASK',
    8388608: 'TT_BLOCKED_FLAG',
    16777216: 'TT_FORWARD_BACK_FLAG',
    33554432: 'TT_DIRECT_LOAD_FLAG',
    67108864: 'TT_HOME_PAGE_FLAG',
    134217728: 'TT_FROM_API_FLAG',
    268435456: 'TT_CHAIN_START_FLAG',
    536870912: 'TT_CHAIN_END_FLAG',
    1073741824: 'TT_CLIENT_REDIRECT_FLAG',
    2147483648: 'TT_SERVER_REDIRECT_FLAG',
    3221225472: 'TT_IS_REDIRECT_MASK',
    4294967040: 'TT_QUALIFIER_MASK',
}
TT_LINK = 0
TT_EXPLICIT = 1
TT_AUTO_BOOKMARK = 2
TT_AUTO_SUBFRAME = 3
TT_MANUAL_SUBFRAME = 4
TT_GENERATED = 5
TT_AUTO_TOPLEVEL = 6
TT_FORM_SUBMIT = 7
TT_RELOAD = 8
TT_KEYWORD = 9
TT_KEYWORD_GENERATED = 10
TT_SOURCE_MASK = 255
TT_BLOCKED_FLAG = 8388608
TT_FORWARD_BACK_FLAG = 16777216
TT_DIRECT_LOAD_FLAG = 33554432
TT_HOME_PAGE_FLAG = 67108864
TT_FROM_API_FLAG = 134217728
TT_CHAIN_START_FLAG = 268435456
TT_CHAIN_END_FLAG = 536870912
TT_CLIENT_REDIRECT_FLAG = 1073741824
TT_SERVER_REDIRECT_FLAG = 2147483648
TT_IS_REDIRECT_MASK = 3221225472
TT_QUALIFIER_MASK = 4294967040
c__EA_cef_transition_type_t = ctypes.c_uint32 # enum
# Transition type for a request. Made up of one source value and 0 or more
# qualifiers.
# Transition type for a request. Made up of one source value and 0 or more
# qualifiers.
cef_transition_type_t = c__EA_cef_transition_type_t
cef_transition_type_t__enumvalues = c__EA_cef_transition_type_t__enumvalues
# Flags used to customize the behavior of CefURLRequest.
# Flags used to customize the behavior of CefURLRequest.

# values for enumeration 'c__EA_cef_urlrequest_flags_t'
c__EA_cef_urlrequest_flags_t__enumvalues = {
    0: 'UR_FLAG_NONE',
    1: 'UR_FLAG_SKIP_CACHE',
    2: 'UR_FLAG_ONLY_FROM_CACHE',
    4: 'UR_FLAG_DISABLE_CACHE',
    8: 'UR_FLAG_ALLOW_STORED_CREDENTIALS',
    16: 'UR_FLAG_REPORT_UPLOAD_PROGRESS',
    32: 'UR_FLAG_NO_DOWNLOAD_DATA',
    64: 'UR_FLAG_NO_RETRY_ON_5XX',
    128: 'UR_FLAG_STOP_ON_REDIRECT',
}
UR_FLAG_NONE = 0
UR_FLAG_SKIP_CACHE = 1
UR_FLAG_ONLY_FROM_CACHE = 2
UR_FLAG_DISABLE_CACHE = 4
UR_FLAG_ALLOW_STORED_CREDENTIALS = 8
UR_FLAG_REPORT_UPLOAD_PROGRESS = 16
UR_FLAG_NO_DOWNLOAD_DATA = 32
UR_FLAG_NO_RETRY_ON_5XX = 64
UR_FLAG_STOP_ON_REDIRECT = 128
c__EA_cef_urlrequest_flags_t = ctypes.c_uint32 # enum
# Flags used to customize the behavior of CefURLRequest.
# Flags used to customize the behavior of CefURLRequest.
cef_urlrequest_flags_t = c__EA_cef_urlrequest_flags_t
cef_urlrequest_flags_t__enumvalues = c__EA_cef_urlrequest_flags_t__enumvalues
# Flags that represent CefURLRequest status.
# Flags that represent CefURLRequest status.

# values for enumeration 'c__EA_cef_urlrequest_status_t'
c__EA_cef_urlrequest_status_t__enumvalues = {
    0: 'UR_UNKNOWN',
    1: 'UR_SUCCESS',
    2: 'UR_IO_PENDING',
    3: 'UR_CANCELED',
    4: 'UR_FAILED',
}
UR_UNKNOWN = 0
UR_SUCCESS = 1
UR_IO_PENDING = 2
UR_CANCELED = 3
UR_FAILED = 4
c__EA_cef_urlrequest_status_t = ctypes.c_uint32 # enum
# Flags that represent CefURLRequest status.
# Flags that represent CefURLRequest status.
cef_urlrequest_status_t = c__EA_cef_urlrequest_status_t
cef_urlrequest_status_t__enumvalues = c__EA_cef_urlrequest_status_t__enumvalues
# Structure representing a draggable region.
class struct__cef_draggable_region_t(Structure):
    pass

struct__cef_draggable_region_t._pack_ = 1 # source:False
struct__cef_draggable_region_t._fields_ = [
    ('bounds', cef_rect_t),
    ('draggable', ctypes.c_int32),
]

# Structure representing a draggable region.
# Structure representing a draggable region.
cef_draggable_region_t = struct__cef_draggable_region_t
# Existing process IDs.
# Existing process IDs.

# values for enumeration 'c__EA_cef_process_id_t'
c__EA_cef_process_id_t__enumvalues = {
    0: 'PID_BROWSER',
    1: 'PID_RENDERER',
}
PID_BROWSER = 0
PID_RENDERER = 1
c__EA_cef_process_id_t = ctypes.c_uint32 # enum
# Existing process IDs.
# Existing process IDs.
cef_process_id_t = c__EA_cef_process_id_t
cef_process_id_t__enumvalues = c__EA_cef_process_id_t__enumvalues
# Existing thread IDs.
# Existing thread IDs.

# values for enumeration 'c__EA_cef_thread_id_t'
c__EA_cef_thread_id_t__enumvalues = {
    0: 'TID_UI',
    1: 'TID_FILE_BACKGROUND',
    2: 'TID_FILE_USER_VISIBLE',
    3: 'TID_FILE_USER_BLOCKING',
    4: 'TID_PROCESS_LAUNCHER',
    5: 'TID_IO',
    6: 'TID_RENDERER',
}
TID_UI = 0
TID_FILE_BACKGROUND = 1
TID_FILE_USER_VISIBLE = 2
TID_FILE_USER_BLOCKING = 3
TID_PROCESS_LAUNCHER = 4
TID_IO = 5
TID_RENDERER = 6
c__EA_cef_thread_id_t = ctypes.c_uint32 # enum
# Existing thread IDs.
# Existing thread IDs.
cef_thread_id_t = c__EA_cef_thread_id_t
cef_thread_id_t__enumvalues = c__EA_cef_thread_id_t__enumvalues
# Thread priority values listed in increasing order of importance.
# Thread priority values listed in increasing order of importance.

# values for enumeration 'c__EA_cef_thread_priority_t'
c__EA_cef_thread_priority_t__enumvalues = {
    0: 'TP_BACKGROUND',
    1: 'TP_NORMAL',
    2: 'TP_DISPLAY',
    3: 'TP_REALTIME_AUDIO',
}
TP_BACKGROUND = 0
TP_NORMAL = 1
TP_DISPLAY = 2
TP_REALTIME_AUDIO = 3
c__EA_cef_thread_priority_t = ctypes.c_uint32 # enum
# Thread priority values listed in increasing order of importance.
# Thread priority values listed in increasing order of importance.
cef_thread_priority_t = c__EA_cef_thread_priority_t
cef_thread_priority_t__enumvalues = c__EA_cef_thread_priority_t__enumvalues
# Message loop types. Indicates the set of asynchronous events that a message
# loop can process.
# Message loop types. Indicates the set of asynchronous events that a message
# loop can process.

# values for enumeration 'c__EA_cef_message_loop_type_t'
c__EA_cef_message_loop_type_t__enumvalues = {
    0: 'ML_TYPE_DEFAULT',
    1: 'ML_TYPE_UI',
    2: 'ML_TYPE_IO',
}
ML_TYPE_DEFAULT = 0
ML_TYPE_UI = 1
ML_TYPE_IO = 2
c__EA_cef_message_loop_type_t = ctypes.c_uint32 # enum
# Message loop types. Indicates the set of asynchronous events that a message
# loop can process.
# Message loop types. Indicates the set of asynchronous events that a message
# loop can process.
cef_message_loop_type_t = c__EA_cef_message_loop_type_t
cef_message_loop_type_t__enumvalues = c__EA_cef_message_loop_type_t__enumvalues
# Windows COM initialization mode. Specifies how COM will be initialized for a
# new thread.
# Windows COM initialization mode. Specifies how COM will be initialized for a
# new thread.

# values for enumeration 'c__EA_cef_com_init_mode_t'
c__EA_cef_com_init_mode_t__enumvalues = {
    0: 'COM_INIT_MODE_NONE',
    1: 'COM_INIT_MODE_STA',
    2: 'COM_INIT_MODE_MTA',
}
COM_INIT_MODE_NONE = 0
COM_INIT_MODE_STA = 1
COM_INIT_MODE_MTA = 2
c__EA_cef_com_init_mode_t = ctypes.c_uint32 # enum
# Windows COM initialization mode. Specifies how COM will be initialized for a
# new thread.
# Windows COM initialization mode. Specifies how COM will be initialized for a
# new thread.
cef_com_init_mode_t = c__EA_cef_com_init_mode_t
cef_com_init_mode_t__enumvalues = c__EA_cef_com_init_mode_t__enumvalues
# Supported value types.
# Supported value types.

# values for enumeration 'c__EA_cef_value_type_t'
c__EA_cef_value_type_t__enumvalues = {
    0: 'VTYPE_INVALID',
    1: 'VTYPE_NULL',
    2: 'VTYPE_BOOL',
    3: 'VTYPE_INT',
    4: 'VTYPE_DOUBLE',
    5: 'VTYPE_STRING',
    6: 'VTYPE_BINARY',
    7: 'VTYPE_DICTIONARY',
    8: 'VTYPE_LIST',
}
VTYPE_INVALID = 0
VTYPE_NULL = 1
VTYPE_BOOL = 2
VTYPE_INT = 3
VTYPE_DOUBLE = 4
VTYPE_STRING = 5
VTYPE_BINARY = 6
VTYPE_DICTIONARY = 7
VTYPE_LIST = 8
c__EA_cef_value_type_t = ctypes.c_uint32 # enum
# Supported value types.
# Supported value types.
cef_value_type_t = c__EA_cef_value_type_t
cef_value_type_t__enumvalues = c__EA_cef_value_type_t__enumvalues
# Supported JavaScript dialog types.
# Supported JavaScript dialog types.

# values for enumeration 'c__EA_cef_jsdialog_type_t'
c__EA_cef_jsdialog_type_t__enumvalues = {
    0: 'JSDIALOGTYPE_ALERT',
    1: 'JSDIALOGTYPE_CONFIRM',
    2: 'JSDIALOGTYPE_PROMPT',
}
JSDIALOGTYPE_ALERT = 0
JSDIALOGTYPE_CONFIRM = 1
JSDIALOGTYPE_PROMPT = 2
c__EA_cef_jsdialog_type_t = ctypes.c_uint32 # enum
# Supported JavaScript dialog types.
# Supported JavaScript dialog types.
cef_jsdialog_type_t = c__EA_cef_jsdialog_type_t
cef_jsdialog_type_t__enumvalues = c__EA_cef_jsdialog_type_t__enumvalues
# Screen information used when window rendering is disabled. This structure is
# passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled
# in by the client.
class struct__cef_screen_info_t(Structure):
    pass

struct__cef_screen_info_t._pack_ = 1 # source:False
struct__cef_screen_info_t._fields_ = [
    ('device_scale_factor', ctypes.c_float),
    ('depth', ctypes.c_int32),
    ('depth_per_component', ctypes.c_int32),
    ('is_monochrome', ctypes.c_int32),
    ('rect', cef_rect_t),
    ('available_rect', cef_rect_t),
]

# Screen information used when window rendering is disabled. This structure is
# passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled
# in by the client.
# Screen information used when window rendering is disabled. This structure is
# passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled
# in by the client.
cef_screen_info_t = struct__cef_screen_info_t
# Linux window properties, such as X11's WM_CLASS or Wayland's app_id. Those are
# passed to CefWindowDelegate, so the client can set them for the CefWindow's
# top-level. Thus, allowing window managers to correctly display the
# application's information (e.g., icons).
class struct__cef_linux_window_properties_t(Structure):
    _pack_ = 1 # source:False
    _fields_ = [
    ('wayland_app_id', cef_string_t),
    ('wm_class_class', cef_string_t),
    ('wm_class_name', cef_string_t),
    ('wm_role_name', cef_string_t),
     ]

# Linux window properties, such as X11's WM_CLASS or Wayland's app_id. Those are
# passed to CefWindowDelegate, so the client can set them for the CefWindow's
# top-level. Thus, allowing window managers to correctly display the
# application's information (e.g., icons).
# Linux window properties, such as X11's WM_CLASS or Wayland's app_id. Those are
# passed to CefWindowDelegate, so the client can set them for the CefWindow's
# top-level. Thus, allowing window managers to correctly display the
# application's information (e.g., icons).
cef_linux_window_properties_t = struct__cef_linux_window_properties_t
# Supported menu IDs. Non-English translations can be provided for the
# IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().
# Supported menu IDs. Non-English translations can be provided for the
# IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().

# values for enumeration 'c__EA_cef_menu_id_t'
c__EA_cef_menu_id_t__enumvalues = {
    100: 'MENU_ID_BACK',
    101: 'MENU_ID_FORWARD',
    102: 'MENU_ID_RELOAD',
    103: 'MENU_ID_RELOAD_NOCACHE',
    104: 'MENU_ID_STOPLOAD',
    110: 'MENU_ID_UNDO',
    111: 'MENU_ID_REDO',
    112: 'MENU_ID_CUT',
    113: 'MENU_ID_COPY',
    114: 'MENU_ID_PASTE',
    115: 'MENU_ID_PASTE_MATCH_STYLE',
    116: 'MENU_ID_DELETE',
    117: 'MENU_ID_SELECT_ALL',
    130: 'MENU_ID_FIND',
    131: 'MENU_ID_PRINT',
    132: 'MENU_ID_VIEW_SOURCE',
    200: 'MENU_ID_SPELLCHECK_SUGGESTION_0',
    201: 'MENU_ID_SPELLCHECK_SUGGESTION_1',
    202: 'MENU_ID_SPELLCHECK_SUGGESTION_2',
    203: 'MENU_ID_SPELLCHECK_SUGGESTION_3',
    204: 'MENU_ID_SPELLCHECK_SUGGESTION_4',
    204: 'MENU_ID_SPELLCHECK_SUGGESTION_LAST',
    205: 'MENU_ID_NO_SPELLING_SUGGESTIONS',
    206: 'MENU_ID_ADD_TO_DICTIONARY',
    220: 'MENU_ID_CUSTOM_FIRST',
    250: 'MENU_ID_CUSTOM_LAST',
    26500: 'MENU_ID_USER_FIRST',
    28500: 'MENU_ID_USER_LAST',
}
MENU_ID_BACK = 100
MENU_ID_FORWARD = 101
MENU_ID_RELOAD = 102
MENU_ID_RELOAD_NOCACHE = 103
MENU_ID_STOPLOAD = 104
MENU_ID_UNDO = 110
MENU_ID_REDO = 111
MENU_ID_CUT = 112
MENU_ID_COPY = 113
MENU_ID_PASTE = 114
MENU_ID_PASTE_MATCH_STYLE = 115
MENU_ID_DELETE = 116
MENU_ID_SELECT_ALL = 117
MENU_ID_FIND = 130
MENU_ID_PRINT = 131
MENU_ID_VIEW_SOURCE = 132
MENU_ID_SPELLCHECK_SUGGESTION_0 = 200
MENU_ID_SPELLCHECK_SUGGESTION_1 = 201
MENU_ID_SPELLCHECK_SUGGESTION_2 = 202
MENU_ID_SPELLCHECK_SUGGESTION_3 = 203
MENU_ID_SPELLCHECK_SUGGESTION_4 = 204
MENU_ID_SPELLCHECK_SUGGESTION_LAST = 204
MENU_ID_NO_SPELLING_SUGGESTIONS = 205
MENU_ID_ADD_TO_DICTIONARY = 206
MENU_ID_CUSTOM_FIRST = 220
MENU_ID_CUSTOM_LAST = 250
MENU_ID_USER_FIRST = 26500
MENU_ID_USER_LAST = 28500
c__EA_cef_menu_id_t = ctypes.c_uint32 # enum
# Supported menu IDs. Non-English translations can be provided for the
# IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().
# Supported menu IDs. Non-English translations can be provided for the
# IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().
cef_menu_id_t = c__EA_cef_menu_id_t
cef_menu_id_t__enumvalues = c__EA_cef_menu_id_t__enumvalues
# Mouse button types.
# Mouse button types.

# values for enumeration 'c__EA_cef_mouse_button_type_t'
c__EA_cef_mouse_button_type_t__enumvalues = {
    0: 'MBT_LEFT',
    1: 'MBT_MIDDLE',
    2: 'MBT_RIGHT',
}
MBT_LEFT = 0
MBT_MIDDLE = 1
MBT_RIGHT = 2
c__EA_cef_mouse_button_type_t = ctypes.c_uint32 # enum
# Mouse button types.
# Mouse button types.
cef_mouse_button_type_t = c__EA_cef_mouse_button_type_t
cef_mouse_button_type_t__enumvalues = c__EA_cef_mouse_button_type_t__enumvalues
# Structure representing mouse event information.
class struct__cef_mouse_event_t(Structure):
    pass

struct__cef_mouse_event_t._pack_ = 1 # source:False
struct__cef_mouse_event_t._fields_ = [
    ('x', ctypes.c_int32),
    ('y', ctypes.c_int32),
    ('modifiers', ctypes.c_uint32),
]

# Structure representing mouse event information.
# Structure representing mouse event information.
cef_mouse_event_t = struct__cef_mouse_event_t
# Touch points states types.
# Touch points states types.

# values for enumeration 'c__EA_cef_touch_event_type_t'
c__EA_cef_touch_event_type_t__enumvalues = {
    0: 'CEF_TET_RELEASED',
    1: 'CEF_TET_PRESSED',
    2: 'CEF_TET_MOVED',
    3: 'CEF_TET_CANCELLED',
}
CEF_TET_RELEASED = 0
CEF_TET_PRESSED = 1
CEF_TET_MOVED = 2
CEF_TET_CANCELLED = 3
c__EA_cef_touch_event_type_t = ctypes.c_uint32 # enum
# Touch points states types.
# Touch points states types.
cef_touch_event_type_t = c__EA_cef_touch_event_type_t
cef_touch_event_type_t__enumvalues = c__EA_cef_touch_event_type_t__enumvalues
# The device type that caused the event.
# The device type that caused the event.

# values for enumeration 'c__EA_cef_pointer_type_t'
c__EA_cef_pointer_type_t__enumvalues = {
    0: 'CEF_POINTER_TYPE_TOUCH',
    1: 'CEF_POINTER_TYPE_MOUSE',
    2: 'CEF_POINTER_TYPE_PEN',
    3: 'CEF_POINTER_TYPE_ERASER',
    4: 'CEF_POINTER_TYPE_UNKNOWN',
}
CEF_POINTER_TYPE_TOUCH = 0
CEF_POINTER_TYPE_MOUSE = 1
CEF_POINTER_TYPE_PEN = 2
CEF_POINTER_TYPE_ERASER = 3
CEF_POINTER_TYPE_UNKNOWN = 4
c__EA_cef_pointer_type_t = ctypes.c_uint32 # enum
# The device type that caused the event.
# The device type that caused the event.
cef_pointer_type_t = c__EA_cef_pointer_type_t
cef_pointer_type_t__enumvalues = c__EA_cef_pointer_type_t__enumvalues
# Structure representing touch event information.
class struct__cef_touch_event_t(Structure):
    pass

struct__cef_touch_event_t._pack_ = 1 # source:False
struct__cef_touch_event_t._fields_ = [
    ('id', ctypes.c_int32),
    ('x', ctypes.c_float),
    ('y', ctypes.c_float),
    ('radius_x', ctypes.c_float),
    ('radius_y', ctypes.c_float),
    ('rotation_angle', ctypes.c_float),
    ('pressure', ctypes.c_float),
    ('type', cef_touch_event_type_t),
    ('modifiers', ctypes.c_uint32),
    ('pointer_type', cef_pointer_type_t),
]

# Structure representing touch event information.
# Structure representing touch event information.
cef_touch_event_t = struct__cef_touch_event_t
# Paint element types.
# Paint element types.

# values for enumeration 'c__EA_cef_paint_element_type_t'
c__EA_cef_paint_element_type_t__enumvalues = {
    0: 'PET_VIEW',
    1: 'PET_POPUP',
}
PET_VIEW = 0
PET_POPUP = 1
c__EA_cef_paint_element_type_t = ctypes.c_uint32 # enum
# Paint element types.
# Paint element types.
cef_paint_element_type_t = c__EA_cef_paint_element_type_t
cef_paint_element_type_t__enumvalues = c__EA_cef_paint_element_type_t__enumvalues
# Supported event bit flags.
# Supported event bit flags.

# values for enumeration 'c__EA_cef_event_flags_t'
c__EA_cef_event_flags_t__enumvalues = {
    0: 'EVENTFLAG_NONE',
    1: 'EVENTFLAG_CAPS_LOCK_ON',
    2: 'EVENTFLAG_SHIFT_DOWN',
    4: 'EVENTFLAG_CONTROL_DOWN',
    8: 'EVENTFLAG_ALT_DOWN',
    16: 'EVENTFLAG_LEFT_MOUSE_BUTTON',
    32: 'EVENTFLAG_MIDDLE_MOUSE_BUTTON',
    64: 'EVENTFLAG_RIGHT_MOUSE_BUTTON',
    128: 'EVENTFLAG_COMMAND_DOWN',
    256: 'EVENTFLAG_NUM_LOCK_ON',
    512: 'EVENTFLAG_IS_KEY_PAD',
    1024: 'EVENTFLAG_IS_LEFT',
    2048: 'EVENTFLAG_IS_RIGHT',
    4096: 'EVENTFLAG_ALTGR_DOWN',
    8192: 'EVENTFLAG_IS_REPEAT',
}
EVENTFLAG_NONE = 0
EVENTFLAG_CAPS_LOCK_ON = 1
EVENTFLAG_SHIFT_DOWN = 2
EVENTFLAG_CONTROL_DOWN = 4
EVENTFLAG_ALT_DOWN = 8
EVENTFLAG_LEFT_MOUSE_BUTTON = 16
EVENTFLAG_MIDDLE_MOUSE_BUTTON = 32
EVENTFLAG_RIGHT_MOUSE_BUTTON = 64
EVENTFLAG_COMMAND_DOWN = 128
EVENTFLAG_NUM_LOCK_ON = 256
EVENTFLAG_IS_KEY_PAD = 512
EVENTFLAG_IS_LEFT = 1024
EVENTFLAG_IS_RIGHT = 2048
EVENTFLAG_ALTGR_DOWN = 4096
EVENTFLAG_IS_REPEAT = 8192
c__EA_cef_event_flags_t = ctypes.c_uint32 # enum
# Supported event bit flags.
# Supported event bit flags.
cef_event_flags_t = c__EA_cef_event_flags_t
cef_event_flags_t__enumvalues = c__EA_cef_event_flags_t__enumvalues
# Supported menu item types.
# Supported menu item types.

# values for enumeration 'c__EA_cef_menu_item_type_t'
c__EA_cef_menu_item_type_t__enumvalues = {
    0: 'MENUITEMTYPE_NONE',
    1: 'MENUITEMTYPE_COMMAND',
    2: 'MENUITEMTYPE_CHECK',
    3: 'MENUITEMTYPE_RADIO',
    4: 'MENUITEMTYPE_SEPARATOR',
    5: 'MENUITEMTYPE_SUBMENU',
}
MENUITEMTYPE_NONE = 0
MENUITEMTYPE_COMMAND = 1
MENUITEMTYPE_CHECK = 2
MENUITEMTYPE_RADIO = 3
MENUITEMTYPE_SEPARATOR = 4
MENUITEMTYPE_SUBMENU = 5
c__EA_cef_menu_item_type_t = ctypes.c_uint32 # enum
# Supported menu item types.
# Supported menu item types.
cef_menu_item_type_t = c__EA_cef_menu_item_type_t
cef_menu_item_type_t__enumvalues = c__EA_cef_menu_item_type_t__enumvalues
# Supported context menu type flags.
# Supported context menu type flags.

# values for enumeration 'c__EA_cef_context_menu_type_flags_t'
c__EA_cef_context_menu_type_flags_t__enumvalues = {
    0: 'CM_TYPEFLAG_NONE',
    1: 'CM_TYPEFLAG_PAGE',
    2: 'CM_TYPEFLAG_FRAME',
    4: 'CM_TYPEFLAG_LINK',
    8: 'CM_TYPEFLAG_MEDIA',
    16: 'CM_TYPEFLAG_SELECTION',
    32: 'CM_TYPEFLAG_EDITABLE',
}
CM_TYPEFLAG_NONE = 0
CM_TYPEFLAG_PAGE = 1
CM_TYPEFLAG_FRAME = 2
CM_TYPEFLAG_LINK = 4
CM_TYPEFLAG_MEDIA = 8
CM_TYPEFLAG_SELECTION = 16
CM_TYPEFLAG_EDITABLE = 32
c__EA_cef_context_menu_type_flags_t = ctypes.c_uint32 # enum
# Supported context menu type flags.
# Supported context menu type flags.
cef_context_menu_type_flags_t = c__EA_cef_context_menu_type_flags_t
cef_context_menu_type_flags_t__enumvalues = c__EA_cef_context_menu_type_flags_t__enumvalues
# Supported context menu media types. These constants match their equivalents in
# Chromium's ContextMenuDataMediaType and should not be renumbered.
# Supported context menu media types. These constants match their equivalents in
# Chromium's ContextMenuDataMediaType and should not be renumbered.

# values for enumeration 'c__EA_cef_context_menu_media_type_t'
c__EA_cef_context_menu_media_type_t__enumvalues = {
    0: 'CM_MEDIATYPE_NONE',
    1: 'CM_MEDIATYPE_IMAGE',
    2: 'CM_MEDIATYPE_VIDEO',
    3: 'CM_MEDIATYPE_AUDIO',
    4: 'CM_MEDIATYPE_CANVAS',
    5: 'CM_MEDIATYPE_FILE',
    6: 'CM_MEDIATYPE_PLUGIN',
}
CM_MEDIATYPE_NONE = 0
CM_MEDIATYPE_IMAGE = 1
CM_MEDIATYPE_VIDEO = 2
CM_MEDIATYPE_AUDIO = 3
CM_MEDIATYPE_CANVAS = 4
CM_MEDIATYPE_FILE = 5
CM_MEDIATYPE_PLUGIN = 6
c__EA_cef_context_menu_media_type_t = ctypes.c_uint32 # enum
# Supported context menu media types. These constants match their equivalents in
# Chromium's ContextMenuDataMediaType and should not be renumbered.
# Supported context menu media types. These constants match their equivalents in
# Chromium's ContextMenuDataMediaType and should not be renumbered.
cef_context_menu_media_type_t = c__EA_cef_context_menu_media_type_t
cef_context_menu_media_type_t__enumvalues = c__EA_cef_context_menu_media_type_t__enumvalues
# Supported context menu media state bit flags. These constants match their
# equivalents in Chromium's ContextMenuData::MediaFlags and should not be
# renumbered.
# Supported context menu media state bit flags. These constants match their
# equivalents in Chromium's ContextMenuData::MediaFlags and should not be
# renumbered.

# values for enumeration 'c__EA_cef_context_menu_media_state_flags_t'
c__EA_cef_context_menu_media_state_flags_t__enumvalues = {
    0: 'CM_MEDIAFLAG_NONE',
    1: 'CM_MEDIAFLAG_IN_ERROR',
    2: 'CM_MEDIAFLAG_PAUSED',
    4: 'CM_MEDIAFLAG_MUTED',
    8: 'CM_MEDIAFLAG_LOOP',
    16: 'CM_MEDIAFLAG_CAN_SAVE',
    32: 'CM_MEDIAFLAG_HAS_AUDIO',
    64: 'CM_MEDIAFLAG_CAN_TOGGLE_CONTROLS',
    128: 'CM_MEDIAFLAG_CONTROLS',
    256: 'CM_MEDIAFLAG_CAN_PRINT',
    512: 'CM_MEDIAFLAG_CAN_ROTATE',
    1024: 'CM_MEDIAFLAG_CAN_PICTURE_IN_PICTURE',
    2048: 'CM_MEDIAFLAG_PICTURE_IN_PICTURE',
    4096: 'CM_MEDIAFLAG_CAN_LOOP',
}
CM_MEDIAFLAG_NONE = 0
CM_MEDIAFLAG_IN_ERROR = 1
CM_MEDIAFLAG_PAUSED = 2
CM_MEDIAFLAG_MUTED = 4
CM_MEDIAFLAG_LOOP = 8
CM_MEDIAFLAG_CAN_SAVE = 16
CM_MEDIAFLAG_HAS_AUDIO = 32
CM_MEDIAFLAG_CAN_TOGGLE_CONTROLS = 64
CM_MEDIAFLAG_CONTROLS = 128
CM_MEDIAFLAG_CAN_PRINT = 256
CM_MEDIAFLAG_CAN_ROTATE = 512
CM_MEDIAFLAG_CAN_PICTURE_IN_PICTURE = 1024
CM_MEDIAFLAG_PICTURE_IN_PICTURE = 2048
CM_MEDIAFLAG_CAN_LOOP = 4096
c__EA_cef_context_menu_media_state_flags_t = ctypes.c_uint32 # enum
# Supported context menu media state bit flags. These constants match their
# equivalents in Chromium's ContextMenuData::MediaFlags and should not be
# renumbered.
# Supported context menu media state bit flags. These constants match their
# equivalents in Chromium's ContextMenuData::MediaFlags and should not be
# renumbered.
cef_context_menu_media_state_flags_t = c__EA_cef_context_menu_media_state_flags_t
cef_context_menu_media_state_flags_t__enumvalues = c__EA_cef_context_menu_media_state_flags_t__enumvalues
# Supported context menu edit state bit flags. These constants match their
# equivalents in Chromium's ContextMenuDataEditFlags and should not be
# renumbered.
# Supported context menu edit state bit flags. These constants match their
# equivalents in Chromium's ContextMenuDataEditFlags and should not be
# renumbered.

# values for enumeration 'c__EA_cef_context_menu_edit_state_flags_t'
c__EA_cef_context_menu_edit_state_flags_t__enumvalues = {
    0: 'CM_EDITFLAG_NONE',
    1: 'CM_EDITFLAG_CAN_UNDO',
    2: 'CM_EDITFLAG_CAN_REDO',
    4: 'CM_EDITFLAG_CAN_CUT',
    8: 'CM_EDITFLAG_CAN_COPY',
    16: 'CM_EDITFLAG_CAN_PASTE',
    32: 'CM_EDITFLAG_CAN_DELETE',
    64: 'CM_EDITFLAG_CAN_SELECT_ALL',
    128: 'CM_EDITFLAG_CAN_TRANSLATE',
    256: 'CM_EDITFLAG_CAN_EDIT_RICHLY',
}
CM_EDITFLAG_NONE = 0
CM_EDITFLAG_CAN_UNDO = 1
CM_EDITFLAG_CAN_REDO = 2
CM_EDITFLAG_CAN_CUT = 4
CM_EDITFLAG_CAN_COPY = 8
CM_EDITFLAG_CAN_PASTE = 16
CM_EDITFLAG_CAN_DELETE = 32
CM_EDITFLAG_CAN_SELECT_ALL = 64
CM_EDITFLAG_CAN_TRANSLATE = 128
CM_EDITFLAG_CAN_EDIT_RICHLY = 256
c__EA_cef_context_menu_edit_state_flags_t = ctypes.c_uint32 # enum
# Supported context menu edit state bit flags. These constants match their
# equivalents in Chromium's ContextMenuDataEditFlags and should not be
# renumbered.
# Supported context menu edit state bit flags. These constants match their
# equivalents in Chromium's ContextMenuDataEditFlags and should not be
# renumbered.
cef_context_menu_edit_state_flags_t = c__EA_cef_context_menu_edit_state_flags_t
cef_context_menu_edit_state_flags_t__enumvalues = c__EA_cef_context_menu_edit_state_flags_t__enumvalues
# Supported quick menu state bit flags.
# Supported quick menu state bit flags.

# values for enumeration 'c__EA_cef_quick_menu_edit_state_flags_t'
c__EA_cef_quick_menu_edit_state_flags_t__enumvalues = {
    0: 'QM_EDITFLAG_NONE',
    1: 'QM_EDITFLAG_CAN_ELLIPSIS',
    2: 'QM_EDITFLAG_CAN_CUT',
    4: 'QM_EDITFLAG_CAN_COPY',
    8: 'QM_EDITFLAG_CAN_PASTE',
}
QM_EDITFLAG_NONE = 0
QM_EDITFLAG_CAN_ELLIPSIS = 1
QM_EDITFLAG_CAN_CUT = 2
QM_EDITFLAG_CAN_COPY = 4
QM_EDITFLAG_CAN_PASTE = 8
c__EA_cef_quick_menu_edit_state_flags_t = ctypes.c_uint32 # enum
# Supported quick menu state bit flags.
# Supported quick menu state bit flags.
cef_quick_menu_edit_state_flags_t = c__EA_cef_quick_menu_edit_state_flags_t
cef_quick_menu_edit_state_flags_t__enumvalues = c__EA_cef_quick_menu_edit_state_flags_t__enumvalues
# Key event types.
# Key event types.

# values for enumeration 'c__EA_cef_key_event_type_t'
c__EA_cef_key_event_type_t__enumvalues = {
    0: 'KEYEVENT_RAWKEYDOWN',
    1: 'KEYEVENT_KEYDOWN',
    2: 'KEYEVENT_KEYUP',
    3: 'KEYEVENT_CHAR',
}
KEYEVENT_RAWKEYDOWN = 0
KEYEVENT_KEYDOWN = 1
KEYEVENT_KEYUP = 2
KEYEVENT_CHAR = 3
c__EA_cef_key_event_type_t = ctypes.c_uint32 # enum
# Key event types.
# Key event types.
cef_key_event_type_t = c__EA_cef_key_event_type_t
cef_key_event_type_t__enumvalues = c__EA_cef_key_event_type_t__enumvalues
# Structure representing keyboard event information.
class struct__cef_key_event_t(Structure):
    pass

struct__cef_key_event_t._pack_ = 1 # source:False
struct__cef_key_event_t._fields_ = [
    ('type', cef_key_event_type_t),
    ('modifiers', ctypes.c_uint32),
    ('windows_key_code', ctypes.c_int32),
    ('native_key_code', ctypes.c_int32),
    ('is_system_key', ctypes.c_int32),
    ('character', ctypes.c_uint16),
    ('unmodified_character', ctypes.c_uint16),
    ('focus_on_editable_field', ctypes.c_int32),
]

# Structure representing keyboard event information.
# Structure representing keyboard event information.
cef_key_event_t = struct__cef_key_event_t
# Focus sources.
# Focus sources.

# values for enumeration 'c__EA_cef_focus_source_t'
c__EA_cef_focus_source_t__enumvalues = {
    0: 'FOCUS_SOURCE_NAVIGATION',
    1: 'FOCUS_SOURCE_SYSTEM',
}
FOCUS_SOURCE_NAVIGATION = 0
FOCUS_SOURCE_SYSTEM = 1
c__EA_cef_focus_source_t = ctypes.c_uint32 # enum
# Focus sources.
# Focus sources.
cef_focus_source_t = c__EA_cef_focus_source_t
cef_focus_source_t__enumvalues = c__EA_cef_focus_source_t__enumvalues
# Navigation types.
# Navigation types.

# values for enumeration 'c__EA_cef_navigation_type_t'
c__EA_cef_navigation_type_t__enumvalues = {
    0: 'NAVIGATION_LINK_CLICKED',
    1: 'NAVIGATION_FORM_SUBMITTED',
    2: 'NAVIGATION_BACK_FORWARD',
    3: 'NAVIGATION_RELOAD',
    4: 'NAVIGATION_FORM_RESUBMITTED',
    5: 'NAVIGATION_OTHER',
}
NAVIGATION_LINK_CLICKED = 0
NAVIGATION_FORM_SUBMITTED = 1
NAVIGATION_BACK_FORWARD = 2
NAVIGATION_RELOAD = 3
NAVIGATION_FORM_RESUBMITTED = 4
NAVIGATION_OTHER = 5
c__EA_cef_navigation_type_t = ctypes.c_uint32 # enum
# Navigation types.
# Navigation types.
cef_navigation_type_t = c__EA_cef_navigation_type_t
cef_navigation_type_t__enumvalues = c__EA_cef_navigation_type_t__enumvalues
# Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and UTF16
# (LE and BE) by default. All other types must be translated to UTF8 before
# being passed to the parser. If a BOM is detected and the correct decoder is
# available then that decoder will be used automatically.
# Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and UTF16
# (LE and BE) by default. All other types must be translated to UTF8 before
# being passed to the parser. If a BOM is detected and the correct decoder is
# available then that decoder will be used automatically.

# values for enumeration 'c__EA_cef_xml_encoding_type_t'
c__EA_cef_xml_encoding_type_t__enumvalues = {
    0: 'XML_ENCODING_NONE',
    1: 'XML_ENCODING_UTF8',
    2: 'XML_ENCODING_UTF16LE',
    3: 'XML_ENCODING_UTF16BE',
    4: 'XML_ENCODING_ASCII',
}
XML_ENCODING_NONE = 0
XML_ENCODING_UTF8 = 1
XML_ENCODING_UTF16LE = 2
XML_ENCODING_UTF16BE = 3
XML_ENCODING_ASCII = 4
c__EA_cef_xml_encoding_type_t = ctypes.c_uint32 # enum
# Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and UTF16
# (LE and BE) by default. All other types must be translated to UTF8 before
# being passed to the parser. If a BOM is detected and the correct decoder is
# available then that decoder will be used automatically.
# Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and UTF16
# (LE and BE) by default. All other types must be translated to UTF8 before
# being passed to the parser. If a BOM is detected and the correct decoder is
# available then that decoder will be used automatically.
cef_xml_encoding_type_t = c__EA_cef_xml_encoding_type_t
cef_xml_encoding_type_t__enumvalues = c__EA_cef_xml_encoding_type_t__enumvalues
# XML node types.
# XML node types.

# values for enumeration 'c__EA_cef_xml_node_type_t'
c__EA_cef_xml_node_type_t__enumvalues = {
    0: 'XML_NODE_UNSUPPORTED',
    1: 'XML_NODE_PROCESSING_INSTRUCTION',
    2: 'XML_NODE_DOCUMENT_TYPE',
    3: 'XML_NODE_ELEMENT_START',
    4: 'XML_NODE_ELEMENT_END',
    5: 'XML_NODE_ATTRIBUTE',
    6: 'XML_NODE_TEXT',
    7: 'XML_NODE_CDATA',
    8: 'XML_NODE_ENTITY_REFERENCE',
    9: 'XML_NODE_WHITESPACE',
    10: 'XML_NODE_COMMENT',
}
XML_NODE_UNSUPPORTED = 0
XML_NODE_PROCESSING_INSTRUCTION = 1
XML_NODE_DOCUMENT_TYPE = 2
XML_NODE_ELEMENT_START = 3
XML_NODE_ELEMENT_END = 4
XML_NODE_ATTRIBUTE = 5
XML_NODE_TEXT = 6
XML_NODE_CDATA = 7
XML_NODE_ENTITY_REFERENCE = 8
XML_NODE_WHITESPACE = 9
XML_NODE_COMMENT = 10
c__EA_cef_xml_node_type_t = ctypes.c_uint32 # enum
# XML node types.
# XML node types.
cef_xml_node_type_t = c__EA_cef_xml_node_type_t
cef_xml_node_type_t__enumvalues = c__EA_cef_xml_node_type_t__enumvalues
# Popup window features.
class struct__cef_popup_features_t(Structure):
    pass

struct__cef_popup_features_t._pack_ = 1 # source:False
struct__cef_popup_features_t._fields_ = [
    ('x', ctypes.c_int32),
    ('xSet', ctypes.c_int32),
    ('y', ctypes.c_int32),
    ('ySet', ctypes.c_int32),
    ('width', ctypes.c_int32),
    ('widthSet', ctypes.c_int32),
    ('height', ctypes.c_int32),
    ('heightSet', ctypes.c_int32),
    ('isPopup', ctypes.c_int32),
]

# Popup window features.
# Popup window features.
cef_popup_features_t = struct__cef_popup_features_t
# DOM document types.
# DOM document types.

# values for enumeration 'c__EA_cef_dom_document_type_t'
c__EA_cef_dom_document_type_t__enumvalues = {
    0: 'DOM_DOCUMENT_TYPE_UNKNOWN',
    1: 'DOM_DOCUMENT_TYPE_HTML',
    2: 'DOM_DOCUMENT_TYPE_XHTML',
    3: 'DOM_DOCUMENT_TYPE_PLUGIN',
}
DOM_DOCUMENT_TYPE_UNKNOWN = 0
DOM_DOCUMENT_TYPE_HTML = 1
DOM_DOCUMENT_TYPE_XHTML = 2
DOM_DOCUMENT_TYPE_PLUGIN = 3
c__EA_cef_dom_document_type_t = ctypes.c_uint32 # enum
# DOM document types.
# DOM document types.
cef_dom_document_type_t = c__EA_cef_dom_document_type_t
cef_dom_document_type_t__enumvalues = c__EA_cef_dom_document_type_t__enumvalues
# DOM event category flags.
# DOM event category flags.

# values for enumeration 'c__EA_cef_dom_event_category_t'
c__EA_cef_dom_event_category_t__enumvalues = {
    0: 'DOM_EVENT_CATEGORY_UNKNOWN',
    1: 'DOM_EVENT_CATEGORY_UI',
    2: 'DOM_EVENT_CATEGORY_MOUSE',
    4: 'DOM_EVENT_CATEGORY_MUTATION',
    8: 'DOM_EVENT_CATEGORY_KEYBOARD',
    16: 'DOM_EVENT_CATEGORY_TEXT',
    32: 'DOM_EVENT_CATEGORY_COMPOSITION',
    64: 'DOM_EVENT_CATEGORY_DRAG',
    128: 'DOM_EVENT_CATEGORY_CLIPBOARD',
    256: 'DOM_EVENT_CATEGORY_MESSAGE',
    512: 'DOM_EVENT_CATEGORY_WHEEL',
    1024: 'DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED',
    2048: 'DOM_EVENT_CATEGORY_OVERFLOW',
    4096: 'DOM_EVENT_CATEGORY_PAGE_TRANSITION',
    8192: 'DOM_EVENT_CATEGORY_POPSTATE',
    16384: 'DOM_EVENT_CATEGORY_PROGRESS',
    32768: 'DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS',
}
DOM_EVENT_CATEGORY_UNKNOWN = 0
DOM_EVENT_CATEGORY_UI = 1
DOM_EVENT_CATEGORY_MOUSE = 2
DOM_EVENT_CATEGORY_MUTATION = 4
DOM_EVENT_CATEGORY_KEYBOARD = 8
DOM_EVENT_CATEGORY_TEXT = 16
DOM_EVENT_CATEGORY_COMPOSITION = 32
DOM_EVENT_CATEGORY_DRAG = 64
DOM_EVENT_CATEGORY_CLIPBOARD = 128
DOM_EVENT_CATEGORY_MESSAGE = 256
DOM_EVENT_CATEGORY_WHEEL = 512
DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED = 1024
DOM_EVENT_CATEGORY_OVERFLOW = 2048
DOM_EVENT_CATEGORY_PAGE_TRANSITION = 4096
DOM_EVENT_CATEGORY_POPSTATE = 8192
DOM_EVENT_CATEGORY_PROGRESS = 16384
DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS = 32768
c__EA_cef_dom_event_category_t = ctypes.c_uint32 # enum
# DOM event category flags.
# DOM event category flags.
cef_dom_event_category_t = c__EA_cef_dom_event_category_t
cef_dom_event_category_t__enumvalues = c__EA_cef_dom_event_category_t__enumvalues
# DOM event processing phases.
# DOM event processing phases.

# values for enumeration 'c__EA_cef_dom_event_phase_t'
c__EA_cef_dom_event_phase_t__enumvalues = {
    0: 'DOM_EVENT_PHASE_UNKNOWN',
    1: 'DOM_EVENT_PHASE_CAPTURING',
    2: 'DOM_EVENT_PHASE_AT_TARGET',
    3: 'DOM_EVENT_PHASE_BUBBLING',
}
DOM_EVENT_PHASE_UNKNOWN = 0
DOM_EVENT_PHASE_CAPTURING = 1
DOM_EVENT_PHASE_AT_TARGET = 2
DOM_EVENT_PHASE_BUBBLING = 3
c__EA_cef_dom_event_phase_t = ctypes.c_uint32 # enum
# DOM event processing phases.
# DOM event processing phases.
cef_dom_event_phase_t = c__EA_cef_dom_event_phase_t
cef_dom_event_phase_t__enumvalues = c__EA_cef_dom_event_phase_t__enumvalues
# DOM node types.
# DOM node types.

# values for enumeration 'c__EA_cef_dom_node_type_t'
c__EA_cef_dom_node_type_t__enumvalues = {
    0: 'DOM_NODE_TYPE_UNSUPPORTED',
    1: 'DOM_NODE_TYPE_ELEMENT',
    2: 'DOM_NODE_TYPE_ATTRIBUTE',
    3: 'DOM_NODE_TYPE_TEXT',
    4: 'DOM_NODE_TYPE_CDATA_SECTION',
    5: 'DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS',
    6: 'DOM_NODE_TYPE_COMMENT',
    7: 'DOM_NODE_TYPE_DOCUMENT',
    8: 'DOM_NODE_TYPE_DOCUMENT_TYPE',
    9: 'DOM_NODE_TYPE_DOCUMENT_FRAGMENT',
}
DOM_NODE_TYPE_UNSUPPORTED = 0
DOM_NODE_TYPE_ELEMENT = 1
DOM_NODE_TYPE_ATTRIBUTE = 2
DOM_NODE_TYPE_TEXT = 3
DOM_NODE_TYPE_CDATA_SECTION = 4
DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS = 5
DOM_NODE_TYPE_COMMENT = 6
DOM_NODE_TYPE_DOCUMENT = 7
DOM_NODE_TYPE_DOCUMENT_TYPE = 8
DOM_NODE_TYPE_DOCUMENT_FRAGMENT = 9
c__EA_cef_dom_node_type_t = ctypes.c_uint32 # enum
# DOM node types.
# DOM node types.
cef_dom_node_type_t = c__EA_cef_dom_node_type_t
cef_dom_node_type_t__enumvalues = c__EA_cef_dom_node_type_t__enumvalues
# DOM form control types. Should be kept in sync with Chromium's
# blink::mojom::FormControlType type.
# DOM form control types. Should be kept in sync with Chromium's
# blink::mojom::FormControlType type.

# values for enumeration 'c__EA_cef_dom_form_control_type_t'
c__EA_cef_dom_form_control_type_t__enumvalues = {
    0: 'DOM_FORM_CONTROL_TYPE_UNSUPPORTED',
    1: 'DOM_FORM_CONTROL_TYPE_BUTTON_BUTTON',
    2: 'DOM_FORM_CONTROL_TYPE_BUTTON_SUBMIT',
    3: 'DOM_FORM_CONTROL_TYPE_BUTTON_RESET',
    4: 'DOM_FORM_CONTROL_TYPE_BUTTON_POPOVER',
    5: 'DOM_FORM_CONTROL_TYPE_FIELDSET',
    6: 'DOM_FORM_CONTROL_TYPE_INPUT_BUTTON',
    7: 'DOM_FORM_CONTROL_TYPE_INPUT_CHECKBOX',
    8: 'DOM_FORM_CONTROL_TYPE_INPUT_COLOR',
    9: 'DOM_FORM_CONTROL_TYPE_INPUT_DATE',
    10: 'DOM_FORM_CONTROL_TYPE_INPUT_DATETIME_LOCAL',
    11: 'DOM_FORM_CONTROL_TYPE_INPUT_EMAIL',
    12: 'DOM_FORM_CONTROL_TYPE_INPUT_FILE',
    13: 'DOM_FORM_CONTROL_TYPE_INPUT_HIDDEN',
    14: 'DOM_FORM_CONTROL_TYPE_INPUT_IMAGE',
    15: 'DOM_FORM_CONTROL_TYPE_INPUT_MONTH',
    16: 'DOM_FORM_CONTROL_TYPE_INPUT_NUMBER',
    17: 'DOM_FORM_CONTROL_TYPE_INPUT_PASSWORD',
    18: 'DOM_FORM_CONTROL_TYPE_INPUT_RADIO',
    19: 'DOM_FORM_CONTROL_TYPE_INPUT_RANGE',
    20: 'DOM_FORM_CONTROL_TYPE_INPUT_RESET',
    21: 'DOM_FORM_CONTROL_TYPE_INPUT_SEARCH',
    22: 'DOM_FORM_CONTROL_TYPE_INPUT_SUBMIT',
    23: 'DOM_FORM_CONTROL_TYPE_INPUT_TELEPHONE',
    24: 'DOM_FORM_CONTROL_TYPE_INPUT_TEXT',
    25: 'DOM_FORM_CONTROL_TYPE_INPUT_TIME',
    26: 'DOM_FORM_CONTROL_TYPE_INPUT_URL',
    27: 'DOM_FORM_CONTROL_TYPE_INPUT_WEEK',
    28: 'DOM_FORM_CONTROL_TYPE_OUTPUT',
    29: 'DOM_FORM_CONTROL_TYPE_SELECT_ONE',
    30: 'DOM_FORM_CONTROL_TYPE_SELECT_MULTIPLE',
    31: 'DOM_FORM_CONTROL_TYPE_TEXT_AREA',
}
DOM_FORM_CONTROL_TYPE_UNSUPPORTED = 0
DOM_FORM_CONTROL_TYPE_BUTTON_BUTTON = 1
DOM_FORM_CONTROL_TYPE_BUTTON_SUBMIT = 2
DOM_FORM_CONTROL_TYPE_BUTTON_RESET = 3
DOM_FORM_CONTROL_TYPE_BUTTON_POPOVER = 4
DOM_FORM_CONTROL_TYPE_FIELDSET = 5
DOM_FORM_CONTROL_TYPE_INPUT_BUTTON = 6
DOM_FORM_CONTROL_TYPE_INPUT_CHECKBOX = 7
DOM_FORM_CONTROL_TYPE_INPUT_COLOR = 8
DOM_FORM_CONTROL_TYPE_INPUT_DATE = 9
DOM_FORM_CONTROL_TYPE_INPUT_DATETIME_LOCAL = 10
DOM_FORM_CONTROL_TYPE_INPUT_EMAIL = 11
DOM_FORM_CONTROL_TYPE_INPUT_FILE = 12
DOM_FORM_CONTROL_TYPE_INPUT_HIDDEN = 13
DOM_FORM_CONTROL_TYPE_INPUT_IMAGE = 14
DOM_FORM_CONTROL_TYPE_INPUT_MONTH = 15
DOM_FORM_CONTROL_TYPE_INPUT_NUMBER = 16
DOM_FORM_CONTROL_TYPE_INPUT_PASSWORD = 17
DOM_FORM_CONTROL_TYPE_INPUT_RADIO = 18
DOM_FORM_CONTROL_TYPE_INPUT_RANGE = 19
DOM_FORM_CONTROL_TYPE_INPUT_RESET = 20
DOM_FORM_CONTROL_TYPE_INPUT_SEARCH = 21
DOM_FORM_CONTROL_TYPE_INPUT_SUBMIT = 22
DOM_FORM_CONTROL_TYPE_INPUT_TELEPHONE = 23
DOM_FORM_CONTROL_TYPE_INPUT_TEXT = 24
DOM_FORM_CONTROL_TYPE_INPUT_TIME = 25
DOM_FORM_CONTROL_TYPE_INPUT_URL = 26
DOM_FORM_CONTROL_TYPE_INPUT_WEEK = 27
DOM_FORM_CONTROL_TYPE_OUTPUT = 28
DOM_FORM_CONTROL_TYPE_SELECT_ONE = 29
DOM_FORM_CONTROL_TYPE_SELECT_MULTIPLE = 30
DOM_FORM_CONTROL_TYPE_TEXT_AREA = 31
c__EA_cef_dom_form_control_type_t = ctypes.c_uint32 # enum
# DOM form control types. Should be kept in sync with Chromium's
# blink::mojom::FormControlType type.
# DOM form control types. Should be kept in sync with Chromium's
# blink::mojom::FormControlType type.
cef_dom_form_control_type_t = c__EA_cef_dom_form_control_type_t
cef_dom_form_control_type_t__enumvalues = c__EA_cef_dom_form_control_type_t__enumvalues
# Supported file dialog modes.
# Supported file dialog modes.

# values for enumeration 'c__EA_cef_file_dialog_mode_t'
c__EA_cef_file_dialog_mode_t__enumvalues = {
    0: 'FILE_DIALOG_OPEN',
    1: 'FILE_DIALOG_OPEN_MULTIPLE',
    2: 'FILE_DIALOG_OPEN_FOLDER',
    3: 'FILE_DIALOG_SAVE',
}
FILE_DIALOG_OPEN = 0
FILE_DIALOG_OPEN_MULTIPLE = 1
FILE_DIALOG_OPEN_FOLDER = 2
FILE_DIALOG_SAVE = 3
c__EA_cef_file_dialog_mode_t = ctypes.c_uint32 # enum
# Supported file dialog modes.
# Supported file dialog modes.
cef_file_dialog_mode_t = c__EA_cef_file_dialog_mode_t
cef_file_dialog_mode_t__enumvalues = c__EA_cef_file_dialog_mode_t__enumvalues
# Print job color mode values.
# Print job color mode values.

# values for enumeration 'c__EA_cef_color_model_t'
c__EA_cef_color_model_t__enumvalues = {
    0: 'COLOR_MODEL_UNKNOWN',
    1: 'COLOR_MODEL_GRAY',
    2: 'COLOR_MODEL_COLOR',
    3: 'COLOR_MODEL_CMYK',
    4: 'COLOR_MODEL_CMY',
    5: 'COLOR_MODEL_KCMY',
    6: 'COLOR_MODEL_CMY_K',
    7: 'COLOR_MODEL_BLACK',
    8: 'COLOR_MODEL_GRAYSCALE',
    9: 'COLOR_MODEL_RGB',
    10: 'COLOR_MODEL_RGB16',
    11: 'COLOR_MODEL_RGBA',
    12: 'COLOR_MODEL_COLORMODE_COLOR',
    13: 'COLOR_MODEL_COLORMODE_MONOCHROME',
    14: 'COLOR_MODEL_HP_COLOR_COLOR',
    15: 'COLOR_MODEL_HP_COLOR_BLACK',
    16: 'COLOR_MODEL_PRINTOUTMODE_NORMAL',
    17: 'COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY',
    18: 'COLOR_MODEL_PROCESSCOLORMODEL_CMYK',
    19: 'COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE',
    20: 'COLOR_MODEL_PROCESSCOLORMODEL_RGB',
}
COLOR_MODEL_UNKNOWN = 0
COLOR_MODEL_GRAY = 1
COLOR_MODEL_COLOR = 2
COLOR_MODEL_CMYK = 3
COLOR_MODEL_CMY = 4
COLOR_MODEL_KCMY = 5
COLOR_MODEL_CMY_K = 6
COLOR_MODEL_BLACK = 7
COLOR_MODEL_GRAYSCALE = 8
COLOR_MODEL_RGB = 9
COLOR_MODEL_RGB16 = 10
COLOR_MODEL_RGBA = 11
COLOR_MODEL_COLORMODE_COLOR = 12
COLOR_MODEL_COLORMODE_MONOCHROME = 13
COLOR_MODEL_HP_COLOR_COLOR = 14
COLOR_MODEL_HP_COLOR_BLACK = 15
COLOR_MODEL_PRINTOUTMODE_NORMAL = 16
COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY = 17
COLOR_MODEL_PROCESSCOLORMODEL_CMYK = 18
COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE = 19
COLOR_MODEL_PROCESSCOLORMODEL_RGB = 20
c__EA_cef_color_model_t = ctypes.c_uint32 # enum
# Print job color mode values.
# Print job color mode values.
cef_color_model_t = c__EA_cef_color_model_t
cef_color_model_t__enumvalues = c__EA_cef_color_model_t__enumvalues
# Print job duplex mode values.
# Print job duplex mode values.

# values for enumeration 'c__EA_cef_duplex_mode_t'
c__EA_cef_duplex_mode_t__enumvalues = {
    -1: 'DUPLEX_MODE_UNKNOWN',
    0: 'DUPLEX_MODE_SIMPLEX',
    1: 'DUPLEX_MODE_LONG_EDGE',
    2: 'DUPLEX_MODE_SHORT_EDGE',
}
DUPLEX_MODE_UNKNOWN = -1
DUPLEX_MODE_SIMPLEX = 0
DUPLEX_MODE_LONG_EDGE = 1
DUPLEX_MODE_SHORT_EDGE = 2
c__EA_cef_duplex_mode_t = ctypes.c_int32 # enum
# Print job duplex mode values.
# Print job duplex mode values.
cef_duplex_mode_t = c__EA_cef_duplex_mode_t
cef_duplex_mode_t__enumvalues = c__EA_cef_duplex_mode_t__enumvalues
# Cursor type values.
# Cursor type values.

# values for enumeration 'c__EA_cef_cursor_type_t'
c__EA_cef_cursor_type_t__enumvalues = {
    0: 'CT_POINTER',
    1: 'CT_CROSS',
    2: 'CT_HAND',
    3: 'CT_IBEAM',
    4: 'CT_WAIT',
    5: 'CT_HELP',
    6: 'CT_EASTRESIZE',
    7: 'CT_NORTHRESIZE',
    8: 'CT_NORTHEASTRESIZE',
    9: 'CT_NORTHWESTRESIZE',
    10: 'CT_SOUTHRESIZE',
    11: 'CT_SOUTHEASTRESIZE',
    12: 'CT_SOUTHWESTRESIZE',
    13: 'CT_WESTRESIZE',
    14: 'CT_NORTHSOUTHRESIZE',
    15: 'CT_EASTWESTRESIZE',
    16: 'CT_NORTHEASTSOUTHWESTRESIZE',
    17: 'CT_NORTHWESTSOUTHEASTRESIZE',
    18: 'CT_COLUMNRESIZE',
    19: 'CT_ROWRESIZE',
    20: 'CT_MIDDLEPANNING',
    21: 'CT_EASTPANNING',
    22: 'CT_NORTHPANNING',
    23: 'CT_NORTHEASTPANNING',
    24: 'CT_NORTHWESTPANNING',
    25: 'CT_SOUTHPANNING',
    26: 'CT_SOUTHEASTPANNING',
    27: 'CT_SOUTHWESTPANNING',
    28: 'CT_WESTPANNING',
    29: 'CT_MOVE',
    30: 'CT_VERTICALTEXT',
    31: 'CT_CELL',
    32: 'CT_CONTEXTMENU',
    33: 'CT_ALIAS',
    34: 'CT_PROGRESS',
    35: 'CT_NODROP',
    36: 'CT_COPY',
    37: 'CT_NONE',
    38: 'CT_NOTALLOWED',
    39: 'CT_ZOOMIN',
    40: 'CT_ZOOMOUT',
    41: 'CT_GRAB',
    42: 'CT_GRABBING',
    43: 'CT_MIDDLE_PANNING_VERTICAL',
    44: 'CT_MIDDLE_PANNING_HORIZONTAL',
    45: 'CT_CUSTOM',
    46: 'CT_DND_NONE',
    47: 'CT_DND_MOVE',
    48: 'CT_DND_COPY',
    49: 'CT_DND_LINK',
}
CT_POINTER = 0
CT_CROSS = 1
CT_HAND = 2
CT_IBEAM = 3
CT_WAIT = 4
CT_HELP = 5
CT_EASTRESIZE = 6
CT_NORTHRESIZE = 7
CT_NORTHEASTRESIZE = 8
CT_NORTHWESTRESIZE = 9
CT_SOUTHRESIZE = 10
CT_SOUTHEASTRESIZE = 11
CT_SOUTHWESTRESIZE = 12
CT_WESTRESIZE = 13
CT_NORTHSOUTHRESIZE = 14
CT_EASTWESTRESIZE = 15
CT_NORTHEASTSOUTHWESTRESIZE = 16
CT_NORTHWESTSOUTHEASTRESIZE = 17
CT_COLUMNRESIZE = 18
CT_ROWRESIZE = 19
CT_MIDDLEPANNING = 20
CT_EASTPANNING = 21
CT_NORTHPANNING = 22
CT_NORTHEASTPANNING = 23
CT_NORTHWESTPANNING = 24
CT_SOUTHPANNING = 25
CT_SOUTHEASTPANNING = 26
CT_SOUTHWESTPANNING = 27
CT_WESTPANNING = 28
CT_MOVE = 29
CT_VERTICALTEXT = 30
CT_CELL = 31
CT_CONTEXTMENU = 32
CT_ALIAS = 33
CT_PROGRESS = 34
CT_NODROP = 35
CT_COPY = 36
CT_NONE = 37
CT_NOTALLOWED = 38
CT_ZOOMIN = 39
CT_ZOOMOUT = 40
CT_GRAB = 41
CT_GRABBING = 42
CT_MIDDLE_PANNING_VERTICAL = 43
CT_MIDDLE_PANNING_HORIZONTAL = 44
CT_CUSTOM = 45
CT_DND_NONE = 46
CT_DND_MOVE = 47
CT_DND_COPY = 48
CT_DND_LINK = 49
c__EA_cef_cursor_type_t = ctypes.c_uint32 # enum
# Cursor type values.
# Cursor type values.
cef_cursor_type_t = c__EA_cef_cursor_type_t
cef_cursor_type_t__enumvalues = c__EA_cef_cursor_type_t__enumvalues
# Structure representing cursor information. |buffer| will be
# |size.width|*|size.height|*4 bytes in size and represents a BGRA image with an
# upper-left origin.
class struct__cef_cursor_info_t(Structure):
    pass

struct__cef_cursor_info_t._pack_ = 1 # source:False
struct__cef_cursor_info_t._fields_ = [
    ('hotspot', cef_point_t),
    ('image_scale_factor', ctypes.c_float),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('buffer', ctypes.POINTER(None)),
    ('size', cef_size_t),
]

# Structure representing cursor information. |buffer| will be
# |size.width|*|size.height|*4 bytes in size and represents a BGRA image with an
# upper-left origin.
# Structure representing cursor information. |buffer| will be
# |size.width|*|size.height|*4 bytes in size and represents a BGRA image with an
# upper-left origin.
cef_cursor_info_t = struct__cef_cursor_info_t
# URI unescape rules passed to CefURIDecode().
# URI unescape rules passed to CefURIDecode().

# values for enumeration 'c__EA_cef_uri_unescape_rule_t'
c__EA_cef_uri_unescape_rule_t__enumvalues = {
    0: 'UU_NONE',
    1: 'UU_NORMAL',
    2: 'UU_SPACES',
    4: 'UU_PATH_SEPARATORS',
    8: 'UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS',
    16: 'UU_REPLACE_PLUS_WITH_SPACE',
}
UU_NONE = 0
UU_NORMAL = 1
UU_SPACES = 2
UU_PATH_SEPARATORS = 4
UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS = 8
UU_REPLACE_PLUS_WITH_SPACE = 16
c__EA_cef_uri_unescape_rule_t = ctypes.c_uint32 # enum
# URI unescape rules passed to CefURIDecode().
# URI unescape rules passed to CefURIDecode().
cef_uri_unescape_rule_t = c__EA_cef_uri_unescape_rule_t
cef_uri_unescape_rule_t__enumvalues = c__EA_cef_uri_unescape_rule_t__enumvalues
# Options that can be passed to CefParseJSON.
# Options that can be passed to CefParseJSON.

# values for enumeration 'c__EA_cef_json_parser_options_t'
c__EA_cef_json_parser_options_t__enumvalues = {
    0: 'JSON_PARSER_RFC',
    1: 'JSON_PARSER_ALLOW_TRAILING_COMMAS',
}
JSON_PARSER_RFC = 0
JSON_PARSER_ALLOW_TRAILING_COMMAS = 1
c__EA_cef_json_parser_options_t = ctypes.c_uint32 # enum
# Options that can be passed to CefParseJSON.
# Options that can be passed to CefParseJSON.
cef_json_parser_options_t = c__EA_cef_json_parser_options_t
cef_json_parser_options_t__enumvalues = c__EA_cef_json_parser_options_t__enumvalues
# Options that can be passed to CefWriteJSON.
# Options that can be passed to CefWriteJSON.

# values for enumeration 'c__EA_cef_json_writer_options_t'
c__EA_cef_json_writer_options_t__enumvalues = {
    0: 'JSON_WRITER_DEFAULT',
    1: 'JSON_WRITER_OMIT_BINARY_VALUES',
    2: 'JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION',
    4: 'JSON_WRITER_PRETTY_PRINT',
}
JSON_WRITER_DEFAULT = 0
JSON_WRITER_OMIT_BINARY_VALUES = 1
JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION = 2
JSON_WRITER_PRETTY_PRINT = 4
c__EA_cef_json_writer_options_t = ctypes.c_uint32 # enum
# Options that can be passed to CefWriteJSON.
# Options that can be passed to CefWriteJSON.
cef_json_writer_options_t = c__EA_cef_json_writer_options_t
cef_json_writer_options_t__enumvalues = c__EA_cef_json_writer_options_t__enumvalues
# Margin type for PDF printing.
# Margin type for PDF printing.

# values for enumeration 'c__EA_cef_pdf_print_margin_type_t'
c__EA_cef_pdf_print_margin_type_t__enumvalues = {
    0: 'PDF_PRINT_MARGIN_DEFAULT',
    1: 'PDF_PRINT_MARGIN_NONE',
    2: 'PDF_PRINT_MARGIN_CUSTOM',
}
PDF_PRINT_MARGIN_DEFAULT = 0
PDF_PRINT_MARGIN_NONE = 1
PDF_PRINT_MARGIN_CUSTOM = 2
c__EA_cef_pdf_print_margin_type_t = ctypes.c_uint32 # enum
# Margin type for PDF printing.
# Margin type for PDF printing.
cef_pdf_print_margin_type_t = c__EA_cef_pdf_print_margin_type_t
cef_pdf_print_margin_type_t__enumvalues = c__EA_cef_pdf_print_margin_type_t__enumvalues
# Structure representing PDF print settings. These values match the parameters
# supported by the DevTools Page.printToPDF function. See
# https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF
class struct__cef_pdf_print_settings_t(Structure):
    pass

struct__cef_pdf_print_settings_t._pack_ = 1 # source:False
struct__cef_pdf_print_settings_t._fields_ = [
    ('landscape', ctypes.c_int32),
    ('print_background', ctypes.c_int32),
    ('scale', ctypes.c_double),
    ('paper_width', ctypes.c_double),
    ('paper_height', ctypes.c_double),
    ('prefer_css_page_size', ctypes.c_int32),
    ('margin_type', cef_pdf_print_margin_type_t),
    ('margin_top', ctypes.c_double),
    ('margin_right', ctypes.c_double),
    ('margin_bottom', ctypes.c_double),
    ('margin_left', ctypes.c_double),
    ('page_ranges', cef_string_t),
    ('display_header_footer', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('header_template', cef_string_t),
    ('footer_template', cef_string_t),
    ('generate_tagged_pdf', ctypes.c_int32),
    ('generate_document_outline', ctypes.c_int32),
]

# Structure representing PDF print settings. These values match the parameters
# supported by the DevTools Page.printToPDF function. See
# https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF
# Structure representing PDF print settings. These values match the parameters
# supported by the DevTools Page.printToPDF function. See
# https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF
cef_pdf_print_settings_t = struct__cef_pdf_print_settings_t
# Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for
# density independent resources such as string, html/js files or an image that
# can be used for any scale factors (such as wallpapers).
# Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for
# density independent resources such as string, html/js files or an image that
# can be used for any scale factors (such as wallpapers).

# values for enumeration 'c__EA_cef_scale_factor_t'
c__EA_cef_scale_factor_t__enumvalues = {
    0: 'SCALE_FACTOR_NONE',
    1: 'SCALE_FACTOR_100P',
    2: 'SCALE_FACTOR_125P',
    3: 'SCALE_FACTOR_133P',
    4: 'SCALE_FACTOR_140P',
    5: 'SCALE_FACTOR_150P',
    6: 'SCALE_FACTOR_180P',
    7: 'SCALE_FACTOR_200P',
    8: 'SCALE_FACTOR_250P',
    9: 'SCALE_FACTOR_300P',
}
SCALE_FACTOR_NONE = 0
SCALE_FACTOR_100P = 1
SCALE_FACTOR_125P = 2
SCALE_FACTOR_133P = 3
SCALE_FACTOR_140P = 4
SCALE_FACTOR_150P = 5
SCALE_FACTOR_180P = 6
SCALE_FACTOR_200P = 7
SCALE_FACTOR_250P = 8
SCALE_FACTOR_300P = 9
c__EA_cef_scale_factor_t = ctypes.c_uint32 # enum
# Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for
# density independent resources such as string, html/js files or an image that
# can be used for any scale factors (such as wallpapers).
# Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for
# density independent resources such as string, html/js files or an image that
# can be used for any scale factors (such as wallpapers).
cef_scale_factor_t = c__EA_cef_scale_factor_t
cef_scale_factor_t__enumvalues = c__EA_cef_scale_factor_t__enumvalues
# Policy for how the Referrer HTTP header value will be sent during navigation.
# If the `--no-referrers` command-line flag is specified then the policy value
# will be ignored and the Referrer value will never be sent. Must be kept
# synchronized with net::URLRequest::ReferrerPolicy from Chromium.
# Policy for how the Referrer HTTP header value will be sent during navigation.
# If the `--no-referrers` command-line flag is specified then the policy value
# will be ignored and the Referrer value will never be sent. Must be kept
# synchronized with net::URLRequest::ReferrerPolicy from Chromium.

# values for enumeration 'c__EA_cef_referrer_policy_t'
c__EA_cef_referrer_policy_t__enumvalues = {
    0: 'REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE',
    0: 'REFERRER_POLICY_DEFAULT',
    1: 'REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN',
    2: 'REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN',
    3: 'REFERRER_POLICY_NEVER_CLEAR_REFERRER',
    4: 'REFERRER_POLICY_ORIGIN',
    5: 'REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN',
    6: 'REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE',
    7: 'REFERRER_POLICY_NO_REFERRER',
    7: 'REFERRER_POLICY_LAST_VALUE',
}
REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE = 0
REFERRER_POLICY_DEFAULT = 0
REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN = 1
REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN = 2
REFERRER_POLICY_NEVER_CLEAR_REFERRER = 3
REFERRER_POLICY_ORIGIN = 4
REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN = 5
REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE = 6
REFERRER_POLICY_NO_REFERRER = 7
REFERRER_POLICY_LAST_VALUE = 7
c__EA_cef_referrer_policy_t = ctypes.c_uint32 # enum
# Policy for how the Referrer HTTP header value will be sent during navigation.
# If the `--no-referrers` command-line flag is specified then the policy value
# will be ignored and the Referrer value will never be sent. Must be kept
# synchronized with net::URLRequest::ReferrerPolicy from Chromium.
# Policy for how the Referrer HTTP header value will be sent during navigation.
# If the `--no-referrers` command-line flag is specified then the policy value
# will be ignored and the Referrer value will never be sent. Must be kept
# synchronized with net::URLRequest::ReferrerPolicy from Chromium.
cef_referrer_policy_t = c__EA_cef_referrer_policy_t
cef_referrer_policy_t__enumvalues = c__EA_cef_referrer_policy_t__enumvalues
# Return values for CefResponseFilter::Filter().
# Return values for CefResponseFilter::Filter().

# values for enumeration 'c__EA_cef_response_filter_status_t'
c__EA_cef_response_filter_status_t__enumvalues = {
    0: 'RESPONSE_FILTER_NEED_MORE_DATA',
    1: 'RESPONSE_FILTER_DONE',
    2: 'RESPONSE_FILTER_ERROR',
}
RESPONSE_FILTER_NEED_MORE_DATA = 0
RESPONSE_FILTER_DONE = 1
RESPONSE_FILTER_ERROR = 2
c__EA_cef_response_filter_status_t = ctypes.c_uint32 # enum
# Return values for CefResponseFilter::Filter().
# Return values for CefResponseFilter::Filter().
cef_response_filter_status_t = c__EA_cef_response_filter_status_t
cef_response_filter_status_t__enumvalues = c__EA_cef_response_filter_status_t__enumvalues
# Describes how to interpret the alpha component of a pixel.
# Describes how to interpret the alpha component of a pixel.

# values for enumeration 'c__EA_cef_alpha_type_t'
c__EA_cef_alpha_type_t__enumvalues = {
    0: 'CEF_ALPHA_TYPE_OPAQUE',
    1: 'CEF_ALPHA_TYPE_PREMULTIPLIED',
    2: 'CEF_ALPHA_TYPE_POSTMULTIPLIED',
}
CEF_ALPHA_TYPE_OPAQUE = 0
CEF_ALPHA_TYPE_PREMULTIPLIED = 1
CEF_ALPHA_TYPE_POSTMULTIPLIED = 2
c__EA_cef_alpha_type_t = ctypes.c_uint32 # enum
# Describes how to interpret the alpha component of a pixel.
# Describes how to interpret the alpha component of a pixel.
cef_alpha_type_t = c__EA_cef_alpha_type_t
cef_alpha_type_t__enumvalues = c__EA_cef_alpha_type_t__enumvalues
# Text style types. Should be kepy in sync with gfx::TextStyle.
# Text style types. Should be kepy in sync with gfx::TextStyle.

# values for enumeration 'c__EA_cef_text_style_t'
c__EA_cef_text_style_t__enumvalues = {
    0: 'CEF_TEXT_STYLE_BOLD',
    1: 'CEF_TEXT_STYLE_ITALIC',
    2: 'CEF_TEXT_STYLE_STRIKE',
    3: 'CEF_TEXT_STYLE_DIAGONAL_STRIKE',
    4: 'CEF_TEXT_STYLE_UNDERLINE',
}
CEF_TEXT_STYLE_BOLD = 0
CEF_TEXT_STYLE_ITALIC = 1
CEF_TEXT_STYLE_STRIKE = 2
CEF_TEXT_STYLE_DIAGONAL_STRIKE = 3
CEF_TEXT_STYLE_UNDERLINE = 4
c__EA_cef_text_style_t = ctypes.c_uint32 # enum
# Text style types. Should be kepy in sync with gfx::TextStyle.
# Text style types. Should be kepy in sync with gfx::TextStyle.
cef_text_style_t = c__EA_cef_text_style_t
cef_text_style_t__enumvalues = c__EA_cef_text_style_t__enumvalues
# Specifies where along the axis the CefBoxLayout child views should be laid
# out. Should be kept in sync with Chromium's views::LayoutAlignment type.
# Specifies where along the axis the CefBoxLayout child views should be laid
# out. Should be kept in sync with Chromium's views::LayoutAlignment type.

# values for enumeration 'c__EA_cef_axis_alignment_t'
c__EA_cef_axis_alignment_t__enumvalues = {
    0: 'CEF_AXIS_ALIGNMENT_START',
    1: 'CEF_AXIS_ALIGNMENT_CENTER',
    2: 'CEF_AXIS_ALIGNMENT_END',
    3: 'CEF_AXIS_ALIGNMENT_STRETCH',
}
CEF_AXIS_ALIGNMENT_START = 0
CEF_AXIS_ALIGNMENT_CENTER = 1
CEF_AXIS_ALIGNMENT_END = 2
CEF_AXIS_ALIGNMENT_STRETCH = 3
c__EA_cef_axis_alignment_t = ctypes.c_uint32 # enum
# Specifies where along the axis the CefBoxLayout child views should be laid
# out. Should be kept in sync with Chromium's views::LayoutAlignment type.
# Specifies where along the axis the CefBoxLayout child views should be laid
# out. Should be kept in sync with Chromium's views::LayoutAlignment type.
cef_axis_alignment_t = c__EA_cef_axis_alignment_t
cef_axis_alignment_t__enumvalues = c__EA_cef_axis_alignment_t__enumvalues
# Settings used when initializing a CefBoxLayout.
class struct__cef_box_layout_settings_t(Structure):
    pass

struct__cef_box_layout_settings_t._pack_ = 1 # source:False
struct__cef_box_layout_settings_t._fields_ = [
    ('horizontal', ctypes.c_int32),
    ('inside_border_horizontal_spacing', ctypes.c_int32),
    ('inside_border_vertical_spacing', ctypes.c_int32),
    ('inside_border_insets', cef_insets_t),
    ('between_child_spacing', ctypes.c_int32),
    ('main_axis_alignment', cef_axis_alignment_t),
    ('cross_axis_alignment', cef_axis_alignment_t),
    ('minimum_cross_axis_size', ctypes.c_int32),
    ('default_flex', ctypes.c_int32),
]

# Settings used when initializing a CefBoxLayout.
# Settings used when initializing a CefBoxLayout.
cef_box_layout_settings_t = struct__cef_box_layout_settings_t
# Specifies the button display state.
# Specifies the button display state.

# values for enumeration 'c__EA_cef_button_state_t'
c__EA_cef_button_state_t__enumvalues = {
    0: 'CEF_BUTTON_STATE_NORMAL',
    1: 'CEF_BUTTON_STATE_HOVERED',
    2: 'CEF_BUTTON_STATE_PRESSED',
    3: 'CEF_BUTTON_STATE_DISABLED',
}
CEF_BUTTON_STATE_NORMAL = 0
CEF_BUTTON_STATE_HOVERED = 1
CEF_BUTTON_STATE_PRESSED = 2
CEF_BUTTON_STATE_DISABLED = 3
c__EA_cef_button_state_t = ctypes.c_uint32 # enum
# Specifies the button display state.
# Specifies the button display state.
cef_button_state_t = c__EA_cef_button_state_t
cef_button_state_t__enumvalues = c__EA_cef_button_state_t__enumvalues
# Specifies the horizontal text alignment mode.
# Specifies the horizontal text alignment mode.

# values for enumeration 'c__EA_cef_horizontal_alignment_t'
c__EA_cef_horizontal_alignment_t__enumvalues = {
    0: 'CEF_HORIZONTAL_ALIGNMENT_LEFT',
    1: 'CEF_HORIZONTAL_ALIGNMENT_CENTER',
    2: 'CEF_HORIZONTAL_ALIGNMENT_RIGHT',
}
CEF_HORIZONTAL_ALIGNMENT_LEFT = 0
CEF_HORIZONTAL_ALIGNMENT_CENTER = 1
CEF_HORIZONTAL_ALIGNMENT_RIGHT = 2
c__EA_cef_horizontal_alignment_t = ctypes.c_uint32 # enum
# Specifies the horizontal text alignment mode.
# Specifies the horizontal text alignment mode.
cef_horizontal_alignment_t = c__EA_cef_horizontal_alignment_t
cef_horizontal_alignment_t__enumvalues = c__EA_cef_horizontal_alignment_t__enumvalues
# Specifies how a menu will be anchored for non-RTL languages. The opposite
# position will be used for RTL languages.
# Specifies how a menu will be anchored for non-RTL languages. The opposite
# position will be used for RTL languages.

# values for enumeration 'c__EA_cef_menu_anchor_position_t'
c__EA_cef_menu_anchor_position_t__enumvalues = {
    0: 'CEF_MENU_ANCHOR_TOPLEFT',
    1: 'CEF_MENU_ANCHOR_TOPRIGHT',
    2: 'CEF_MENU_ANCHOR_BOTTOMCENTER',
}
CEF_MENU_ANCHOR_TOPLEFT = 0
CEF_MENU_ANCHOR_TOPRIGHT = 1
CEF_MENU_ANCHOR_BOTTOMCENTER = 2
c__EA_cef_menu_anchor_position_t = ctypes.c_uint32 # enum
# Specifies how a menu will be anchored for non-RTL languages. The opposite
# position will be used for RTL languages.
# Specifies how a menu will be anchored for non-RTL languages. The opposite
# position will be used for RTL languages.
cef_menu_anchor_position_t = c__EA_cef_menu_anchor_position_t
cef_menu_anchor_position_t__enumvalues = c__EA_cef_menu_anchor_position_t__enumvalues
# Supported color types for menu items.
# Supported color types for menu items.

# values for enumeration 'c__EA_cef_menu_color_type_t'
c__EA_cef_menu_color_type_t__enumvalues = {
    0: 'CEF_MENU_COLOR_TEXT',
    1: 'CEF_MENU_COLOR_TEXT_HOVERED',
    2: 'CEF_MENU_COLOR_TEXT_ACCELERATOR',
    3: 'CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED',
    4: 'CEF_MENU_COLOR_BACKGROUND',
    5: 'CEF_MENU_COLOR_BACKGROUND_HOVERED',
    6: 'CEF_MENU_COLOR_COUNT',
}
CEF_MENU_COLOR_TEXT = 0
CEF_MENU_COLOR_TEXT_HOVERED = 1
CEF_MENU_COLOR_TEXT_ACCELERATOR = 2
CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED = 3
CEF_MENU_COLOR_BACKGROUND = 4
CEF_MENU_COLOR_BACKGROUND_HOVERED = 5
CEF_MENU_COLOR_COUNT = 6
c__EA_cef_menu_color_type_t = ctypes.c_uint32 # enum
# Supported color types for menu items.
# Supported color types for menu items.
cef_menu_color_type_t = c__EA_cef_menu_color_type_t
cef_menu_color_type_t__enumvalues = c__EA_cef_menu_color_type_t__enumvalues
# Supported SSL version values. See net/ssl/ssl_connection_status_flags.h for
# more information.
# Supported SSL version values. See net/ssl/ssl_connection_status_flags.h for
# more information.

# values for enumeration 'c__EA_cef_ssl_version_t'
c__EA_cef_ssl_version_t__enumvalues = {
    0: 'SSL_CONNECTION_VERSION_UNKNOWN',
    1: 'SSL_CONNECTION_VERSION_SSL2',
    2: 'SSL_CONNECTION_VERSION_SSL3',
    3: 'SSL_CONNECTION_VERSION_TLS1',
    4: 'SSL_CONNECTION_VERSION_TLS1_1',
    5: 'SSL_CONNECTION_VERSION_TLS1_2',
    6: 'SSL_CONNECTION_VERSION_TLS1_3',
    7: 'SSL_CONNECTION_VERSION_QUIC',
}
SSL_CONNECTION_VERSION_UNKNOWN = 0
SSL_CONNECTION_VERSION_SSL2 = 1
SSL_CONNECTION_VERSION_SSL3 = 2
SSL_CONNECTION_VERSION_TLS1 = 3
SSL_CONNECTION_VERSION_TLS1_1 = 4
SSL_CONNECTION_VERSION_TLS1_2 = 5
SSL_CONNECTION_VERSION_TLS1_3 = 6
SSL_CONNECTION_VERSION_QUIC = 7
c__EA_cef_ssl_version_t = ctypes.c_uint32 # enum
# Supported SSL version values. See net/ssl/ssl_connection_status_flags.h for
# more information.
# Supported SSL version values. See net/ssl/ssl_connection_status_flags.h for
# more information.
cef_ssl_version_t = c__EA_cef_ssl_version_t
cef_ssl_version_t__enumvalues = c__EA_cef_ssl_version_t__enumvalues
# Supported SSL content status flags. See content/public/common/ssl_status.h for
# more information.
# Supported SSL content status flags. See content/public/common/ssl_status.h for
# more information.

# values for enumeration 'c__EA_cef_ssl_content_status_t'
c__EA_cef_ssl_content_status_t__enumvalues = {
    0: 'SSL_CONTENT_NORMAL_CONTENT',
    1: 'SSL_CONTENT_DISPLAYED_INSECURE_CONTENT',
    2: 'SSL_CONTENT_RAN_INSECURE_CONTENT',
}
SSL_CONTENT_NORMAL_CONTENT = 0
SSL_CONTENT_DISPLAYED_INSECURE_CONTENT = 1
SSL_CONTENT_RAN_INSECURE_CONTENT = 2
c__EA_cef_ssl_content_status_t = ctypes.c_uint32 # enum
# Supported SSL content status flags. See content/public/common/ssl_status.h for
# more information.
# Supported SSL content status flags. See content/public/common/ssl_status.h for
# more information.
cef_ssl_content_status_t = c__EA_cef_ssl_content_status_t
cef_ssl_content_status_t__enumvalues = c__EA_cef_ssl_content_status_t__enumvalues
# Configuration options for registering a custom scheme. These values are used
# when calling AddCustomScheme.
# Configuration options for registering a custom scheme. These values are used
# when calling AddCustomScheme.

# values for enumeration 'c__EA_cef_scheme_options_t'
c__EA_cef_scheme_options_t__enumvalues = {
    0: 'CEF_SCHEME_OPTION_NONE',
    1: 'CEF_SCHEME_OPTION_STANDARD',
    2: 'CEF_SCHEME_OPTION_LOCAL',
    4: 'CEF_SCHEME_OPTION_DISPLAY_ISOLATED',
    8: 'CEF_SCHEME_OPTION_SECURE',
    16: 'CEF_SCHEME_OPTION_CORS_ENABLED',
    32: 'CEF_SCHEME_OPTION_CSP_BYPASSING',
    64: 'CEF_SCHEME_OPTION_FETCH_ENABLED',
}
CEF_SCHEME_OPTION_NONE = 0
CEF_SCHEME_OPTION_STANDARD = 1
CEF_SCHEME_OPTION_LOCAL = 2
CEF_SCHEME_OPTION_DISPLAY_ISOLATED = 4
CEF_SCHEME_OPTION_SECURE = 8
CEF_SCHEME_OPTION_CORS_ENABLED = 16
CEF_SCHEME_OPTION_CSP_BYPASSING = 32
CEF_SCHEME_OPTION_FETCH_ENABLED = 64
c__EA_cef_scheme_options_t = ctypes.c_uint32 # enum
# Configuration options for registering a custom scheme. These values are used
# when calling AddCustomScheme.
# Configuration options for registering a custom scheme. These values are used
# when calling AddCustomScheme.
cef_scheme_options_t = c__EA_cef_scheme_options_t
cef_scheme_options_t__enumvalues = c__EA_cef_scheme_options_t__enumvalues
# Structure representing a range.
class struct__cef_range_t(Structure):
    pass

struct__cef_range_t._pack_ = 1 # source:False
struct__cef_range_t._fields_ = [
    ('from', ctypes.c_uint32),
    ('to', ctypes.c_uint32),
]

# Structure representing a range.
# Structure representing a range.
cef_range_t = struct__cef_range_t
# Composition underline style.
# Composition underline style.

# values for enumeration 'c__EA_cef_composition_underline_style_t'
c__EA_cef_composition_underline_style_t__enumvalues = {
    0: 'CEF_CUS_SOLID',
    1: 'CEF_CUS_DOT',
    2: 'CEF_CUS_DASH',
    3: 'CEF_CUS_NONE',
}
CEF_CUS_SOLID = 0
CEF_CUS_DOT = 1
CEF_CUS_DASH = 2
CEF_CUS_NONE = 3
c__EA_cef_composition_underline_style_t = ctypes.c_uint32 # enum
# Composition underline style.
# Composition underline style.
cef_composition_underline_style_t = c__EA_cef_composition_underline_style_t
cef_composition_underline_style_t__enumvalues = c__EA_cef_composition_underline_style_t__enumvalues
# Structure representing IME composition underline information. This is a thin
# wrapper around Blink's WebCompositionUnderline class and should be kept in
# sync with that.
class struct__cef_composition_underline_t(Structure):
    pass

struct__cef_composition_underline_t._pack_ = 1 # source:False
struct__cef_composition_underline_t._fields_ = [
    ('range', cef_range_t),
    ('color', ctypes.c_uint32),
    ('background_color', ctypes.c_uint32),
    ('thick', ctypes.c_int32),
    ('style', cef_composition_underline_style_t),
]

# Structure representing IME composition underline information. This is a thin
# wrapper around Blink's WebCompositionUnderline class and should be kept in
# sync with that.
# Structure representing IME composition underline information. This is a thin
# wrapper around Blink's WebCompositionUnderline class and should be kept in
# sync with that.
cef_composition_underline_t = struct__cef_composition_underline_t
# Enumerates the various representations of the ordering of audio channels. Must
# be kept synchronized with media::ChannelLayout from Chromium. See
# media_layout.h
# Enumerates the various representations of the ordering of audio channels. Must
# be kept synchronized with media::ChannelLayout from Chromium. See
# media_layout.h

# values for enumeration 'c__EA_cef_channel_layout_t'
c__EA_cef_channel_layout_t__enumvalues = {
    0: 'CEF_CHANNEL_LAYOUT_NONE',
    1: 'CEF_CHANNEL_LAYOUT_UNSUPPORTED',
    2: 'CEF_CHANNEL_LAYOUT_MONO',
    3: 'CEF_CHANNEL_LAYOUT_STEREO',
    4: 'CEF_CHANNEL_LAYOUT_2_1',
    5: 'CEF_CHANNEL_LAYOUT_SURROUND',
    6: 'CEF_CHANNEL_LAYOUT_4_0',
    7: 'CEF_CHANNEL_LAYOUT_2_2',
    8: 'CEF_CHANNEL_LAYOUT_QUAD',
    9: 'CEF_CHANNEL_LAYOUT_5_0',
    10: 'CEF_CHANNEL_LAYOUT_5_1',
    11: 'CEF_CHANNEL_LAYOUT_5_0_BACK',
    12: 'CEF_CHANNEL_LAYOUT_5_1_BACK',
    13: 'CEF_CHANNEL_LAYOUT_7_0',
    14: 'CEF_CHANNEL_LAYOUT_7_1',
    15: 'CEF_CHANNEL_LAYOUT_7_1_WIDE',
    16: 'CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX',
    17: 'CEF_CHANNEL_LAYOUT_2POINT1',
    18: 'CEF_CHANNEL_LAYOUT_3_1',
    19: 'CEF_CHANNEL_LAYOUT_4_1',
    20: 'CEF_CHANNEL_LAYOUT_6_0',
    21: 'CEF_CHANNEL_LAYOUT_6_0_FRONT',
    22: 'CEF_CHANNEL_LAYOUT_HEXAGONAL',
    23: 'CEF_CHANNEL_LAYOUT_6_1',
    24: 'CEF_CHANNEL_LAYOUT_6_1_BACK',
    25: 'CEF_CHANNEL_LAYOUT_6_1_FRONT',
    26: 'CEF_CHANNEL_LAYOUT_7_0_FRONT',
    27: 'CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK',
    28: 'CEF_CHANNEL_LAYOUT_OCTAGONAL',
    29: 'CEF_CHANNEL_LAYOUT_DISCRETE',
    30: 'CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC',
    31: 'CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE',
    32: 'CEF_CHANNEL_LAYOUT_BITSTREAM',
    33: 'CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX',
    34: 'CEF_CHANNEL_LAYOUT_1_1',
    35: 'CEF_CHANNEL_LAYOUT_3_1_BACK',
    35: 'CEF_CHANNEL_LAYOUT_MAX',
}
CEF_CHANNEL_LAYOUT_NONE = 0
CEF_CHANNEL_LAYOUT_UNSUPPORTED = 1
CEF_CHANNEL_LAYOUT_MONO = 2
CEF_CHANNEL_LAYOUT_STEREO = 3
CEF_CHANNEL_LAYOUT_2_1 = 4
CEF_CHANNEL_LAYOUT_SURROUND = 5
CEF_CHANNEL_LAYOUT_4_0 = 6
CEF_CHANNEL_LAYOUT_2_2 = 7
CEF_CHANNEL_LAYOUT_QUAD = 8
CEF_CHANNEL_LAYOUT_5_0 = 9
CEF_CHANNEL_LAYOUT_5_1 = 10
CEF_CHANNEL_LAYOUT_5_0_BACK = 11
CEF_CHANNEL_LAYOUT_5_1_BACK = 12
CEF_CHANNEL_LAYOUT_7_0 = 13
CEF_CHANNEL_LAYOUT_7_1 = 14
CEF_CHANNEL_LAYOUT_7_1_WIDE = 15
CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX = 16
CEF_CHANNEL_LAYOUT_2POINT1 = 17
CEF_CHANNEL_LAYOUT_3_1 = 18
CEF_CHANNEL_LAYOUT_4_1 = 19
CEF_CHANNEL_LAYOUT_6_0 = 20
CEF_CHANNEL_LAYOUT_6_0_FRONT = 21
CEF_CHANNEL_LAYOUT_HEXAGONAL = 22
CEF_CHANNEL_LAYOUT_6_1 = 23
CEF_CHANNEL_LAYOUT_6_1_BACK = 24
CEF_CHANNEL_LAYOUT_6_1_FRONT = 25
CEF_CHANNEL_LAYOUT_7_0_FRONT = 26
CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK = 27
CEF_CHANNEL_LAYOUT_OCTAGONAL = 28
CEF_CHANNEL_LAYOUT_DISCRETE = 29
CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC = 30
CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE = 31
CEF_CHANNEL_LAYOUT_BITSTREAM = 32
CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX = 33
CEF_CHANNEL_LAYOUT_1_1 = 34
CEF_CHANNEL_LAYOUT_3_1_BACK = 35
CEF_CHANNEL_LAYOUT_MAX = 35
c__EA_cef_channel_layout_t = ctypes.c_uint32 # enum
# Enumerates the various representations of the ordering of audio channels. Must
# be kept synchronized with media::ChannelLayout from Chromium. See
# media_layout.h
# Enumerates the various representations of the ordering of audio channels. Must
# be kept synchronized with media::ChannelLayout from Chromium. See
# media_layout.h
cef_channel_layout_t = c__EA_cef_channel_layout_t
cef_channel_layout_t__enumvalues = c__EA_cef_channel_layout_t__enumvalues
# Structure representing the audio parameters for setting up the audio handler.
class struct__cef_audio_parameters_t(Structure):
    pass

struct__cef_audio_parameters_t._pack_ = 1 # source:False
struct__cef_audio_parameters_t._fields_ = [
    ('channel_layout', cef_channel_layout_t),
    ('sample_rate', ctypes.c_int32),
    ('frames_per_buffer', ctypes.c_int32),
]

# Structure representing the audio parameters for setting up the audio handler.
# Structure representing the audio parameters for setting up the audio handler.
cef_audio_parameters_t = struct__cef_audio_parameters_t
# Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with
# Chromium's media_router::mojom::RouteRequestResultCode type.
# Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with
# Chromium's media_router::mojom::RouteRequestResultCode type.

# values for enumeration 'c__EA_cef_media_route_create_result_t'
c__EA_cef_media_route_create_result_t__enumvalues = {
    0: 'CEF_MRCR_UNKNOWN_ERROR',
    1: 'CEF_MRCR_OK',
    2: 'CEF_MRCR_TIMED_OUT',
    3: 'CEF_MRCR_ROUTE_NOT_FOUND',
    4: 'CEF_MRCR_SINK_NOT_FOUND',
    5: 'CEF_MRCR_INVALID_ORIGIN',
    7: 'CEF_MRCR_NO_SUPPORTED_PROVIDER',
    8: 'CEF_MRCR_CANCELLED',
    9: 'CEF_MRCR_ROUTE_ALREADY_EXISTS',
    11: 'CEF_MRCR_ROUTE_ALREADY_TERMINATED',
}
CEF_MRCR_UNKNOWN_ERROR = 0
CEF_MRCR_OK = 1
CEF_MRCR_TIMED_OUT = 2
CEF_MRCR_ROUTE_NOT_FOUND = 3
CEF_MRCR_SINK_NOT_FOUND = 4
CEF_MRCR_INVALID_ORIGIN = 5
CEF_MRCR_NO_SUPPORTED_PROVIDER = 7
CEF_MRCR_CANCELLED = 8
CEF_MRCR_ROUTE_ALREADY_EXISTS = 9
CEF_MRCR_ROUTE_ALREADY_TERMINATED = 11
c__EA_cef_media_route_create_result_t = ctypes.c_uint32 # enum
# Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with
# Chromium's media_router::mojom::RouteRequestResultCode type.
# Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with
# Chromium's media_router::mojom::RouteRequestResultCode type.
cef_media_route_create_result_t = c__EA_cef_media_route_create_result_t
cef_media_route_create_result_t__enumvalues = c__EA_cef_media_route_create_result_t__enumvalues
# Connection state for a MediaRoute object.
# Connection state for a MediaRoute object.

# values for enumeration 'c__EA_cef_media_route_connection_state_t'
c__EA_cef_media_route_connection_state_t__enumvalues = {
    0: 'CEF_MRCS_UNKNOWN',
    1: 'CEF_MRCS_CONNECTING',
    2: 'CEF_MRCS_CONNECTED',
    3: 'CEF_MRCS_CLOSED',
    4: 'CEF_MRCS_TERMINATED',
}
CEF_MRCS_UNKNOWN = 0
CEF_MRCS_CONNECTING = 1
CEF_MRCS_CONNECTED = 2
CEF_MRCS_CLOSED = 3
CEF_MRCS_TERMINATED = 4
c__EA_cef_media_route_connection_state_t = ctypes.c_uint32 # enum
# Connection state for a MediaRoute object.
# Connection state for a MediaRoute object.
cef_media_route_connection_state_t = c__EA_cef_media_route_connection_state_t
cef_media_route_connection_state_t__enumvalues = c__EA_cef_media_route_connection_state_t__enumvalues
# Icon types for a MediaSink object. Should be kept in sync with Chromium's
# media_router::SinkIconType type.
# Icon types for a MediaSink object. Should be kept in sync with Chromium's
# media_router::SinkIconType type.

# values for enumeration 'c__EA_cef_media_sink_icon_type_t'
c__EA_cef_media_sink_icon_type_t__enumvalues = {
    0: 'CEF_MSIT_CAST',
    1: 'CEF_MSIT_CAST_AUDIO_GROUP',
    2: 'CEF_MSIT_CAST_AUDIO',
    3: 'CEF_MSIT_MEETING',
    4: 'CEF_MSIT_HANGOUT',
    5: 'CEF_MSIT_EDUCATION',
    6: 'CEF_MSIT_WIRED_DISPLAY',
    7: 'CEF_MSIT_GENERIC',
    8: 'CEF_MSIT_TOTAL_COUNT',
}
CEF_MSIT_CAST = 0
CEF_MSIT_CAST_AUDIO_GROUP = 1
CEF_MSIT_CAST_AUDIO = 2
CEF_MSIT_MEETING = 3
CEF_MSIT_HANGOUT = 4
CEF_MSIT_EDUCATION = 5
CEF_MSIT_WIRED_DISPLAY = 6
CEF_MSIT_GENERIC = 7
CEF_MSIT_TOTAL_COUNT = 8
c__EA_cef_media_sink_icon_type_t = ctypes.c_uint32 # enum
# Icon types for a MediaSink object. Should be kept in sync with Chromium's
# media_router::SinkIconType type.
# Icon types for a MediaSink object. Should be kept in sync with Chromium's
# media_router::SinkIconType type.
cef_media_sink_icon_type_t = c__EA_cef_media_sink_icon_type_t
cef_media_sink_icon_type_t__enumvalues = c__EA_cef_media_sink_icon_type_t__enumvalues
# Device information for a MediaSink object.
class struct__cef_media_sink_device_info_t(Structure):
    pass

struct__cef_media_sink_device_info_t._pack_ = 1 # source:False
struct__cef_media_sink_device_info_t._fields_ = [
    ('ip_address', cef_string_t),
    ('port', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('model_name', cef_string_t),
]

# Device information for a MediaSink object.
# Device information for a MediaSink object.
cef_media_sink_device_info_t = struct__cef_media_sink_device_info_t
# Represents commands available to TextField.
# Represents commands available to TextField.

# values for enumeration 'c__EA_cef_text_field_commands_t'
c__EA_cef_text_field_commands_t__enumvalues = {
    1: 'CEF_TFC_CUT',
    2: 'CEF_TFC_COPY',
    3: 'CEF_TFC_PASTE',
    4: 'CEF_TFC_UNDO',
    5: 'CEF_TFC_DELETE',
    6: 'CEF_TFC_SELECT_ALL',
}
CEF_TFC_CUT = 1
CEF_TFC_COPY = 2
CEF_TFC_PASTE = 3
CEF_TFC_UNDO = 4
CEF_TFC_DELETE = 5
CEF_TFC_SELECT_ALL = 6
c__EA_cef_text_field_commands_t = ctypes.c_uint32 # enum
# Represents commands available to TextField.
# Represents commands available to TextField.
cef_text_field_commands_t = c__EA_cef_text_field_commands_t
cef_text_field_commands_t__enumvalues = c__EA_cef_text_field_commands_t__enumvalues
# Chrome toolbar types.
# Chrome toolbar types.

# values for enumeration 'c__EA_cef_chrome_toolbar_type_t'
c__EA_cef_chrome_toolbar_type_t__enumvalues = {
    1: 'CEF_CTT_NONE',
    2: 'CEF_CTT_NORMAL',
    3: 'CEF_CTT_LOCATION',
}
CEF_CTT_NONE = 1
CEF_CTT_NORMAL = 2
CEF_CTT_LOCATION = 3
c__EA_cef_chrome_toolbar_type_t = ctypes.c_uint32 # enum
# Chrome toolbar types.
# Chrome toolbar types.
cef_chrome_toolbar_type_t = c__EA_cef_chrome_toolbar_type_t
cef_chrome_toolbar_type_t__enumvalues = c__EA_cef_chrome_toolbar_type_t__enumvalues
# Chrome page action icon types. Should be kept in sync with Chromium's
# PageActionIconType type.
# Chrome page action icon types. Should be kept in sync with Chromium's
# PageActionIconType type.

# values for enumeration 'c__EA_cef_chrome_page_action_icon_type_t'
c__EA_cef_chrome_page_action_icon_type_t__enumvalues = {
    0: 'CEF_CPAIT_BOOKMARK_STAR',
    1: 'CEF_CPAIT_CLICK_TO_CALL',
    2: 'CEF_CPAIT_COOKIE_CONTROLS',
    3: 'CEF_CPAIT_FILE_SYSTEM_ACCESS',
    4: 'CEF_CPAIT_FIND',
    5: 'CEF_CPAIT_MEMORY_SAVER',
    6: 'CEF_CPAIT_INTENT_PICKER',
    7: 'CEF_CPAIT_LOCAL_CARD_MIGRATION',
    8: 'CEF_CPAIT_MANAGE_PASSWORDS',
    9: 'CEF_CPAIT_PAYMENTS_OFFER_NOTIFICATION',
    10: 'CEF_CPAIT_PRICE_TRACKING',
    11: 'CEF_CPAIT_PWA_INSTALL',
    12: 'CEF_CPAIT_QR_CODE_GENERATOR_DEPRECATED',
    13: 'CEF_CPAIT_READER_MODE_DEPRECATED',
    14: 'CEF_CPAIT_SAVE_AUTOFILL_ADDRESS',
    15: 'CEF_CPAIT_SAVE_CARD',
    16: 'CEF_CPAIT_SEND_TAB_TO_SELF_DEPRECATED',
    17: 'CEF_CPAIT_SHARING_HUB',
    18: 'CEF_CPAIT_SIDE_SEARCH',
    19: 'CEF_CPAIT_SMS_REMOTE_FETCHER',
    20: 'CEF_CPAIT_TRANSLATE',
    21: 'CEF_CPAIT_VIRTUAL_CARD_ENROLL',
    22: 'CEF_CPAIT_VIRTUAL_CARD_MANUAL_FALLBACK',
    23: 'CEF_CPAIT_ZOOM',
    24: 'CEF_CPAIT_SAVE_IBAN',
    25: 'CEF_CPAIT_MANDATORY_REAUTH',
    26: 'CEF_CPAIT_PRICE_INSIGHTS',
    27: 'CEF_CPAIT_PRICE_READ_ANYTHING',
    28: 'CEF_CPAIT_PRODUCT_SPECIFICATIONS',
    29: 'CEF_CPAIT_LENS_OVERLAY',
    30: 'CEF_CPAIT_DISCOUNTS',
    30: 'CEF_CPAIT_MAX_VALUE',
}
CEF_CPAIT_BOOKMARK_STAR = 0
CEF_CPAIT_CLICK_TO_CALL = 1
CEF_CPAIT_COOKIE_CONTROLS = 2
CEF_CPAIT_FILE_SYSTEM_ACCESS = 3
CEF_CPAIT_FIND = 4
CEF_CPAIT_MEMORY_SAVER = 5
CEF_CPAIT_INTENT_PICKER = 6
CEF_CPAIT_LOCAL_CARD_MIGRATION = 7
CEF_CPAIT_MANAGE_PASSWORDS = 8
CEF_CPAIT_PAYMENTS_OFFER_NOTIFICATION = 9
CEF_CPAIT_PRICE_TRACKING = 10
CEF_CPAIT_PWA_INSTALL = 11
CEF_CPAIT_QR_CODE_GENERATOR_DEPRECATED = 12
CEF_CPAIT_READER_MODE_DEPRECATED = 13
CEF_CPAIT_SAVE_AUTOFILL_ADDRESS = 14
CEF_CPAIT_SAVE_CARD = 15
CEF_CPAIT_SEND_TAB_TO_SELF_DEPRECATED = 16
CEF_CPAIT_SHARING_HUB = 17
CEF_CPAIT_SIDE_SEARCH = 18
CEF_CPAIT_SMS_REMOTE_FETCHER = 19
CEF_CPAIT_TRANSLATE = 20
CEF_CPAIT_VIRTUAL_CARD_ENROLL = 21
CEF_CPAIT_VIRTUAL_CARD_MANUAL_FALLBACK = 22
CEF_CPAIT_ZOOM = 23
CEF_CPAIT_SAVE_IBAN = 24
CEF_CPAIT_MANDATORY_REAUTH = 25
CEF_CPAIT_PRICE_INSIGHTS = 26
CEF_CPAIT_PRICE_READ_ANYTHING = 27
CEF_CPAIT_PRODUCT_SPECIFICATIONS = 28
CEF_CPAIT_LENS_OVERLAY = 29
CEF_CPAIT_DISCOUNTS = 30
CEF_CPAIT_MAX_VALUE = 30
c__EA_cef_chrome_page_action_icon_type_t = ctypes.c_uint32 # enum
# Chrome page action icon types. Should be kept in sync with Chromium's
# PageActionIconType type.
# Chrome page action icon types. Should be kept in sync with Chromium's
# PageActionIconType type.
cef_chrome_page_action_icon_type_t = c__EA_cef_chrome_page_action_icon_type_t
cef_chrome_page_action_icon_type_t__enumvalues = c__EA_cef_chrome_page_action_icon_type_t__enumvalues
# Chrome toolbar button types. Should be kept in sync with CEF's internal
# ToolbarButtonType type.
# Chrome toolbar button types. Should be kept in sync with CEF's internal
# ToolbarButtonType type.

# values for enumeration 'c__EA_cef_chrome_toolbar_button_type_t'
c__EA_cef_chrome_toolbar_button_type_t__enumvalues = {
    0: 'CEF_CTBT_CAST',
    1: 'CEF_CTBT_DOWNLOAD',
    2: 'CEF_CTBT_SEND_TAB_TO_SELF',
    3: 'CEF_CTBT_SIDE_PANEL',
    3: 'CEF_CTBT_MAX_VALUE',
}
CEF_CTBT_CAST = 0
CEF_CTBT_DOWNLOAD = 1
CEF_CTBT_SEND_TAB_TO_SELF = 2
CEF_CTBT_SIDE_PANEL = 3
CEF_CTBT_MAX_VALUE = 3
c__EA_cef_chrome_toolbar_button_type_t = ctypes.c_uint32 # enum
# Chrome toolbar button types. Should be kept in sync with CEF's internal
# ToolbarButtonType type.
# Chrome toolbar button types. Should be kept in sync with CEF's internal
# ToolbarButtonType type.
cef_chrome_toolbar_button_type_t = c__EA_cef_chrome_toolbar_button_type_t
cef_chrome_toolbar_button_type_t__enumvalues = c__EA_cef_chrome_toolbar_button_type_t__enumvalues
# Docking modes supported by CefWindow::AddOverlay.
# Docking modes supported by CefWindow::AddOverlay.

# values for enumeration 'c__EA_cef_docking_mode_t'
c__EA_cef_docking_mode_t__enumvalues = {
    1: 'CEF_DOCKING_MODE_TOP_LEFT',
    2: 'CEF_DOCKING_MODE_TOP_RIGHT',
    3: 'CEF_DOCKING_MODE_BOTTOM_LEFT',
    4: 'CEF_DOCKING_MODE_BOTTOM_RIGHT',
    5: 'CEF_DOCKING_MODE_CUSTOM',
}
CEF_DOCKING_MODE_TOP_LEFT = 1
CEF_DOCKING_MODE_TOP_RIGHT = 2
CEF_DOCKING_MODE_BOTTOM_LEFT = 3
CEF_DOCKING_MODE_BOTTOM_RIGHT = 4
CEF_DOCKING_MODE_CUSTOM = 5
c__EA_cef_docking_mode_t = ctypes.c_uint32 # enum
# Docking modes supported by CefWindow::AddOverlay.
# Docking modes supported by CefWindow::AddOverlay.
cef_docking_mode_t = c__EA_cef_docking_mode_t
cef_docking_mode_t__enumvalues = c__EA_cef_docking_mode_t__enumvalues
# Show states supported by CefWindowDelegate::GetInitialShowState.
# Show states supported by CefWindowDelegate::GetInitialShowState.

# values for enumeration 'c__EA_cef_show_state_t'
c__EA_cef_show_state_t__enumvalues = {
    1: 'CEF_SHOW_STATE_NORMAL',
    2: 'CEF_SHOW_STATE_MINIMIZED',
    3: 'CEF_SHOW_STATE_MAXIMIZED',
    4: 'CEF_SHOW_STATE_FULLSCREEN',
    5: 'CEF_SHOW_STATE_HIDDEN',
}
CEF_SHOW_STATE_NORMAL = 1
CEF_SHOW_STATE_MINIMIZED = 2
CEF_SHOW_STATE_MAXIMIZED = 3
CEF_SHOW_STATE_FULLSCREEN = 4
CEF_SHOW_STATE_HIDDEN = 5
c__EA_cef_show_state_t = ctypes.c_uint32 # enum
# Show states supported by CefWindowDelegate::GetInitialShowState.
# Show states supported by CefWindowDelegate::GetInitialShowState.
cef_show_state_t = c__EA_cef_show_state_t
cef_show_state_t__enumvalues = c__EA_cef_show_state_t__enumvalues
# Values indicating what state of the touch handle is set.
# Values indicating what state of the touch handle is set.

# values for enumeration 'c__EA_cef_touch_handle_state_flags_t'
c__EA_cef_touch_handle_state_flags_t__enumvalues = {
    0: 'CEF_THS_FLAG_NONE',
    1: 'CEF_THS_FLAG_ENABLED',
    2: 'CEF_THS_FLAG_ORIENTATION',
    4: 'CEF_THS_FLAG_ORIGIN',
    8: 'CEF_THS_FLAG_ALPHA',
}
CEF_THS_FLAG_NONE = 0
CEF_THS_FLAG_ENABLED = 1
CEF_THS_FLAG_ORIENTATION = 2
CEF_THS_FLAG_ORIGIN = 4
CEF_THS_FLAG_ALPHA = 8
c__EA_cef_touch_handle_state_flags_t = ctypes.c_uint32 # enum
# Values indicating what state of the touch handle is set.
# Values indicating what state of the touch handle is set.
cef_touch_handle_state_flags_t = c__EA_cef_touch_handle_state_flags_t
cef_touch_handle_state_flags_t__enumvalues = c__EA_cef_touch_handle_state_flags_t__enumvalues
class struct__cef_touch_handle_state_t(Structure):
    pass

struct__cef_touch_handle_state_t._pack_ = 1 # source:False
struct__cef_touch_handle_state_t._fields_ = [
    ('touch_handle_id', ctypes.c_int32),
    ('flags', ctypes.c_uint32),
    ('enabled', ctypes.c_int32),
    ('orientation', cef_horizontal_alignment_t),
    ('mirror_vertical', ctypes.c_int32),
    ('mirror_horizontal', ctypes.c_int32),
    ('origin', cef_point_t),
    ('alpha', ctypes.c_float),
]

cef_touch_handle_state_t = struct__cef_touch_handle_state_t
# Media access permissions used by OnRequestMediaAccessPermission.
# Media access permissions used by OnRequestMediaAccessPermission.

# values for enumeration 'c__EA_cef_media_access_permission_types_t'
c__EA_cef_media_access_permission_types_t__enumvalues = {
    0: 'CEF_MEDIA_PERMISSION_NONE',
    1: 'CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE',
    2: 'CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE',
    4: 'CEF_MEDIA_PERMISSION_DESKTOP_AUDIO_CAPTURE',
    8: 'CEF_MEDIA_PERMISSION_DESKTOP_VIDEO_CAPTURE',
}
CEF_MEDIA_PERMISSION_NONE = 0
CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE = 1
CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE = 2
CEF_MEDIA_PERMISSION_DESKTOP_AUDIO_CAPTURE = 4
CEF_MEDIA_PERMISSION_DESKTOP_VIDEO_CAPTURE = 8
c__EA_cef_media_access_permission_types_t = ctypes.c_uint32 # enum
# Media access permissions used by OnRequestMediaAccessPermission.
# Media access permissions used by OnRequestMediaAccessPermission.
cef_media_access_permission_types_t = c__EA_cef_media_access_permission_types_t
cef_media_access_permission_types_t__enumvalues = c__EA_cef_media_access_permission_types_t__enumvalues
# Permission types used with OnShowPermissionPrompt. Some types are platform-
# specific or only supported with Chrome style. Should be kept in sync with
# Chromium's permissions::RequestType type.
# Permission types used with OnShowPermissionPrompt. Some types are platform-
# specific or only supported with Chrome style. Should be kept in sync with
# Chromium's permissions::RequestType type.

# values for enumeration 'c__EA_cef_permission_request_types_t'
c__EA_cef_permission_request_types_t__enumvalues = {
    0: 'CEF_PERMISSION_TYPE_NONE',
    1: 'CEF_PERMISSION_TYPE_AR_SESSION',
    2: 'CEF_PERMISSION_TYPE_CAMERA_PAN_TILT_ZOOM',
    4: 'CEF_PERMISSION_TYPE_CAMERA_STREAM',
    8: 'CEF_PERMISSION_TYPE_CAPTURED_SURFACE_CONTROL',
    16: 'CEF_PERMISSION_TYPE_CLIPBOARD',
    32: 'CEF_PERMISSION_TYPE_TOP_LEVEL_STORAGE_ACCESS',
    64: 'CEF_PERMISSION_TYPE_DISK_QUOTA',
    128: 'CEF_PERMISSION_TYPE_LOCAL_FONTS',
    256: 'CEF_PERMISSION_TYPE_GEOLOCATION',
    512: 'CEF_PERMISSION_TYPE_HAND_TRACKING',
    1024: 'CEF_PERMISSION_TYPE_IDENTITY_PROVIDER',
    2048: 'CEF_PERMISSION_TYPE_IDLE_DETECTION',
    4096: 'CEF_PERMISSION_TYPE_MIC_STREAM',
    8192: 'CEF_PERMISSION_TYPE_MIDI_SYSEX',
    16384: 'CEF_PERMISSION_TYPE_MULTIPLE_DOWNLOADS',
    32768: 'CEF_PERMISSION_TYPE_NOTIFICATIONS',
    65536: 'CEF_PERMISSION_TYPE_KEYBOARD_LOCK',
    131072: 'CEF_PERMISSION_TYPE_POINTER_LOCK',
    262144: 'CEF_PERMISSION_TYPE_PROTECTED_MEDIA_IDENTIFIER',
    524288: 'CEF_PERMISSION_TYPE_REGISTER_PROTOCOL_HANDLER',
    1048576: 'CEF_PERMISSION_TYPE_STORAGE_ACCESS',
    2097152: 'CEF_PERMISSION_TYPE_VR_SESSION',
    4194304: 'CEF_PERMISSION_TYPE_WEB_APP_INSTALLATION',
    8388608: 'CEF_PERMISSION_TYPE_WINDOW_MANAGEMENT',
    16777216: 'CEF_PERMISSION_TYPE_FILE_SYSTEM_ACCESS',
}
CEF_PERMISSION_TYPE_NONE = 0
CEF_PERMISSION_TYPE_AR_SESSION = 1
CEF_PERMISSION_TYPE_CAMERA_PAN_TILT_ZOOM = 2
CEF_PERMISSION_TYPE_CAMERA_STREAM = 4
CEF_PERMISSION_TYPE_CAPTURED_SURFACE_CONTROL = 8
CEF_PERMISSION_TYPE_CLIPBOARD = 16
CEF_PERMISSION_TYPE_TOP_LEVEL_STORAGE_ACCESS = 32
CEF_PERMISSION_TYPE_DISK_QUOTA = 64
CEF_PERMISSION_TYPE_LOCAL_FONTS = 128
CEF_PERMISSION_TYPE_GEOLOCATION = 256
CEF_PERMISSION_TYPE_HAND_TRACKING = 512
CEF_PERMISSION_TYPE_IDENTITY_PROVIDER = 1024
CEF_PERMISSION_TYPE_IDLE_DETECTION = 2048
CEF_PERMISSION_TYPE_MIC_STREAM = 4096
CEF_PERMISSION_TYPE_MIDI_SYSEX = 8192
CEF_PERMISSION_TYPE_MULTIPLE_DOWNLOADS = 16384
CEF_PERMISSION_TYPE_NOTIFICATIONS = 32768
CEF_PERMISSION_TYPE_KEYBOARD_LOCK = 65536
CEF_PERMISSION_TYPE_POINTER_LOCK = 131072
CEF_PERMISSION_TYPE_PROTECTED_MEDIA_IDENTIFIER = 262144
CEF_PERMISSION_TYPE_REGISTER_PROTOCOL_HANDLER = 524288
CEF_PERMISSION_TYPE_STORAGE_ACCESS = 1048576
CEF_PERMISSION_TYPE_VR_SESSION = 2097152
CEF_PERMISSION_TYPE_WEB_APP_INSTALLATION = 4194304
CEF_PERMISSION_TYPE_WINDOW_MANAGEMENT = 8388608
CEF_PERMISSION_TYPE_FILE_SYSTEM_ACCESS = 16777216
c__EA_cef_permission_request_types_t = ctypes.c_uint32 # enum
# Permission types used with OnShowPermissionPrompt. Some types are platform-
# specific or only supported with Chrome style. Should be kept in sync with
# Chromium's permissions::RequestType type.
# Permission types used with OnShowPermissionPrompt. Some types are platform-
# specific or only supported with Chrome style. Should be kept in sync with
# Chromium's permissions::RequestType type.
cef_permission_request_types_t = c__EA_cef_permission_request_types_t
cef_permission_request_types_t__enumvalues = c__EA_cef_permission_request_types_t__enumvalues
# Permission request results.
# Permission request results.

# values for enumeration 'c__EA_cef_permission_request_result_t'
c__EA_cef_permission_request_result_t__enumvalues = {
    0: 'CEF_PERMISSION_RESULT_ACCEPT',
    1: 'CEF_PERMISSION_RESULT_DENY',
    2: 'CEF_PERMISSION_RESULT_DISMISS',
    3: 'CEF_PERMISSION_RESULT_IGNORE',
}
CEF_PERMISSION_RESULT_ACCEPT = 0
CEF_PERMISSION_RESULT_DENY = 1
CEF_PERMISSION_RESULT_DISMISS = 2
CEF_PERMISSION_RESULT_IGNORE = 3
c__EA_cef_permission_request_result_t = ctypes.c_uint32 # enum
# Permission request results.
# Permission request results.
cef_permission_request_result_t = c__EA_cef_permission_request_result_t
cef_permission_request_result_t__enumvalues = c__EA_cef_permission_request_result_t__enumvalues
# Certificate types supported by CefTestServer::CreateAndStart. The matching
# certificate file must exist in the "net/data/ssl/certificates" directory. See
# CefSetDataDirectoryForTests() for related configuration.
# Certificate types supported by CefTestServer::CreateAndStart. The matching
# certificate file must exist in the "net/data/ssl/certificates" directory. See
# CefSetDataDirectoryForTests() for related configuration.

# values for enumeration 'c__EA_cef_test_cert_type_t'
c__EA_cef_test_cert_type_t__enumvalues = {
    0: 'CEF_TEST_CERT_OK_IP',
    1: 'CEF_TEST_CERT_OK_DOMAIN',
    2: 'CEF_TEST_CERT_EXPIRED',
}
CEF_TEST_CERT_OK_IP = 0
CEF_TEST_CERT_OK_DOMAIN = 1
CEF_TEST_CERT_EXPIRED = 2
c__EA_cef_test_cert_type_t = ctypes.c_uint32 # enum
# Certificate types supported by CefTestServer::CreateAndStart. The matching
# certificate file must exist in the "net/data/ssl/certificates" directory. See
# CefSetDataDirectoryForTests() for related configuration.
# Certificate types supported by CefTestServer::CreateAndStart. The matching
# certificate file must exist in the "net/data/ssl/certificates" directory. See
# CefSetDataDirectoryForTests() for related configuration.
cef_test_cert_type_t = c__EA_cef_test_cert_type_t
cef_test_cert_type_t__enumvalues = c__EA_cef_test_cert_type_t__enumvalues
# Preferences type passed to
# CefBrowserProcessHandler::OnRegisterCustomPreferences.
# Preferences type passed to
# CefBrowserProcessHandler::OnRegisterCustomPreferences.

# values for enumeration 'c__EA_cef_preferences_type_t'
c__EA_cef_preferences_type_t__enumvalues = {
    0: 'CEF_PREFERENCES_TYPE_GLOBAL',
    1: 'CEF_PREFERENCES_TYPE_REQUEST_CONTEXT',
}
CEF_PREFERENCES_TYPE_GLOBAL = 0
CEF_PREFERENCES_TYPE_REQUEST_CONTEXT = 1
c__EA_cef_preferences_type_t = ctypes.c_uint32 # enum
# Preferences type passed to
# CefBrowserProcessHandler::OnRegisterCustomPreferences.
# Preferences type passed to
# CefBrowserProcessHandler::OnRegisterCustomPreferences.
cef_preferences_type_t = c__EA_cef_preferences_type_t
cef_preferences_type_t__enumvalues = c__EA_cef_preferences_type_t__enumvalues
# Download interrupt reasons. Should be kept in sync with Chromium's
# download::DownloadInterruptReason type.
# Download interrupt reasons. Should be kept in sync with Chromium's
# download::DownloadInterruptReason type.

# values for enumeration 'c__EA_cef_download_interrupt_reason_t'
c__EA_cef_download_interrupt_reason_t__enumvalues = {
    0: 'CEF_DOWNLOAD_INTERRUPT_REASON_NONE',
    1: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_FAILED',
    2: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED',
    3: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NO_SPACE',
    5: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG',
    6: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE',
    7: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_VIRUS_INFECTED',
    10: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR',
    11: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_BLOCKED',
    12: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SECURITY_CHECK_FAILED',
    13: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_SHORT',
    14: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_HASH_MISMATCH',
    15: 'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SAME_AS_SOURCE',
    20: 'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_FAILED',
    21: 'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT',
    22: 'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_DISCONNECTED',
    23: 'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_SERVER_DOWN',
    24: 'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST',
    30: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FAILED',
    31: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_NO_RANGE',
    33: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_BAD_CONTENT',
    34: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNAUTHORIZED',
    35: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CERT_PROBLEM',
    36: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FORBIDDEN',
    37: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNREACHABLE',
    38: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CONTENT_LENGTH_MISMATCH',
    39: 'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT',
    40: 'CEF_DOWNLOAD_INTERRUPT_REASON_USER_CANCELED',
    41: 'CEF_DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN',
    50: 'CEF_DOWNLOAD_INTERRUPT_REASON_CRASH',
}
CEF_DOWNLOAD_INTERRUPT_REASON_NONE = 0
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_FAILED = 1
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED = 2
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NO_SPACE = 3
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG = 5
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE = 6
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_VIRUS_INFECTED = 7
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR = 10
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_BLOCKED = 11
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SECURITY_CHECK_FAILED = 12
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_SHORT = 13
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_HASH_MISMATCH = 14
CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SAME_AS_SOURCE = 15
CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_FAILED = 20
CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT = 21
CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_DISCONNECTED = 22
CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_SERVER_DOWN = 23
CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST = 24
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FAILED = 30
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_NO_RANGE = 31
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_BAD_CONTENT = 33
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNAUTHORIZED = 34
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CERT_PROBLEM = 35
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FORBIDDEN = 36
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNREACHABLE = 37
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CONTENT_LENGTH_MISMATCH = 38
CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT = 39
CEF_DOWNLOAD_INTERRUPT_REASON_USER_CANCELED = 40
CEF_DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN = 41
CEF_DOWNLOAD_INTERRUPT_REASON_CRASH = 50
c__EA_cef_download_interrupt_reason_t = ctypes.c_uint32 # enum
# Download interrupt reasons. Should be kept in sync with Chromium's
# download::DownloadInterruptReason type.
# Download interrupt reasons. Should be kept in sync with Chromium's
# download::DownloadInterruptReason type.
cef_download_interrupt_reason_t = c__EA_cef_download_interrupt_reason_t
cef_download_interrupt_reason_t__enumvalues = c__EA_cef_download_interrupt_reason_t__enumvalues
# Specifies the gesture commands.
# Specifies the gesture commands.

# values for enumeration 'c__EA_cef_gesture_command_t'
c__EA_cef_gesture_command_t__enumvalues = {
    0: 'CEF_GESTURE_COMMAND_BACK',
    1: 'CEF_GESTURE_COMMAND_FORWARD',
}
CEF_GESTURE_COMMAND_BACK = 0
CEF_GESTURE_COMMAND_FORWARD = 1
c__EA_cef_gesture_command_t = ctypes.c_uint32 # enum
# Specifies the gesture commands.
# Specifies the gesture commands.
cef_gesture_command_t = c__EA_cef_gesture_command_t
cef_gesture_command_t__enumvalues = c__EA_cef_gesture_command_t__enumvalues
# Specifies the zoom commands supported by CefBrowserHost::Zoom.
# Specifies the zoom commands supported by CefBrowserHost::Zoom.

# values for enumeration 'c__EA_cef_zoom_command_t'
c__EA_cef_zoom_command_t__enumvalues = {
    0: 'CEF_ZOOM_COMMAND_OUT',
    1: 'CEF_ZOOM_COMMAND_RESET',
    2: 'CEF_ZOOM_COMMAND_IN',
}
CEF_ZOOM_COMMAND_OUT = 0
CEF_ZOOM_COMMAND_RESET = 1
CEF_ZOOM_COMMAND_IN = 2
c__EA_cef_zoom_command_t = ctypes.c_uint32 # enum
# Specifies the zoom commands supported by CefBrowserHost::Zoom.
# Specifies the zoom commands supported by CefBrowserHost::Zoom.
cef_zoom_command_t = c__EA_cef_zoom_command_t
cef_zoom_command_t__enumvalues = c__EA_cef_zoom_command_t__enumvalues
# Specifies the color variants supported by
# CefRequestContext::SetChromeThemeColor.
# Specifies the color variants supported by
# CefRequestContext::SetChromeThemeColor.

# values for enumeration 'c__EA_cef_color_variant_t'
c__EA_cef_color_variant_t__enumvalues = {
    0: 'CEF_COLOR_VARIANT_SYSTEM',
    1: 'CEF_COLOR_VARIANT_LIGHT',
    2: 'CEF_COLOR_VARIANT_DARK',
    3: 'CEF_COLOR_VARIANT_TONAL_SPOT',
    4: 'CEF_COLOR_VARIANT_NEUTRAL',
    5: 'CEF_COLOR_VARIANT_VIBRANT',
    6: 'CEF_COLOR_VARIANT_EXPRESSIVE',
}
CEF_COLOR_VARIANT_SYSTEM = 0
CEF_COLOR_VARIANT_LIGHT = 1
CEF_COLOR_VARIANT_DARK = 2
CEF_COLOR_VARIANT_TONAL_SPOT = 3
CEF_COLOR_VARIANT_NEUTRAL = 4
CEF_COLOR_VARIANT_VIBRANT = 5
CEF_COLOR_VARIANT_EXPRESSIVE = 6
c__EA_cef_color_variant_t = ctypes.c_uint32 # enum
# Specifies the color variants supported by
# CefRequestContext::SetChromeThemeColor.
# Specifies the color variants supported by
# CefRequestContext::SetChromeThemeColor.
cef_color_variant_t = c__EA_cef_color_variant_t
cef_color_variant_t__enumvalues = c__EA_cef_color_variant_t__enumvalues
# Specifies the task type variants supported by CefTaskManager. Should be kept
# in sync with Chromium's task_manager::Task::Type type.
# Specifies the task type variants supported by CefTaskManager. Should be kept
# in sync with Chromium's task_manager::Task::Type type.

# values for enumeration 'c__EA_cef_task_type_t'
c__EA_cef_task_type_t__enumvalues = {
    0: 'CEF_TASK_TYPE_UNKNOWN',
    1: 'CEF_TASK_TYPE_BROWSER',
    2: 'CEF_TASK_TYPE_GPU',
    3: 'CEF_TASK_TYPE_ZYGOTE',
    4: 'CEF_TASK_TYPE_UTILITY',
    5: 'CEF_TASK_TYPE_RENDERER',
    6: 'CEF_TASK_TYPE_EXTENSION',
    7: 'CEF_TASK_TYPE_GUEST',
    8: 'CEF_TASK_TYPE_PLUGIN',
    9: 'CEF_TASK_TYPE_SANDBOX_HELPER',
    10: 'CEF_TASK_TYPE_DEDICATED_WORKER',
    11: 'CEF_TASK_TYPE_SHARED_WORKER',
    12: 'CEF_TASK_TYPE_SERVICE_WORKER',
}
CEF_TASK_TYPE_UNKNOWN = 0
CEF_TASK_TYPE_BROWSER = 1
CEF_TASK_TYPE_GPU = 2
CEF_TASK_TYPE_ZYGOTE = 3
CEF_TASK_TYPE_UTILITY = 4
CEF_TASK_TYPE_RENDERER = 5
CEF_TASK_TYPE_EXTENSION = 6
CEF_TASK_TYPE_GUEST = 7
CEF_TASK_TYPE_PLUGIN = 8
CEF_TASK_TYPE_SANDBOX_HELPER = 9
CEF_TASK_TYPE_DEDICATED_WORKER = 10
CEF_TASK_TYPE_SHARED_WORKER = 11
CEF_TASK_TYPE_SERVICE_WORKER = 12
c__EA_cef_task_type_t = ctypes.c_uint32 # enum
# Specifies the task type variants supported by CefTaskManager. Should be kept
# in sync with Chromium's task_manager::Task::Type type.
# Specifies the task type variants supported by CefTaskManager. Should be kept
# in sync with Chromium's task_manager::Task::Type type.
cef_task_type_t = c__EA_cef_task_type_t
cef_task_type_t__enumvalues = c__EA_cef_task_type_t__enumvalues
# Structure representing task information provided by CefTaskManager.
class struct__cef_task_info_t(Structure):
    pass

struct__cef_task_info_t._pack_ = 1 # source:False
struct__cef_task_info_t._fields_ = [
    ('id', ctypes.c_int64),
    ('type', cef_task_type_t),
    ('is_killable', ctypes.c_int32),
    ('title', cef_string_t),
    ('cpu_usage', ctypes.c_double),
    ('number_of_processors', ctypes.c_int32),
    ('PADDING_0', ctypes.c_ubyte * 4),
    ('memory', ctypes.c_int64),
    ('gpu_memory', ctypes.c_int64),
    ('is_gpu_memory_inflated', ctypes.c_int32),
    ('PADDING_1', ctypes.c_ubyte * 4),
]

# Structure representing task information provided by CefTaskManager.
# Structure representing task information provided by CefTaskManager.
cef_task_info_t = struct__cef_task_info_t
class struct__cef_base_ref_counted_t(Structure):
    pass

struct__cef_base_ref_counted_t._pack_ = 1 # source:False
struct__cef_base_ref_counted_t._fields_ = [
    ('size', ctypes.c_uint64),
    ('add_ref', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_base_ref_counted_t))),
    ('release', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_base_ref_counted_t))),
    ('has_one_ref', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_base_ref_counted_t))),
    ('has_at_least_one_ref', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_base_ref_counted_t))),
]

cef_base_ref_counted_t = struct__cef_base_ref_counted_t
class struct__cef_base_scoped_t(Structure):
    pass

struct__cef_base_scoped_t._pack_ = 1 # source:False
struct__cef_base_scoped_t._fields_ = [
    ('size', ctypes.c_uint64),
    ('del', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_base_scoped_t))),
]

cef_base_scoped_t = struct__cef_base_scoped_t
# Structure that wraps other data value types. Complex types (binary, dictionary
# and list) will be referenced but not owned by this object. Can be used on any
# process and thread.
class struct__cef_value_t(Structure):
    pass

class struct__cef_dictionary_value_t(Structure):
    pass

class struct__cef_binary_value_t(Structure):
    pass

class struct__cef_list_value_t(Structure):
    pass

struct__cef_value_t._pack_ = 1 # source:False
struct__cef_value_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('is_owned', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_value_t))),
    ('is_equal', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_value_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_value_type_t, ctypes.POINTER(struct__cef_value_t))),
    ('get_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('get_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('get_double', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_value_t))),
    ('get_string', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('get_binary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('get_dictionary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('get_list', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('set_null', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t))),
    ('set_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.c_int32)),
    ('set_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.c_int32)),
    ('set_double', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.c_double)),
    ('set_string', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_binary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_binary_value_t))),
    ('set_dictionary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('set_list', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_list_value_t))),
]

# Structure that wraps other data value types. Complex types (binary, dictionary
# and list) will be referenced but not owned by this object. Can be used on any
# process and thread.
# Structure that wraps other data value types. Complex types (binary, dictionary
# and list) will be referenced but not owned by this object. Can be used on any
# process and thread.
cef_value_t = struct__cef_value_t
# Creates a new object.
# Creates a new object.
cef_value_create = _libraries['FIXME_STUB'].cef_value_create
cef_value_create.restype = ctypes.POINTER(struct__cef_value_t)
# cef_value_create()
cef_value_create.argtypes = []
# Structure representing a binary value. Can be used on any process and thread.
# Structure representing a binary value. Can be used on any process and thread.
struct__cef_binary_value_t._pack_ = 1 # source:False
struct__cef_binary_value_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_binary_value_t))),
    ('is_owned', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_binary_value_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_binary_value_t), ctypes.POINTER(struct__cef_binary_value_t))),
    ('is_equal', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_binary_value_t), ctypes.POINTER(struct__cef_binary_value_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_binary_value_t))),
    ('get_raw_data', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_binary_value_t))),
    ('get_size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_binary_value_t))),
    ('get_data', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_binary_value_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.c_uint64)),
]

cef_binary_value_t = struct__cef_binary_value_t
# Creates a new object that is not owned by any other object. The specified
# |data| will be copied.
# Creates a new object that is not owned by any other object. The specified
# |data| will be copied.
cef_binary_value_create = _libraries['FIXME_STUB'].cef_binary_value_create
cef_binary_value_create.restype = ctypes.POINTER(struct__cef_binary_value_t)
# cef_binary_value_create(data, data_size)
cef_binary_value_create.argtypes = [ctypes.POINTER(None), size_t]
# Structure representing a dictionary value. Can be used on any process and
# thread.
# Structure representing a dictionary value. Can be used on any process and
# thread.
struct__cef_dictionary_value_t._pack_ = 1 # source:False
struct__cef_dictionary_value_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('is_owned', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('is_equal', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.c_int32)),
    ('get_size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('clear', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('has_key', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_keys', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('remove', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_value_type_t, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_double', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_string', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_binary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_dictionary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_list', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_value_t))),
    ('set_null', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('set_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('set_double', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_double)),
    ('set_string', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_binary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_binary_value_t))),
    ('set_dictionary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('set_list', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_list_value_t))),
]

cef_dictionary_value_t = struct__cef_dictionary_value_t
# Creates a new object that is not owned by any other object.
# Creates a new object that is not owned by any other object.
cef_dictionary_value_create = _libraries['FIXME_STUB'].cef_dictionary_value_create
cef_dictionary_value_create.restype = ctypes.POINTER(struct__cef_dictionary_value_t)
# cef_dictionary_value_create()
cef_dictionary_value_create.argtypes = []
# Structure representing a list value. Can be used on any process and thread.
# Structure representing a list value. Can be used on any process and thread.
struct__cef_list_value_t._pack_ = 1 # source:False
struct__cef_list_value_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t))),
    ('is_owned', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.POINTER(struct__cef_list_value_t))),
    ('is_equal', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.POINTER(struct__cef_list_value_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t))),
    ('set_size', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t))),
    ('clear', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t))),
    ('remove', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_value_type_t, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_double', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_string', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_binary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_dictionary', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('get_list', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('set_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_value_t))),
    ('set_null', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64)),
    ('set_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.c_int32)),
    ('set_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.c_int32)),
    ('set_double', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.c_double)),
    ('set_string', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_binary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_binary_value_t))),
    ('set_dictionary', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('set_list', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_list_value_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_list_value_t))),
]

cef_list_value_t = struct__cef_list_value_t
# Creates a new object that is not owned by any other object.
# Creates a new object that is not owned by any other object.
cef_list_value_create = _libraries['FIXME_STUB'].cef_list_value_create
cef_list_value_create.restype = ctypes.POINTER(struct__cef_list_value_t)
# cef_list_value_create()
cef_list_value_create.argtypes = []
# Implement this structure to receive accessibility notification when
# accessibility events have been registered. The functions of this structure
# will be called on the UI thread.
class struct__cef_accessibility_handler_t(Structure):
    pass

struct__cef_accessibility_handler_t._pack_ = 1 # source:False
struct__cef_accessibility_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_accessibility_tree_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_accessibility_handler_t), ctypes.POINTER(struct__cef_value_t))),
    ('on_accessibility_location_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_accessibility_handler_t), ctypes.POINTER(struct__cef_value_t))),
]

# Implement this structure to receive accessibility notification when
# accessibility events have been registered. The functions of this structure
# will be called on the UI thread.
# Implement this structure to receive accessibility notification when
# accessibility events have been registered. The functions of this structure
# will be called on the UI thread.
cef_accessibility_handler_t = struct__cef_accessibility_handler_t
# Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
# functions of this structure will be called on the browser process UI thread.
class struct__cef_dev_tools_message_observer_t(Structure):
    pass

class struct__cef_browser_t(Structure):
    pass

struct__cef_dev_tools_message_observer_t._pack_ = 1 # source:False
struct__cef_dev_tools_message_observer_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_dev_tools_message', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dev_tools_message_observer_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('on_dev_tools_method_result', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_dev_tools_message_observer_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(None), ctypes.c_uint64)),
    ('on_dev_tools_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_dev_tools_message_observer_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('on_dev_tools_agent_attached', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_dev_tools_message_observer_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_dev_tools_agent_detached', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_dev_tools_message_observer_t), ctypes.POINTER(struct__cef_browser_t))),
]

# Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
# functions of this structure will be called on the browser process UI thread.
# Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
# functions of this structure will be called on the browser process UI thread.
cef_dev_tools_message_observer_t = struct__cef_dev_tools_message_observer_t
# Container for a single image represented at different scale factors. All image
# representations should be the same size in density independent pixel (DIP)
# units. For example, if the image at scale factor 1.0 is 100x100 pixels then
# the image at scale factor 2.0 should be 200x200 pixels -- both images will
# display with a DIP size of 100x100 units. The functions of this structure can
# be called on any browser process thread.
class struct__cef_image_t(Structure):
    pass

struct__cef_image_t._pack_ = 1 # source:False
struct__cef_image_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_empty', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.POINTER(struct__cef_image_t))),
    ('add_bitmap', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.c_int32, ctypes.c_int32, c__EA_cef_color_type_t, c__EA_cef_alpha_type_t, ctypes.POINTER(None), ctypes.c_uint64)),
    ('add_png', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.POINTER(None), ctypes.c_uint64)),
    ('add_jpeg', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.POINTER(None), ctypes.c_uint64)),
    ('get_width', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_image_t))),
    ('get_height', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_image_t))),
    ('has_representation', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float)),
    ('remove_representation', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float)),
    ('get_representation_info', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.POINTER(ctypes.c_float), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('get_as_bitmap', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, c__EA_cef_color_type_t, c__EA_cef_alpha_type_t, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('get_as_png', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('get_as_jpeg', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_image_t), ctypes.c_float, ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
]

# Container for a single image represented at different scale factors. All image
# representations should be the same size in density independent pixel (DIP)
# units. For example, if the image at scale factor 1.0 is 100x100 pixels then
# the image at scale factor 2.0 should be 200x200 pixels -- both images will
# display with a DIP size of 100x100 units. The functions of this structure can
# be called on any browser process thread.
# Container for a single image represented at different scale factors. All image
# representations should be the same size in density independent pixel (DIP)
# units. For example, if the image at scale factor 1.0 is 100x100 pixels then
# the image at scale factor 2.0 should be 200x200 pixels -- both images will
# display with a DIP size of 100x100 units. The functions of this structure can
# be called on any browser process thread.
cef_image_t = struct__cef_image_t
# Create a new cef_image_t. It will initially be NULL. Use the Add*() functions
# to add representations at different scale factors.
# Create a new cef_image_t. It will initially be NULL. Use the Add*() functions
# to add representations at different scale factors.
cef_image_create = _libraries['FIXME_STUB'].cef_image_create
cef_image_create.restype = ctypes.POINTER(struct__cef_image_t)
# cef_image_create()
cef_image_create.argtypes = []
# Structure the client can implement to provide a custom stream reader. The
# functions of this structure may be called on any thread.
class struct__cef_read_handler_t(Structure):
    pass

struct__cef_read_handler_t._pack_ = 1 # source:False
struct__cef_read_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('read', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_read_handler_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.c_uint64)),
    ('seek', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_read_handler_t), ctypes.c_int64, ctypes.c_int32)),
    ('tell', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_read_handler_t))),
    ('eof', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_read_handler_t))),
    ('may_block', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_read_handler_t))),
]

# Structure the client can implement to provide a custom stream reader. The
# functions of this structure may be called on any thread.
# Structure the client can implement to provide a custom stream reader. The
# functions of this structure may be called on any thread.
cef_read_handler_t = struct__cef_read_handler_t
# Structure used to read data from a stream. The functions of this structure may
# be called on any thread.
class struct__cef_stream_reader_t(Structure):
    pass

struct__cef_stream_reader_t._pack_ = 1 # source:False
struct__cef_stream_reader_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('read', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_stream_reader_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.c_uint64)),
    ('seek', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_reader_t), ctypes.c_int64, ctypes.c_int32)),
    ('tell', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_stream_reader_t))),
    ('eof', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_reader_t))),
    ('may_block', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_reader_t))),
]

# Structure used to read data from a stream. The functions of this structure may
# be called on any thread.
# Structure used to read data from a stream. The functions of this structure may
# be called on any thread.
cef_stream_reader_t = struct__cef_stream_reader_t
# Create a new cef_stream_reader_t object from a file.
# Create a new cef_stream_reader_t object from a file.
cef_stream_reader_create_for_file = _libraries['FIXME_STUB'].cef_stream_reader_create_for_file
cef_stream_reader_create_for_file.restype = ctypes.POINTER(struct__cef_stream_reader_t)
# cef_stream_reader_create_for_file(fileName)
cef_stream_reader_create_for_file.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Create a new cef_stream_reader_t object from data.
# Create a new cef_stream_reader_t object from data.
cef_stream_reader_create_for_data = _libraries['FIXME_STUB'].cef_stream_reader_create_for_data
cef_stream_reader_create_for_data.restype = ctypes.POINTER(struct__cef_stream_reader_t)
# cef_stream_reader_create_for_data(data, size)
cef_stream_reader_create_for_data.argtypes = [ctypes.POINTER(None), size_t]
# Create a new cef_stream_reader_t object from a custom handler.
# Create a new cef_stream_reader_t object from a custom handler.
cef_stream_reader_create_for_handler = _libraries['FIXME_STUB'].cef_stream_reader_create_for_handler
cef_stream_reader_create_for_handler.restype = ctypes.POINTER(struct__cef_stream_reader_t)
# cef_stream_reader_create_for_handler(handler)
cef_stream_reader_create_for_handler.argtypes = [ctypes.POINTER(struct__cef_read_handler_t)]
# Structure the client can implement to provide a custom stream writer. The
# functions of this structure may be called on any thread.
class struct__cef_write_handler_t(Structure):
    pass

struct__cef_write_handler_t._pack_ = 1 # source:False
struct__cef_write_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('write', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_write_handler_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.c_uint64)),
    ('seek', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_write_handler_t), ctypes.c_int64, ctypes.c_int32)),
    ('tell', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_write_handler_t))),
    ('flush', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_write_handler_t))),
    ('may_block', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_write_handler_t))),
]

# Structure the client can implement to provide a custom stream writer. The
# functions of this structure may be called on any thread.
# Structure the client can implement to provide a custom stream writer. The
# functions of this structure may be called on any thread.
cef_write_handler_t = struct__cef_write_handler_t
# Structure used to write data to a stream. The functions of this structure may
# be called on any thread.
class struct__cef_stream_writer_t(Structure):
    pass

struct__cef_stream_writer_t._pack_ = 1 # source:False
struct__cef_stream_writer_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('write', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_stream_writer_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.c_uint64)),
    ('seek', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_writer_t), ctypes.c_int64, ctypes.c_int32)),
    ('tell', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_stream_writer_t))),
    ('flush', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_writer_t))),
    ('may_block', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_stream_writer_t))),
]

# Structure used to write data to a stream. The functions of this structure may
# be called on any thread.
# Structure used to write data to a stream. The functions of this structure may
# be called on any thread.
cef_stream_writer_t = struct__cef_stream_writer_t
# Create a new cef_stream_writer_t object for a file.
# Create a new cef_stream_writer_t object for a file.
cef_stream_writer_create_for_file = _libraries['FIXME_STUB'].cef_stream_writer_create_for_file
cef_stream_writer_create_for_file.restype = ctypes.POINTER(struct__cef_stream_writer_t)
# cef_stream_writer_create_for_file(fileName)
cef_stream_writer_create_for_file.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Create a new cef_stream_writer_t object for a custom handler.
# Create a new cef_stream_writer_t object for a custom handler.
cef_stream_writer_create_for_handler = _libraries['FIXME_STUB'].cef_stream_writer_create_for_handler
cef_stream_writer_create_for_handler.restype = ctypes.POINTER(struct__cef_stream_writer_t)
# cef_stream_writer_create_for_handler(handler)
cef_stream_writer_create_for_handler.argtypes = [ctypes.POINTER(struct__cef_write_handler_t)]
# Structure used to represent drag data. The functions of this structure may be
# called on any thread.
class struct__cef_drag_data_t(Structure):
    pass

struct__cef_drag_data_t._pack_ = 1 # source:False
struct__cef_drag_data_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('clone', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t))),
    ('is_link', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t))),
    ('is_fragment', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t))),
    ('is_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_link_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_link_title', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_link_metadata', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_fragment_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_fragment_html', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_fragment_base_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_file_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_file_contents', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_stream_writer_t))),
    ('get_file_names', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('get_file_paths', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('set_link_url', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_link_title', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_link_metadata', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_fragment_text', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_fragment_html', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_fragment_base_url', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('reset_file_contents', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t))),
    ('add_file', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('clear_filenames', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_image', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_drag_data_t))),
    ('get_image_hotspot', ctypes.CFUNCTYPE(struct__cef_point_t, ctypes.POINTER(struct__cef_drag_data_t))),
    ('has_image', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_data_t))),
]

# Structure used to represent drag data. The functions of this structure may be
# called on any thread.
# Structure used to represent drag data. The functions of this structure may be
# called on any thread.
cef_drag_data_t = struct__cef_drag_data_t
# Create a new cef_drag_data_t object.
# Create a new cef_drag_data_t object.
cef_drag_data_create = _libraries['FIXME_STUB'].cef_drag_data_create
cef_drag_data_create.restype = ctypes.POINTER(struct__cef_drag_data_t)
# cef_drag_data_create()
cef_drag_data_create.argtypes = []
# Structure to implement for visiting the DOM. The functions of this structure
# will be called on the render process main thread.
class struct__cef_domvisitor_t(Structure):
    pass

class struct__cef_domdocument_t(Structure):
    pass

struct__cef_domvisitor_t._pack_ = 1 # source:False
struct__cef_domvisitor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('visit', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_domvisitor_t), ctypes.POINTER(struct__cef_domdocument_t))),
]

# Structure to implement for visiting the DOM. The functions of this structure
# will be called on the render process main thread.
# Structure to implement for visiting the DOM. The functions of this structure
# will be called on the render process main thread.
cef_domvisitor_t = struct__cef_domvisitor_t
# Structure used to represent a DOM document. The functions of this structure
# should only be called on the render process main thread thread.
# Structure used to represent a DOM document. The functions of this structure
# should only be called on the render process main thread thread.
class struct__cef_domnode_t(Structure):
    pass

struct__cef_domdocument_t._pack_ = 1 # source:False
struct__cef_domdocument_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_dom_document_type_t, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_document', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_body', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_head', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_title', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_element_by_id', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_focused_node', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('has_selection', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_selection_start_offset', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_selection_end_offset', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_selection_as_markup', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_selection_as_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_base_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t))),
    ('get_complete_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domdocument_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

cef_domdocument_t = struct__cef_domdocument_t
# Structure used to represent a DOM node. The functions of this structure should
# only be called on the render process main thread.
# Structure used to represent a DOM node. The functions of this structure should
# only be called on the render process main thread.
struct__cef_domnode_t._pack_ = 1 # source:False
struct__cef_domnode_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_dom_node_type_t, ctypes.POINTER(struct__cef_domnode_t))),
    ('is_text', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('is_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('is_editable', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('is_form_control_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_form_control_element_type', ctypes.CFUNCTYPE(c__EA_cef_dom_form_control_type_t, ctypes.POINTER(struct__cef_domnode_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_domnode_t))),
    ('get_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('set_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_as_markup', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_document', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_parent', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_previous_sibling', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_next_sibling', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('has_children', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_first_child', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_last_child', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_element_tag_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('has_element_attributes', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t))),
    ('has_element_attribute', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_element_attribute', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_element_attributes', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_string_map_t))),
    ('set_element_attribute', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_domnode_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_element_inner_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_domnode_t))),
    ('get_element_bounds', ctypes.CFUNCTYPE(struct__cef_rect_t, ctypes.POINTER(struct__cef_domnode_t))),
]

cef_domnode_t = struct__cef_domnode_t
# Structure that wraps platform-dependent share memory region mapping.
class struct__cef_shared_memory_region_t(Structure):
    pass

struct__cef_shared_memory_region_t._pack_ = 1 # source:False
struct__cef_shared_memory_region_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_shared_memory_region_t))),
    ('size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_shared_memory_region_t))),
    ('memory', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_shared_memory_region_t))),
]

# Structure that wraps platform-dependent share memory region mapping.
# Structure that wraps platform-dependent share memory region mapping.
cef_shared_memory_region_t = struct__cef_shared_memory_region_t
# Structure representing a message. Can be used on any process and thread.
class struct__cef_process_message_t(Structure):
    pass

struct__cef_process_message_t._pack_ = 1 # source:False
struct__cef_process_message_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_process_message_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_process_message_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_process_message_t))),
    ('get_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_process_message_t))),
    ('get_argument_list', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_process_message_t))),
    ('get_shared_memory_region', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_process_message_t))),
]

# Structure representing a message. Can be used on any process and thread.
# Structure representing a message. Can be used on any process and thread.
cef_process_message_t = struct__cef_process_message_t
# Create a new cef_process_message_t object with the specified name.
# Create a new cef_process_message_t object with the specified name.
cef_process_message_create = _libraries['FIXME_STUB'].cef_process_message_create
cef_process_message_create.restype = ctypes.POINTER(struct__cef_process_message_t)
# cef_process_message_create(name)
cef_process_message_create.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Structure used to represent a web request. The functions of this structure may
# be called on any thread.
class struct__cef_request_t(Structure):
    pass

class struct__cef_post_data_t(Structure):
    pass

struct__cef_request_t._pack_ = 1 # source:False
struct__cef_request_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_t))),
    ('get_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
    ('set_url', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_method', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
    ('set_method', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_referrer', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_referrer_policy_t)),
    ('get_referrer_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
    ('get_referrer_policy', ctypes.CFUNCTYPE(c__EA_cef_referrer_policy_t, ctypes.POINTER(struct__cef_request_t))),
    ('get_post_data', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
    ('set_post_data', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_post_data_t))),
    ('get_header_map', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_multimap_t))),
    ('set_header_map', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_multimap_t))),
    ('get_header_by_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_header_by_name', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('set', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_post_data_t), ctypes.POINTER(struct__cef_string_multimap_t))),
    ('get_flags', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_t))),
    ('set_flags', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.c_int32)),
    ('get_first_party_for_cookies', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
    ('set_first_party_for_cookies', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_resource_type', ctypes.CFUNCTYPE(c__EA_cef_resource_type_t, ctypes.POINTER(struct__cef_request_t))),
    ('get_transition_type', ctypes.CFUNCTYPE(c__EA_cef_transition_type_t, ctypes.POINTER(struct__cef_request_t))),
    ('get_identifier', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_t))),
]

# Structure used to represent a web request. The functions of this structure may
# be called on any thread.
# Structure used to represent a web request. The functions of this structure may
# be called on any thread.
cef_request_t = struct__cef_request_t
# Create a new cef_request_t object.
# Create a new cef_request_t object.
cef_request_create = _libraries['FIXME_STUB'].cef_request_create
cef_request_create.restype = ctypes.POINTER(struct__cef_request_t)
# cef_request_create()
cef_request_create.argtypes = []
# Structure used to represent post data for a web request. The functions of this
# structure may be called on any thread.
# Structure used to represent post data for a web request. The functions of this
# structure may be called on any thread.
class struct__cef_post_data_element_t(Structure):
    pass

struct__cef_post_data_t._pack_ = 1 # source:False
struct__cef_post_data_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_post_data_t))),
    ('has_excluded_elements', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_post_data_t))),
    ('get_element_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_post_data_t))),
    ('get_elements', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_post_data_t), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.POINTER(struct__cef_post_data_element_t)))),
    ('remove_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_post_data_t), ctypes.POINTER(struct__cef_post_data_element_t))),
    ('add_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_post_data_t), ctypes.POINTER(struct__cef_post_data_element_t))),
    ('remove_elements', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_post_data_t))),
]

cef_post_data_t = struct__cef_post_data_t
# Create a new cef_post_data_t object.
# Create a new cef_post_data_t object.
cef_post_data_create = _libraries['FIXME_STUB'].cef_post_data_create
cef_post_data_create.restype = ctypes.POINTER(struct__cef_post_data_t)
# cef_post_data_create()
cef_post_data_create.argtypes = []
# Structure used to represent a single element in the request post data. The
# functions of this structure may be called on any thread.
# Structure used to represent a single element in the request post data. The
# functions of this structure may be called on any thread.
struct__cef_post_data_element_t._pack_ = 1 # source:False
struct__cef_post_data_element_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_post_data_element_t))),
    ('set_to_empty', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_post_data_element_t))),
    ('set_to_file', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_post_data_element_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_to_bytes', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_post_data_element_t), ctypes.c_uint64, ctypes.POINTER(None))),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_postdataelement_type_t, ctypes.POINTER(struct__cef_post_data_element_t))),
    ('get_file', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_post_data_element_t))),
    ('get_bytes_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_post_data_element_t))),
    ('get_bytes', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_post_data_element_t), ctypes.c_uint64, ctypes.POINTER(None))),
]

cef_post_data_element_t = struct__cef_post_data_element_t
# Create a new cef_post_data_element_t object.
# Create a new cef_post_data_element_t object.
cef_post_data_element_create = _libraries['FIXME_STUB'].cef_post_data_element_create
cef_post_data_element_create.restype = ctypes.POINTER(struct__cef_post_data_element_t)
# cef_post_data_element_create()
cef_post_data_element_create.argtypes = []
# Implement this structure to receive string values asynchronously.
class struct__cef_string_visitor_t(Structure):
    pass

struct__cef_string_visitor_t._pack_ = 1 # source:False
struct__cef_string_visitor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('visit', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_string_visitor_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to receive string values asynchronously.
# Implement this structure to receive string values asynchronously.
cef_string_visitor_t = struct__cef_string_visitor_t
# Structure used to represent the browser process aspects of a browser. The
# functions of this structure can only be called in the browser process. They
# may be called on any thread in that process unless otherwise indicated in the
# comments.
class struct__cef_browser_host_t(Structure):
    pass

class struct__cef_pdf_print_callback_t(Structure):
    pass

class struct__cef_registration_t(Structure):
    pass

class struct__cef_navigation_entry_t(Structure):
    pass

class struct__cef_client_t(Structure):
    pass

class struct__cef_run_file_dialog_callback_t(Structure):
    pass

class struct__cef_download_image_callback_t(Structure):
    pass

class struct__cef_request_context_t(Structure):
    pass

class struct__cef_navigation_entry_visitor_t(Structure):
    pass

struct__cef_browser_host_t._pack_ = 1 # source:False
struct__cef_browser_host_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_browser', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('close_browser', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('try_close_browser', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('is_ready_to_be_closed', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('set_focus', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('get_window_handle', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_opener_window_handle', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_opener_identifier', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('has_view', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_client', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_request_context', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('can_zoom', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t), c__EA_cef_zoom_command_t)),
    ('zoom', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), c__EA_cef_zoom_command_t)),
    ('get_default_zoom_level', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_zoom_level', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_browser_host_t))),
    ('set_zoom_level', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_double)),
    ('run_file_dialog', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), c__EA_cef_file_dialog_mode_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_list_t), ctypes.POINTER(struct__cef_run_file_dialog_callback_t))),
    ('start_download', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('download_image', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.c_uint32, ctypes.c_int32, ctypes.POINTER(struct__cef_download_image_callback_t))),
    ('print', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('print_to_pdf', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_pdf_print_settings_t), ctypes.POINTER(struct__cef_pdf_print_callback_t))),
    ('find', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)),
    ('stop_finding', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('show_dev_tools', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_window_info_t), ctypes.POINTER(struct__cef_client_t), ctypes.POINTER(struct__cef_browser_settings_t), ctypes.POINTER(struct__cef_point_t))),
    ('close_dev_tools', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('has_dev_tools', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('send_dev_tools_message', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('execute_dev_tools_method', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('add_dev_tools_message_observer', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_dev_tools_message_observer_t))),
    ('get_navigation_entries', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_navigation_entry_visitor_t), ctypes.c_int32)),
    ('replace_misspelling', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('add_word_to_dictionary', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('is_window_rendering_disabled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('was_resized', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('was_hidden', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('notify_screen_info_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('invalidate', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), c__EA_cef_paint_element_type_t)),
    ('send_external_begin_frame', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('send_key_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_key_event_t))),
    ('send_mouse_click_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_mouse_event_t), c__EA_cef_mouse_button_type_t, ctypes.c_int32, ctypes.c_int32)),
    ('send_mouse_move_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_mouse_event_t), ctypes.c_int32)),
    ('send_mouse_wheel_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_mouse_event_t), ctypes.c_int32, ctypes.c_int32)),
    ('send_touch_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_touch_event_t))),
    ('send_capture_lost_event', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('notify_move_or_resize_started', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_windowless_frame_rate', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('set_windowless_frame_rate', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('ime_set_composition', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_composition_underline_t), ctypes.POINTER(struct__cef_range_t), ctypes.POINTER(struct__cef_range_t))),
    ('ime_commit_text', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_range_t), ctypes.c_int32)),
    ('ime_finish_composing_text', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('ime_cancel_composition', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('drag_target_drag_enter', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_drag_data_t), ctypes.POINTER(struct__cef_mouse_event_t), c__EA_cef_drag_operations_mask_t)),
    ('drag_target_drag_over', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_mouse_event_t), c__EA_cef_drag_operations_mask_t)),
    ('drag_target_drag_leave', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('drag_target_drop', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.POINTER(struct__cef_mouse_event_t))),
    ('drag_source_ended_at', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32, ctypes.c_int32, c__EA_cef_drag_operations_mask_t)),
    ('drag_source_system_drag_ended', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_visible_navigation_entry', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_host_t))),
    ('set_accessibility_state', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), c__EA_cef_state_t)),
    ('set_auto_resize_enabled', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32, ctypes.POINTER(struct__cef_size_t), ctypes.POINTER(struct__cef_size_t))),
    ('set_audio_muted', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('is_audio_muted', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('is_fullscreen', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('exit_fullscreen', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('can_execute_chrome_command', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32)),
    ('execute_chrome_command', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_host_t), ctypes.c_int32, c__EA_cef_window_open_disposition_t)),
    ('is_render_process_unresponsive', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_host_t))),
    ('get_runtime_style', ctypes.CFUNCTYPE(c__EA_cef_runtime_style_t, ctypes.POINTER(struct__cef_browser_host_t))),
]

# Implement this structure to provide handler implementations.
class struct__cef_jsdialog_handler_t(Structure):
    pass

class struct__cef_render_handler_t(Structure):
    pass

class struct__cef_print_handler_t(Structure):
    pass

class struct__cef_frame_handler_t(Structure):
    pass

class struct__cef_display_handler_t(Structure):
    pass

class struct__cef_permission_handler_t(Structure):
    pass

class struct__cef_dialog_handler_t(Structure):
    pass

class struct__cef_frame_t(Structure):
    pass

class struct__cef_audio_handler_t(Structure):
    pass

class struct__cef_command_handler_t(Structure):
    pass

class struct__cef_request_handler_t(Structure):
    pass

class struct__cef_life_span_handler_t(Structure):
    pass

class struct__cef_focus_handler_t(Structure):
    pass

class struct__cef_find_handler_t(Structure):
    pass

class struct__cef_download_handler_t(Structure):
    pass

class struct__cef_keyboard_handler_t(Structure):
    pass

class struct__cef_drag_handler_t(Structure):
    pass

class struct__cef_context_menu_handler_t(Structure):
    pass

class struct__cef_load_handler_t(Structure):
    pass

struct__cef_client_t._pack_ = 1 # source:False
struct__cef_client_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_audio_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_command_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_context_menu_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_dialog_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_display_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_download_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_drag_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_find_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_focus_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_frame_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_permission_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_jsdialog_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_keyboard_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_life_span_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_load_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_print_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_render_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('get_request_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_client_t))),
    ('on_process_message_received', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_client_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), c__EA_cef_process_id_t, ctypes.POINTER(struct__cef_process_message_t))),
]

# Implement this structure to handle audio events.
struct__cef_audio_handler_t._pack_ = 1 # source:False
struct__cef_audio_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_audio_parameters', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_audio_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_audio_parameters_t))),
    ('on_audio_stream_started', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_audio_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_audio_parameters_t), ctypes.c_int32)),
    ('on_audio_stream_packet', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_audio_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(ctypes.POINTER(ctypes.c_float)), ctypes.c_int32, ctypes.c_int64)),
    ('on_audio_stream_stopped', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_audio_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_audio_stream_error', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_audio_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to handle events related to commands. The functions
# of this structure will be called on the UI thread.
struct__cef_command_handler_t._pack_ = 1 # source:False
struct__cef_command_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_chrome_command', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, c__EA_cef_window_open_disposition_t)),
    ('is_chrome_app_menu_item_visible', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('is_chrome_app_menu_item_enabled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('is_chrome_page_action_icon_visible', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_handler_t), c__EA_cef_chrome_page_action_icon_type_t)),
    ('is_chrome_toolbar_button_visible', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_handler_t), c__EA_cef_chrome_toolbar_button_type_t)),
]

# Implement this structure to handle context menu events. The functions of this
# structure will be called on the UI thread.
class struct__cef_context_menu_params_t(Structure):
    pass

class struct__cef_menu_model_t(Structure):
    pass

class struct__cef_run_context_menu_callback_t(Structure):
    pass

class struct__cef_run_quick_menu_callback_t(Structure):
    pass

struct__cef_context_menu_handler_t._pack_ = 1 # source:False
struct__cef_context_menu_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_before_context_menu', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_context_menu_params_t), ctypes.POINTER(struct__cef_menu_model_t))),
    ('run_context_menu', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_context_menu_params_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.POINTER(struct__cef_run_context_menu_callback_t))),
    ('on_context_menu_command', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_context_menu_params_t), ctypes.c_int32, c__EA_cef_event_flags_t)),
    ('on_context_menu_dismissed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t))),
    ('run_quick_menu', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_point_t), ctypes.POINTER(struct__cef_size_t), c__EA_cef_quick_menu_edit_state_flags_t, ctypes.POINTER(struct__cef_run_quick_menu_callback_t))),
    ('on_quick_menu_command', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.c_int32, c__EA_cef_event_flags_t)),
    ('on_quick_menu_dismissed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_context_menu_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t))),
]

# Structure used to represent a frame in the browser window. When used in the
# browser process the functions of this structure may be called on any thread
# unless otherwise indicated in the comments. When used in the render process
# the functions of this structure may only be called on the main thread.
class struct__cef_v8context_t(Structure):
    pass

class struct__cef_urlrequest_t(Structure):
    pass

class struct__cef_urlrequest_client_t(Structure):
    pass

struct__cef_frame_t._pack_ = 1 # source:False
struct__cef_frame_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_frame_t))),
    ('undo', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('redo', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('cut', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('copy', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('paste', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('paste_and_match_style', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('del', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('select_all', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('view_source', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t))),
    ('get_source', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_visitor_t))),
    ('get_text', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_visitor_t))),
    ('load_request', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t))),
    ('load_url', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('execute_java_script', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('is_main', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_frame_t))),
    ('is_focused', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_frame_t))),
    ('get_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('get_identifier', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('get_parent', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('get_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('get_browser', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('get_v8context', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t))),
    ('visit_dom', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_domvisitor_t))),
    ('create_urlrequest', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_urlrequest_client_t))),
    ('send_process_message', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_t), c__EA_cef_process_id_t, ctypes.POINTER(struct__cef_process_message_t))),
]

# Structure representing a V8 context handle. V8 handles can only be accessed
# from the thread on which they are created. Valid threads for creating a V8
# handle include the render process main thread (TID_RENDERER) and WebWorker
# threads. A task runner for posting tasks on the associated thread can be
# retrieved via the cef_v8context_t::get_task_runner() function.
class struct__cef_v8value_t(Structure):
    pass

class struct__cef_v8exception_t(Structure):
    pass

class struct__cef_task_runner_t(Structure):
    pass

struct__cef_v8context_t._pack_ = 1 # source:False
struct__cef_v8context_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_task_runner', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8context_t))),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8context_t))),
    ('get_browser', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8context_t))),
    ('get_frame', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8context_t))),
    ('get_global', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8context_t))),
    ('enter', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8context_t))),
    ('exit', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8context_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8context_t), ctypes.POINTER(struct__cef_v8context_t))),
    ('eval', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(ctypes.POINTER(struct__cef_v8exception_t)))),
]

# Structure that asynchronously executes tasks on the associated thread. It is
# safe to call the functions of this structure on any thread.
class struct__cef_task_t(Structure):
    pass

struct__cef_task_runner_t._pack_ = 1 # source:False
struct__cef_task_runner_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_runner_t), ctypes.POINTER(struct__cef_task_runner_t))),
    ('belongs_to_current_thread', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_runner_t))),
    ('belongs_to_thread', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_runner_t), c__EA_cef_thread_id_t)),
    ('post_task', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_runner_t), ctypes.POINTER(struct__cef_task_t))),
    ('post_delayed_task', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_runner_t), ctypes.POINTER(struct__cef_task_t), ctypes.c_int64)),
]

# Implement this structure for asynchronous task execution. If the task is
# posted successfully and if the associated message loop is still running then
# the execute() function will be called on the target thread. If the task fails
# to post then the task object may be destroyed on the source thread instead of
# the target thread. For this reason be cautious when performing work in the
# task object destructor.
struct__cef_task_t._pack_ = 1 # source:False
struct__cef_task_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('execute', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_task_t))),
]

# Structure representing a V8 value handle. V8 handles can only be accessed from
# the thread on which they are created. Valid threads for creating a V8 handle
# include the render process main thread (TID_RENDERER) and WebWorker threads. A
# task runner for posting tasks on the associated thread can be retrieved via
# the cef_v8context_t::get_task_runner() function.
class struct__cef_v8handler_t(Structure):
    pass

class struct__cef_v8array_buffer_release_callback_t(Structure):
    pass

struct__cef_v8value_t._pack_ = 1 # source:False
struct__cef_v8value_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_undefined', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_null', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_bool', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_int', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_uint', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_double', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_date', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_string', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_object', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_array', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_array_buffer', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_function', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_promise', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t))),
    ('get_bool_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_int_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_uint_value', ctypes.CFUNCTYPE(ctypes.c_uint32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_double_value', ctypes.CFUNCTYPE(ctypes.c_double, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_date_value', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_string_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('is_user_created', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('has_exception', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_exception', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('clear_exception', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('will_rethrow_exceptions', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('set_rethrow_exceptions', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32)),
    ('has_value_bykey', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('has_value_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32)),
    ('delete_value_bykey', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('delete_value_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32)),
    ('get_value_bykey', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_value_byindex', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32)),
    ('set_value_bykey', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), c__EA_cef_v8_propertyattribute_t)),
    ('set_value_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('set_value_byaccessor', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_v8_propertyattribute_t)),
    ('get_keys', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('set_user_data', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_base_ref_counted_t))),
    ('get_user_data', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_externally_allocated_memory', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('adjust_externally_allocated_memory', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.c_int32)),
    ('get_array_length', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_array_buffer_release_callback', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('neuter_array_buffer', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_array_buffer_byte_length', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_array_buffer_data', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_function_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('get_function_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t))),
    ('execute_function', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)))),
    ('execute_function_with_context', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8context_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)))),
    ('resolve_promise', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t))),
    ('reject_promise', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Structure representing a V8 exception. The functions of this structure may be
# called on any render process thread.
struct__cef_v8exception_t._pack_ = 1 # source:False
struct__cef_v8exception_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_message', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_source_line', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_script_resource_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_line_number', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_start_position', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_end_position', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_start_column', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8exception_t))),
    ('get_end_column', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8exception_t))),
]

# Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.
struct__cef_v8array_buffer_release_callback_t._pack_ = 1 # source:False
struct__cef_v8array_buffer_release_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('release_buffer', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_v8array_buffer_release_callback_t), ctypes.POINTER(None))),
]

# Structure that should be implemented to handle V8 function calls. The
# functions of this structure will be called on the thread associated with the
# V8 function.
struct__cef_v8handler_t._pack_ = 1 # source:False
struct__cef_v8handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('execute', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8handler_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(struct__cef_string_utf16_t))),
]

class struct__cef_response_t(Structure):
    pass

struct__cef_urlrequest_t._pack_ = 1 # source:False
struct__cef_urlrequest_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_request', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('get_client', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('get_request_status', ctypes.CFUNCTYPE(c__EA_cef_urlrequest_status_t, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('get_request_error', ctypes.CFUNCTYPE(c__EA_cef_errorcode_t, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('get_response', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('response_was_cached', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_urlrequest_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_urlrequest_t))),
]

class struct__cef_auth_callback_t(Structure):
    pass

struct__cef_urlrequest_client_t._pack_ = 1 # source:False
struct__cef_urlrequest_client_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_request_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.POINTER(struct__cef_urlrequest_t))),
    ('on_upload_progress', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.POINTER(struct__cef_urlrequest_t), ctypes.c_int64, ctypes.c_int64)),
    ('on_download_progress', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.POINTER(struct__cef_urlrequest_t), ctypes.c_int64, ctypes.c_int64)),
    ('on_download_data', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.POINTER(struct__cef_urlrequest_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('get_auth_credentials', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_auth_callback_t))),
]

# Provides information about the context menu state. The functions of this
# structure can only be accessed on browser process the UI thread.
struct__cef_context_menu_params_t._pack_ = 1 # source:False
struct__cef_context_menu_params_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_xcoord', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_ycoord', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_type_flags', ctypes.CFUNCTYPE(c__EA_cef_context_menu_type_flags_t, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_link_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_unfiltered_link_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_source_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('has_image_contents', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_title_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_page_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_frame_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_frame_charset', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_media_type', ctypes.CFUNCTYPE(c__EA_cef_context_menu_media_type_t, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_media_state_flags', ctypes.CFUNCTYPE(c__EA_cef_context_menu_media_state_flags_t, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_selection_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_misspelled_word', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_dictionary_suggestions', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('is_editable', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('is_spell_check_enabled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('get_edit_state_flags', ctypes.CFUNCTYPE(c__EA_cef_context_menu_edit_state_flags_t, ctypes.POINTER(struct__cef_context_menu_params_t))),
    ('is_custom_menu', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_context_menu_params_t))),
]

# Supports creation and modification of menus. See cef_menu_id_t for the command
# ids that have default implementations. All user-defined command ids should be
# between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of this
# structure can only be accessed on the browser process the UI thread.
struct__cef_menu_model_t._pack_ = 1 # source:False
struct__cef_menu_model_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_sub_menu', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t))),
    ('clear', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t))),
    ('get_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t))),
    ('add_separator', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t))),
    ('add_item', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('add_check_item', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('add_radio_item', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('add_sub_menu', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('insert_separator_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('insert_item_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('insert_check_item_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('insert_radio_item_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('insert_sub_menu_at', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('remove', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('remove_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('get_index_of', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('get_command_id_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_command_id_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32)),
    ('get_label', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('get_label_at', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_label', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_label_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_menu_item_type_t, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('get_type_at', ctypes.CFUNCTYPE(c__EA_cef_menu_item_type_t, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('get_group_id', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('get_group_id_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_group_id', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.c_int32)),
    ('set_group_id_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32)),
    ('get_sub_menu', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('get_sub_menu_at', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('is_visible', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('is_visible_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_visible', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.c_int32)),
    ('set_visible_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32)),
    ('is_enabled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('is_enabled_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_enabled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.c_int32)),
    ('set_enabled_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32)),
    ('is_checked', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('is_checked_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_checked', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.c_int32)),
    ('set_checked_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32)),
    ('has_accelerator', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('has_accelerator_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('set_accelerator', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)),
    ('set_accelerator_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)),
    ('remove_accelerator', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('remove_accelerator_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64)),
    ('get_accelerator', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('get_accelerator_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_uint64, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('set_color', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, c__EA_cef_menu_color_type_t, ctypes.c_uint32)),
    ('set_color_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, c__EA_cef_menu_color_type_t, ctypes.c_uint32)),
    ('get_color', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, c__EA_cef_menu_color_type_t, ctypes.POINTER(ctypes.c_uint32))),
    ('get_color_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, c__EA_cef_menu_color_type_t, ctypes.POINTER(ctypes.c_uint32))),
    ('set_font_list', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_font_list_at', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Callback structure used for continuation of custom context menu display.
struct__cef_run_context_menu_callback_t._pack_ = 1 # source:False
struct__cef_run_context_menu_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_run_context_menu_callback_t), ctypes.c_int32, c__EA_cef_event_flags_t)),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_run_context_menu_callback_t))),
]

# Callback structure used for continuation of custom quick menu display.
struct__cef_run_quick_menu_callback_t._pack_ = 1 # source:False
struct__cef_run_quick_menu_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_run_quick_menu_callback_t), ctypes.c_int32, c__EA_cef_event_flags_t)),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_run_quick_menu_callback_t))),
]

# Implement this structure to handle dialog events. The functions of this
# structure will be called on the browser process UI thread.
class struct__cef_file_dialog_callback_t(Structure):
    pass

struct__cef_dialog_handler_t._pack_ = 1 # source:False
struct__cef_dialog_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_file_dialog', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_dialog_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_file_dialog_mode_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_list_t), ctypes.POINTER(struct__cef_string_list_t), ctypes.POINTER(struct__cef_string_list_t), ctypes.POINTER(struct__cef_file_dialog_callback_t))),
]

# Callback structure for asynchronous continuation of file dialog requests.
struct__cef_file_dialog_callback_t._pack_ = 1 # source:False
struct__cef_file_dialog_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_file_dialog_callback_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_file_dialog_callback_t))),
]

# Implement this structure to handle events related to browser display state.
# The functions of this structure will be called on the UI thread.
struct__cef_display_handler_t._pack_ = 1 # source:False
struct__cef_display_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_address_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_title_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_favicon_urlchange', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('on_fullscreen_mode_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('on_tooltip', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_status_message', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_console_message', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_log_severity_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('on_auto_resize', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_size_t))),
    ('on_loading_progress_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_double)),
    ('on_cursor_change', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(None), c__EA_cef_cursor_type_t, ctypes.POINTER(struct__cef_cursor_info_t))),
    ('on_media_access_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_display_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.c_int32)),
]

# Structure used to handle file downloads. The functions of this structure will
# called on the browser process UI thread.
class struct__cef_download_item_t(Structure):
    pass

class struct__cef_before_download_callback_t(Structure):
    pass

class struct__cef_download_item_callback_t(Structure):
    pass

struct__cef_download_handler_t._pack_ = 1 # source:False
struct__cef_download_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('can_download', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_before_download', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_download_item_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_before_download_callback_t))),
    ('on_download_updated', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_download_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_download_item_t), ctypes.POINTER(struct__cef_download_item_callback_t))),
]

# Structure used to represent a download item.
struct__cef_download_item_t._pack_ = 1 # source:False
struct__cef_download_item_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('is_in_progress', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('is_complete', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('is_canceled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('is_interrupted', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_interrupt_reason', ctypes.CFUNCTYPE(c__EA_cef_download_interrupt_reason_t, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_current_speed', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_percent_complete', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_total_bytes', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_received_bytes', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_start_time', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_end_time', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_full_path', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_id', ctypes.CFUNCTYPE(ctypes.c_uint32, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_original_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_suggested_file_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_content_disposition', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
    ('get_mime_type', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_download_item_t))),
]

# Callback structure used to asynchronously continue a download.
struct__cef_before_download_callback_t._pack_ = 1 # source:False
struct__cef_before_download_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_before_download_callback_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
]

# Callback structure used to asynchronously cancel a download.
struct__cef_download_item_callback_t._pack_ = 1 # source:False
struct__cef_download_item_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_download_item_callback_t))),
    ('pause', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_download_item_callback_t))),
    ('resume', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_download_item_callback_t))),
]

# Implement this structure to handle events related to dragging. The functions
# of this structure will be called on the UI thread.
struct__cef_drag_handler_t._pack_ = 1 # source:False
struct__cef_drag_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_drag_enter', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_drag_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_drag_data_t), c__EA_cef_drag_operations_mask_t)),
    ('on_draggable_regions_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_drag_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_draggable_region_t))),
]

# Implement this structure to handle events related to find results. The
# functions of this structure will be called on the UI thread.
struct__cef_find_handler_t._pack_ = 1 # source:False
struct__cef_find_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_find_result', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_find_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(struct__cef_rect_t), ctypes.c_int32, ctypes.c_int32)),
]

# Implement this structure to handle events related to focus. The functions of
# this structure will be called on the UI thread.
struct__cef_focus_handler_t._pack_ = 1 # source:False
struct__cef_focus_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_take_focus', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_focus_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('on_set_focus', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_focus_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_focus_source_t)),
    ('on_got_focus', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_focus_handler_t), ctypes.POINTER(struct__cef_browser_t))),
]

# Implement this structure to handle events related to cef_frame_t life span.
# The order of callbacks is:
struct__cef_frame_handler_t._pack_ = 1 # source:False
struct__cef_frame_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_frame_created', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t))),
    ('on_frame_destroyed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t))),
    ('on_frame_attached', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.c_int32)),
    ('on_frame_detached', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t))),
    ('on_main_frame_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_frame_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_frame_t))),
]

# Implement this structure to handle events related to permission requests. The
# functions of this structure will be called on the browser process UI thread.
class struct__cef_media_access_callback_t(Structure):
    pass

class struct__cef_permission_prompt_callback_t(Structure):
    pass

struct__cef_permission_handler_t._pack_ = 1 # source:False
struct__cef_permission_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_request_media_access_permission', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_permission_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_uint32, ctypes.POINTER(struct__cef_media_access_callback_t))),
    ('on_show_permission_prompt', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_permission_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_uint32, ctypes.POINTER(struct__cef_permission_prompt_callback_t))),
    ('on_dismiss_permission_prompt', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_permission_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_uint64, c__EA_cef_permission_request_result_t)),
]

# Callback structure used for asynchronous continuation of media access
# permission requests.
struct__cef_media_access_callback_t._pack_ = 1 # source:False
struct__cef_media_access_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_access_callback_t), ctypes.c_uint32)),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_access_callback_t))),
]

# Callback structure used for asynchronous continuation of permission prompts.
struct__cef_permission_prompt_callback_t._pack_ = 1 # source:False
struct__cef_permission_prompt_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_permission_prompt_callback_t), c__EA_cef_permission_request_result_t)),
]

# Implement this structure to handle events related to JavaScript dialogs. The
# functions of this structure will be called on the UI thread.
class struct__cef_jsdialog_callback_t(Structure):
    pass

struct__cef_jsdialog_handler_t._pack_ = 1 # source:False
struct__cef_jsdialog_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_jsdialog', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_jsdialog_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_jsdialog_type_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_jsdialog_callback_t), ctypes.POINTER(ctypes.c_int32))),
    ('on_before_unload_dialog', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_jsdialog_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_jsdialog_callback_t))),
    ('on_reset_dialog_state', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_jsdialog_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_dialog_closed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_jsdialog_handler_t), ctypes.POINTER(struct__cef_browser_t))),
]

# Callback structure used for asynchronous continuation of JavaScript dialog
# requests.
struct__cef_jsdialog_callback_t._pack_ = 1 # source:False
struct__cef_jsdialog_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_jsdialog_callback_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to handle events related to keyboard input. The
# functions of this structure will be called on the UI thread.
struct__cef_keyboard_handler_t._pack_ = 1 # source:False
struct__cef_keyboard_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_pre_key_event', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_keyboard_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_key_event_t), ctypes.POINTER(None), ctypes.POINTER(ctypes.c_int32))),
    ('on_key_event', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_keyboard_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_key_event_t), ctypes.POINTER(None))),
]

# Implement this structure to handle events related to browser life span. The
# functions of this structure will be called on the UI thread unless otherwise
# indicated.
struct__cef_life_span_handler_t._pack_ = 1 # source:False
struct__cef_life_span_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_before_popup', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_window_open_disposition_t, ctypes.c_int32, ctypes.POINTER(struct__cef_popup_features_t), ctypes.POINTER(struct__cef_window_info_t), ctypes.POINTER(ctypes.POINTER(struct__cef_client_t)), ctypes.POINTER(struct__cef_browser_settings_t), ctypes.POINTER(ctypes.POINTER(struct__cef_dictionary_value_t)), ctypes.POINTER(ctypes.c_int32))),
    ('on_before_popup_aborted', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('on_before_dev_tools_popup', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_window_info_t), ctypes.POINTER(ctypes.POINTER(struct__cef_client_t)), ctypes.POINTER(struct__cef_browser_settings_t), ctypes.POINTER(ctypes.POINTER(struct__cef_dictionary_value_t)), ctypes.POINTER(ctypes.c_int32))),
    ('on_after_created', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('do_close', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_before_close', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_life_span_handler_t), ctypes.POINTER(struct__cef_browser_t))),
]

# Implement this structure to handle events related to browser load status. The
# functions of this structure will be called on the browser process UI thread or
# render process main thread (TID_RENDERER).
struct__cef_load_handler_t._pack_ = 1 # source:False
struct__cef_load_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_loading_state_change', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_load_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)),
    ('on_load_start', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_load_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), c__EA_cef_transition_type_t)),
    ('on_load_end', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_load_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.c_int32)),
    ('on_load_error', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_load_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), c__EA_cef_errorcode_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to handle printing on Linux. Each browser will have
# only one print job in progress at a time. The functions of this structure will
# be called on the browser process UI thread.
class struct__cef_print_dialog_callback_t(Structure):
    pass

class struct__cef_print_settings_t(Structure):
    pass

class struct__cef_print_job_callback_t(Structure):
    pass

struct__cef_print_handler_t._pack_ = 1 # source:False
struct__cef_print_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_print_start', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_print_settings', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('on_print_dialog', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.POINTER(struct__cef_print_dialog_callback_t))),
    ('on_print_job', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_print_job_callback_t))),
    ('on_print_reset', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('get_pdf_paper_size', ctypes.CFUNCTYPE(struct__cef_size_t, ctypes.POINTER(struct__cef_print_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
]

# Structure representing print settings.
struct__cef_print_settings_t._pack_ = 1 # source:False
struct__cef_print_settings_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_orientation', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('is_landscape', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_printer_printable_area', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.POINTER(struct__cef_size_t), ctypes.POINTER(struct__cef_rect_t), ctypes.c_int32)),
    ('set_device_name', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_device_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_dpi', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('get_dpi', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_page_ranges', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_range_t))),
    ('get_page_ranges_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_print_settings_t))),
    ('get_page_ranges', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(struct__cef_range_t))),
    ('set_selection_only', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('is_selection_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_collate', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('will_collate', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_color_model', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), c__EA_cef_color_model_t)),
    ('get_color_model', ctypes.CFUNCTYPE(c__EA_cef_color_model_t, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_copies', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), ctypes.c_int32)),
    ('get_copies', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_print_settings_t))),
    ('set_duplex_mode', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_settings_t), c__EA_cef_duplex_mode_t)),
    ('get_duplex_mode', ctypes.CFUNCTYPE(c__EA_cef_duplex_mode_t, ctypes.POINTER(struct__cef_print_settings_t))),
]

# Callback structure for asynchronous continuation of print dialog requests.
struct__cef_print_dialog_callback_t._pack_ = 1 # source:False
struct__cef_print_dialog_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_dialog_callback_t), ctypes.POINTER(struct__cef_print_settings_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_dialog_callback_t))),
]

# Callback structure for asynchronous continuation of print job requests.
struct__cef_print_job_callback_t._pack_ = 1 # source:False
struct__cef_print_job_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_print_job_callback_t))),
]

# Implement this structure to handle events when window rendering is disabled.
# The functions of this structure will be called on the UI thread.
struct__cef_render_handler_t._pack_ = 1 # source:False
struct__cef_render_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_accessibility_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_render_handler_t))),
    ('get_root_screen_rect', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_rect_t))),
    ('get_view_rect', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_rect_t))),
    ('get_screen_point', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(ctypes.c_int32))),
    ('get_screen_info', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_screen_info_t))),
    ('on_popup_show', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32)),
    ('on_popup_size', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_rect_t))),
    ('on_paint', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_paint_element_type_t, ctypes.c_uint64, ctypes.POINTER(struct__cef_rect_t), ctypes.POINTER(None), ctypes.c_int32, ctypes.c_int32)),
    ('on_accelerated_paint', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_paint_element_type_t, ctypes.c_uint64, ctypes.POINTER(struct__cef_rect_t), ctypes.POINTER(struct__cef_accelerated_paint_info_t))),
    ('get_touch_handle_size', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_horizontal_alignment_t, ctypes.POINTER(struct__cef_size_t))),
    ('on_touch_handle_state_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_touch_handle_state_t))),
    ('start_dragging', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_drag_data_t), c__EA_cef_drag_operations_mask_t, ctypes.c_int32, ctypes.c_int32)),
    ('update_drag_cursor', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_drag_operations_mask_t)),
    ('on_scroll_offset_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_double, ctypes.c_double)),
    ('on_ime_composition_range_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_range_t), ctypes.c_uint64, ctypes.POINTER(struct__cef_rect_t))),
    ('on_text_selection_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_range_t))),
    ('on_virtual_keyboard_requested', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_text_input_mode_t)),
]

# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the thread indicated.
class struct__cef_unresponsive_process_callback_t(Structure):
    pass

class struct__cef_resource_request_handler_t(Structure):
    pass

class struct__cef_sslinfo_t(Structure):
    pass

class struct__cef_callback_t(Structure):
    pass

class struct__cef_x509certificate_t(Structure):
    pass

class struct__cef_select_client_certificate_callback_t(Structure):
    pass

struct__cef_request_handler_t._pack_ = 1 # source:False
struct__cef_request_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_before_browse', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.c_int32, ctypes.c_int32)),
    ('on_open_urlfrom_tab', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_window_open_disposition_t, ctypes.c_int32)),
    ('get_resource_request_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(ctypes.c_int32))),
    ('get_auth_credentials', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_auth_callback_t))),
    ('on_certificate_error', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_errorcode_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_sslinfo_t), ctypes.POINTER(struct__cef_callback_t))),
    ('on_select_client_certificate', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_x509certificate_t)), ctypes.POINTER(struct__cef_select_client_certificate_callback_t))),
    ('on_render_view_ready', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_render_process_unresponsive', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_unresponsive_process_callback_t))),
    ('on_render_process_responsive', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('on_render_process_terminated', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t), c__EA_cef_termination_status_t, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_document_available_in_main_frame', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_handler_t), ctypes.POINTER(struct__cef_browser_t))),
]

# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the IO thread unless otherwise
# indicated.
class struct__cef_resource_handler_t(Structure):
    pass

class struct__cef_response_filter_t(Structure):
    pass

class struct__cef_cookie_access_filter_t(Structure):
    pass

struct__cef_resource_request_handler_t._pack_ = 1 # source:False
struct__cef_resource_request_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_cookie_access_filter', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t))),
    ('on_before_resource_load', ctypes.CFUNCTYPE(c__EA_cef_return_value_t, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_callback_t))),
    ('get_resource_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t))),
    ('on_resource_redirect', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_resource_response', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_response_t))),
    ('get_resource_response_filter', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_response_t))),
    ('on_resource_load_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_response_t), c__EA_cef_urlrequest_status_t, ctypes.c_int64)),
    ('on_protocol_execution', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_request_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(ctypes.c_int32))),
]

# Implement this structure to filter cookies that may be sent or received from
# resource requests. The functions of this structure will be called on the IO
# thread unless otherwise indicated.
struct__cef_cookie_access_filter_t._pack_ = 1 # source:False
struct__cef_cookie_access_filter_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('can_send_cookie', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_access_filter_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_cookie_t))),
    ('can_save_cookie', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_access_filter_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_cookie_t))),
]

# Structure used to represent a web response. The functions of this structure
# may be called on any thread.
struct__cef_response_t._pack_ = 1 # source:False
struct__cef_response_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_response_t))),
    ('get_error', ctypes.CFUNCTYPE(c__EA_cef_errorcode_t, ctypes.POINTER(struct__cef_response_t))),
    ('set_error', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), c__EA_cef_errorcode_t)),
    ('get_status', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_response_t))),
    ('set_status', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.c_int32)),
    ('get_status_text', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_response_t))),
    ('set_status_text', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_mime_type', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_response_t))),
    ('set_mime_type', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_charset', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_response_t))),
    ('set_charset', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_header_by_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_header_by_name', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('get_header_map', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_multimap_t))),
    ('set_header_map', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_multimap_t))),
    ('get_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_response_t))),
    ('set_url', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Generic callback structure used for asynchronous continuation.
struct__cef_callback_t._pack_ = 1 # source:False
struct__cef_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_callback_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_callback_t))),
]

# Structure used to implement a custom request handler structure. The functions
# of this structure will be called on the IO thread unless otherwise indicated.
class struct__cef_resource_read_callback_t(Structure):
    pass

class struct__cef_resource_skip_callback_t(Structure):
    pass

struct__cef_resource_handler_t._pack_ = 1 # source:False
struct__cef_resource_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('open', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(struct__cef_callback_t))),
    ('process_request', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_callback_t))),
    ('get_response_headers', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.POINTER(struct__cef_response_t), ctypes.POINTER(ctypes.c_int64), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('skip', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.c_int64, ctypes.POINTER(ctypes.c_int64), ctypes.POINTER(struct__cef_resource_skip_callback_t))),
    ('read', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.POINTER(None), ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(struct__cef_resource_read_callback_t))),
    ('read_response', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_handler_t), ctypes.POINTER(None), ctypes.c_int32, ctypes.POINTER(ctypes.c_int32), ctypes.POINTER(struct__cef_callback_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_handler_t))),
]

# Callback for asynchronous continuation of cef_resource_handler_t::skip().
struct__cef_resource_skip_callback_t._pack_ = 1 # source:False
struct__cef_resource_skip_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_skip_callback_t), ctypes.c_int64)),
]

# Callback for asynchronous continuation of cef_resource_handler_t::read().
struct__cef_resource_read_callback_t._pack_ = 1 # source:False
struct__cef_resource_read_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resource_read_callback_t), ctypes.c_int32)),
]

# Implement this structure to filter resource response content. The functions of
# this structure will be called on the browser process IO thread.
struct__cef_response_filter_t._pack_ = 1 # source:False
struct__cef_response_filter_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('init_filter', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_response_filter_t))),
    ('filter', ctypes.CFUNCTYPE(c__EA_cef_response_filter_status_t, ctypes.POINTER(struct__cef_response_filter_t), ctypes.POINTER(None), ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(None), ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64))),
]

# Callback structure used for asynchronous continuation of authentication
# requests.
struct__cef_auth_callback_t._pack_ = 1 # source:False
struct__cef_auth_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('cont', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_auth_callback_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('cancel', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_auth_callback_t))),
]

# Structure representing SSL information.
struct__cef_sslinfo_t._pack_ = 1 # source:False
struct__cef_sslinfo_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_cert_status', ctypes.CFUNCTYPE(c__EA_cef_cert_status_t, ctypes.POINTER(struct__cef_sslinfo_t))),
    ('get_x509certificate', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_sslinfo_t))),
]

# Structure representing a X.509 certificate.
class struct__cef_x509cert_principal_t(Structure):
    pass

struct__cef_x509certificate_t._pack_ = 1 # source:False
struct__cef_x509certificate_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_subject', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_issuer', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_serial_number', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_valid_start', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_valid_expiry', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_derencoded', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_pemencoded', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_issuer_chain_size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509certificate_t))),
    ('get_derencoded_issuer_chain', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_x509certificate_t), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.POINTER(struct__cef_binary_value_t)))),
    ('get_pemencoded_issuer_chain', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_x509certificate_t), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.POINTER(struct__cef_binary_value_t)))),
]

# Structure representing the issuer or subject field of an X.509 certificate.
struct__cef_x509cert_principal_t._pack_ = 1 # source:False
struct__cef_x509cert_principal_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_display_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509cert_principal_t))),
    ('get_common_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509cert_principal_t))),
    ('get_locality_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509cert_principal_t))),
    ('get_state_or_province_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509cert_principal_t))),
    ('get_country_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_x509cert_principal_t))),
    ('get_organization_names', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_x509cert_principal_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('get_organization_unit_names', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_x509cert_principal_t), ctypes.POINTER(struct__cef_string_list_t))),
]

# Callback structure used to select a client certificate for authentication.
struct__cef_select_client_certificate_callback_t._pack_ = 1 # source:False
struct__cef_select_client_certificate_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('select', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_select_client_certificate_callback_t), ctypes.POINTER(struct__cef_x509certificate_t))),
]

# Callback structure for asynchronous handling of an unresponsive process.
struct__cef_unresponsive_process_callback_t._pack_ = 1 # source:False
struct__cef_unresponsive_process_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('wait', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_unresponsive_process_callback_t))),
    ('terminate', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_unresponsive_process_callback_t))),
]

# A request context provides request handling for a set of related browser or
# URL request objects. A request context can be specified when creating a new
# browser via the cef_browser_host_t static factory functions or when creating a
# new URL request via the cef_urlrequest_t static factory functions. Browser
# objects with different request contexts will never be hosted in the same
# render process. Browser objects with the same request context may or may not
# be hosted in the same render process depending on the process model. Browser
# objects created indirectly via the JavaScript window.open function or targeted
# links will share the same render process and the same request context as the
# source browser. When running in single-process mode there is only a single
# render process (the main process) and so all browsers created in single-
# process mode will share the same request context. This will be the first
# request context passed into a cef_browser_host_t static factory function and
# all other request context objects will be ignored.
class struct__cef_completion_callback_t(Structure):
    pass

class struct__cef_media_router_t(Structure):
    pass

class struct__cef_resolve_callback_t(Structure):
    pass

class struct__cef_scheme_handler_factory_t(Structure):
    pass

class struct__cef_cookie_manager_t(Structure):
    pass

# Manage access to preferences. Many built-in preferences are registered by
# Chromium. Custom preferences can be registered in
# cef_browser_process_handler_t::OnRegisterCustomPreferences.
class struct__cef_preference_manager_t(Structure):
    pass

struct__cef_preference_manager_t._pack_ = 1 # source:False
struct__cef_preference_manager_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('has_preference', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_preference_manager_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_preference', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_preference_manager_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_all_preferences', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_preference_manager_t), ctypes.c_int32)),
    ('can_set_preference', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_preference_manager_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_preference', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_preference_manager_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

class struct__cef_request_context_handler_t(Structure):
    pass

struct__cef_request_context_t._pack_ = 1 # source:False
struct__cef_request_context_t._fields_ = [
    ('base', struct__cef_preference_manager_t),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_request_context_t))),
    ('is_sharing_with', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_request_context_t))),
    ('is_global', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_context_t))),
    ('get_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_t))),
    ('get_cache_path', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_t))),
    ('get_cookie_manager', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_completion_callback_t))),
    ('register_scheme_handler_factory', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_scheme_handler_factory_t))),
    ('clear_scheme_handler_factories', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_request_context_t))),
    ('clear_certificate_exceptions', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_completion_callback_t))),
    ('clear_http_auth_credentials', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_completion_callback_t))),
    ('close_all_connections', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_completion_callback_t))),
    ('resolve_host', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_resolve_callback_t))),
    ('get_media_router', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_completion_callback_t))),
    ('get_website_setting', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_content_setting_types_t)),
    ('set_website_setting', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_content_setting_types_t, ctypes.POINTER(struct__cef_value_t))),
    ('get_content_setting', ctypes.CFUNCTYPE(c__EA_cef_content_setting_values_t, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_content_setting_types_t)),
    ('set_content_setting', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), c__EA_cef_content_setting_types_t, c__EA_cef_content_setting_values_t)),
    ('set_chrome_color_scheme', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_t), c__EA_cef_color_variant_t, ctypes.c_uint32)),
    ('get_chrome_color_scheme_mode', ctypes.CFUNCTYPE(c__EA_cef_color_variant_t, ctypes.POINTER(struct__cef_request_context_t))),
    ('get_chrome_color_scheme_color', ctypes.CFUNCTYPE(ctypes.c_uint32, ctypes.POINTER(struct__cef_request_context_t))),
    ('get_chrome_color_scheme_variant', ctypes.CFUNCTYPE(c__EA_cef_color_variant_t, ctypes.POINTER(struct__cef_request_context_t))),
]

# Implement this structure to provide handler implementations. The handler
# instance will not be released until all objects related to the context have
# been destroyed.
struct__cef_request_context_handler_t._pack_ = 1 # source:False
struct__cef_request_context_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_request_context_initialized', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_request_context_handler_t), ctypes.POINTER(struct__cef_request_context_t))),
    ('get_resource_request_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_request_context_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_request_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(ctypes.c_int32))),
]

# Structure used for managing cookies. The functions of this structure may be
# called on any thread unless otherwise indicated.
class struct__cef_delete_cookies_callback_t(Structure):
    pass

class struct__cef_cookie_visitor_t(Structure):
    pass

class struct__cef_set_cookie_callback_t(Structure):
    pass

struct__cef_cookie_manager_t._pack_ = 1 # source:False
struct__cef_cookie_manager_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('visit_all_cookies', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_manager_t), ctypes.POINTER(struct__cef_cookie_visitor_t))),
    ('visit_url_cookies', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_manager_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_visitor_t))),
    ('set_cookie', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_manager_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_cookie_t), ctypes.POINTER(struct__cef_set_cookie_callback_t))),
    ('delete_cookies', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_manager_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_delete_cookies_callback_t))),
    ('flush_store', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_manager_t), ctypes.POINTER(struct__cef_completion_callback_t))),
]

# Structure to implement for visiting cookie values. The functions of this
# structure will always be called on the UI thread.
struct__cef_cookie_visitor_t._pack_ = 1 # source:False
struct__cef_cookie_visitor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('visit', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_cookie_visitor_t), ctypes.POINTER(struct__cef_cookie_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(ctypes.c_int32))),
]

# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::set_cookie().
struct__cef_set_cookie_callback_t._pack_ = 1 # source:False
struct__cef_set_cookie_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_set_cookie_callback_t), ctypes.c_int32)),
]

# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::delete_cookies().
struct__cef_delete_cookies_callback_t._pack_ = 1 # source:False
struct__cef_delete_cookies_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_delete_cookies_callback_t), ctypes.c_int32)),
]

# Generic callback structure used for asynchronous completion.
struct__cef_completion_callback_t._pack_ = 1 # source:False
struct__cef_completion_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_completion_callback_t))),
]

# Structure that creates cef_resource_handler_t instances for handling scheme
# requests. The functions of this structure will always be called on the IO
# thread.
struct__cef_scheme_handler_factory_t._pack_ = 1 # source:False
struct__cef_scheme_handler_factory_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('create', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_scheme_handler_factory_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_request_t))),
]

# Callback structure for cef_request_context_t::ResolveHost.
struct__cef_resolve_callback_t._pack_ = 1 # source:False
struct__cef_resolve_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_resolve_completed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_resolve_callback_t), c__EA_cef_errorcode_t, ctypes.POINTER(struct__cef_string_list_t))),
]

# Supports discovery of and communication with media devices on the local
# network via the Cast and DIAL protocols. The functions of this structure may
# be called on any browser process thread unless otherwise indicated.
class struct__cef_media_source_t(Structure):
    pass

class struct__cef_media_sink_t(Structure):
    pass

class struct__cef_media_route_create_callback_t(Structure):
    pass

class struct__cef_media_observer_t(Structure):
    pass

struct__cef_media_router_t._pack_ = 1 # source:False
struct__cef_media_router_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('add_observer', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_router_t), ctypes.POINTER(struct__cef_media_observer_t))),
    ('get_source', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_router_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('notify_current_sinks', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_router_t))),
    ('create_route', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_router_t), ctypes.POINTER(struct__cef_media_source_t), ctypes.POINTER(struct__cef_media_sink_t), ctypes.POINTER(struct__cef_media_route_create_callback_t))),
    ('notify_current_routes', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_router_t))),
]

# Generic callback structure used for managing the lifespan of a registration.
struct__cef_registration_t._pack_ = 1 # source:False
struct__cef_registration_t._fields_ = [
    ('base', cef_base_ref_counted_t),
]

# Implemented by the client to observe MediaRouter events and registered via
# cef_media_router_t::AddObserver. The functions of this structure will be
# called on the browser process UI thread.
class struct__cef_media_route_t(Structure):
    pass

struct__cef_media_observer_t._pack_ = 1 # source:False
struct__cef_media_observer_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_sinks', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_observer_t), ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_media_sink_t)))),
    ('on_routes', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_observer_t), ctypes.c_uint64, ctypes.POINTER(ctypes.POINTER(struct__cef_media_route_t)))),
    ('on_route_state_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_observer_t), ctypes.POINTER(struct__cef_media_route_t), c__EA_cef_media_route_connection_state_t)),
    ('on_route_message_received', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_observer_t), ctypes.POINTER(struct__cef_media_route_t), ctypes.POINTER(None), ctypes.c_uint64)),
]

# Represents a sink to which media can be routed. Instances of this object are
# retrieved via cef_media_observer_t::OnSinks. The functions of this structure
# may be called on any browser process thread unless otherwise indicated.
class struct__cef_media_sink_device_info_callback_t(Structure):
    pass

struct__cef_media_sink_t._pack_ = 1 # source:False
struct__cef_media_sink_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_id', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_sink_t))),
    ('get_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_sink_t))),
    ('get_icon_type', ctypes.CFUNCTYPE(c__EA_cef_media_sink_icon_type_t, ctypes.POINTER(struct__cef_media_sink_t))),
    ('get_device_info', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_sink_t), ctypes.POINTER(struct__cef_media_sink_device_info_callback_t))),
    ('is_cast_sink', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_media_sink_t))),
    ('is_dial_sink', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_media_sink_t))),
    ('is_compatible_with', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_media_sink_t), ctypes.POINTER(struct__cef_media_source_t))),
]

# Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this
# structure will be called on the browser process UI thread.
struct__cef_media_sink_device_info_callback_t._pack_ = 1 # source:False
struct__cef_media_sink_device_info_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_media_sink_device_info', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_sink_device_info_callback_t), ctypes.POINTER(struct__cef_media_sink_device_info_t))),
]

# Represents a source from which media can be routed. Instances of this object
# are retrieved via cef_media_router_t::GetSource. The functions of this
# structure may be called on any browser process thread unless otherwise
# indicated.
struct__cef_media_source_t._pack_ = 1 # source:False
struct__cef_media_source_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_id', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_source_t))),
    ('is_cast_source', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_media_source_t))),
    ('is_dial_source', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_media_source_t))),
]

# Represents the route between a media source and sink. Instances of this object
# are created via cef_media_router_t::CreateRoute and retrieved via
# cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing
# operation. The functions of this structure may be called on any browser
# process thread unless otherwise indicated.
struct__cef_media_route_t._pack_ = 1 # source:False
struct__cef_media_route_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_id', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_route_t))),
    ('get_source', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_route_t))),
    ('get_sink', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_media_route_t))),
    ('send_route_message', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_route_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('terminate', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_route_t))),
]

# Callback structure for cef_media_router_t::CreateRoute. The functions of this
# structure will be called on the browser process UI thread.
struct__cef_media_route_create_callback_t._pack_ = 1 # source:False
struct__cef_media_route_create_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_media_route_create_finished', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_media_route_create_callback_t), c__EA_cef_media_route_create_result_t, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_media_route_t))),
]

# Callback structure for cef_browser_host_t::RunFileDialog. The functions of
# this structure will be called on the browser process UI thread.
struct__cef_run_file_dialog_callback_t._pack_ = 1 # source:False
struct__cef_run_file_dialog_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_file_dialog_dismissed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_run_file_dialog_callback_t), ctypes.POINTER(struct__cef_string_list_t))),
]

# Callback structure for cef_browser_host_t::DownloadImage. The functions of
# this structure will be called on the browser process UI thread.
struct__cef_download_image_callback_t._pack_ = 1 # source:False
struct__cef_download_image_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_download_image_finished', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_download_image_callback_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, ctypes.POINTER(struct__cef_image_t))),
]

# Callback structure for cef_browser_host_t::PrintToPDF. The functions of this
# structure will be called on the browser process UI thread.
struct__cef_pdf_print_callback_t._pack_ = 1 # source:False
struct__cef_pdf_print_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_pdf_print_finished', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_pdf_print_callback_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
]

# Callback structure for cef_browser_host_t::GetNavigationEntries. The functions
# of this structure will be called on the browser process UI thread.
struct__cef_navigation_entry_visitor_t._pack_ = 1 # source:False
struct__cef_navigation_entry_visitor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('visit', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_navigation_entry_visitor_t), ctypes.POINTER(struct__cef_navigation_entry_t), ctypes.c_int32, ctypes.c_int32, ctypes.c_int32)),
]

# Structure used to represent an entry in navigation history.
class struct__cef_sslstatus_t(Structure):
    pass

struct__cef_navigation_entry_t._pack_ = 1 # source:False
struct__cef_navigation_entry_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_display_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_original_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_title', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_transition_type', ctypes.CFUNCTYPE(c__EA_cef_transition_type_t, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('has_post_data', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_completion_time', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_http_status_code', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_navigation_entry_t))),
    ('get_sslstatus', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_navigation_entry_t))),
]

# Structure representing the SSL information for a navigation entry.
struct__cef_sslstatus_t._pack_ = 1 # source:False
struct__cef_sslstatus_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_secure_connection', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_sslstatus_t))),
    ('get_cert_status', ctypes.CFUNCTYPE(c__EA_cef_cert_status_t, ctypes.POINTER(struct__cef_sslstatus_t))),
    ('get_sslversion', ctypes.CFUNCTYPE(c__EA_cef_ssl_version_t, ctypes.POINTER(struct__cef_sslstatus_t))),
    ('get_content_status', ctypes.CFUNCTYPE(c__EA_cef_ssl_content_status_t, ctypes.POINTER(struct__cef_sslstatus_t))),
    ('get_x509certificate', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_sslstatus_t))),
]

# Structure used to represent a frame in the browser window. When used in the
# browser process the functions of this structure may be called on any thread
# unless otherwise indicated in the comments. When used in the render process
# the functions of this structure may only be called on the main thread.
# Structure used to represent a frame in the browser window. When used in the
# browser process the functions of this structure may be called on any thread
# unless otherwise indicated in the comments. When used in the render process
# the functions of this structure may only be called on the main thread.
cef_frame_t = struct__cef_frame_t
# Structure representing the issuer or subject field of an X.509 certificate.
# Structure representing the issuer or subject field of an X.509 certificate.
cef_x509cert_principal_t = struct__cef_x509cert_principal_t
# Structure representing a X.509 certificate.
# Structure representing a X.509 certificate.
cef_x509certificate_t = struct__cef_x509certificate_t
# Structure representing the SSL information for a navigation entry.
# Structure representing the SSL information for a navigation entry.
cef_sslstatus_t = struct__cef_sslstatus_t
# Structure used to represent an entry in navigation history.
# Structure used to represent an entry in navigation history.
cef_navigation_entry_t = struct__cef_navigation_entry_t
# Generic callback structure used for managing the lifespan of a registration.
# Generic callback structure used for managing the lifespan of a registration.
cef_registration_t = struct__cef_registration_t
# Generic callback structure used for asynchronous continuation.
# Generic callback structure used for asynchronous continuation.
cef_callback_t = struct__cef_callback_t
# Generic callback structure used for asynchronous completion.
# Generic callback structure used for asynchronous completion.
cef_completion_callback_t = struct__cef_completion_callback_t
# Structure used for managing cookies. The functions of this structure may be
# called on any thread unless otherwise indicated.
# Structure used for managing cookies. The functions of this structure may be
# called on any thread unless otherwise indicated.
cef_cookie_manager_t = struct__cef_cookie_manager_t
# Returns the global cookie manager. By default data will be stored at
# cef_settings_t.cache_path if specified or in memory otherwise. If |callback|
# is non-NULL it will be executed asnychronously on the UI thread after the
# manager's storage has been initialized. Using this function is equivalent to
# calling cef_request_context_t::cef_request_context_get_global_context()-
# >GetDefaultCookieManager().
# Returns the global cookie manager. By default data will be stored at
# cef_settings_t.cache_path if specified or in memory otherwise. If |callback|
# is non-NULL it will be executed asnychronously on the UI thread after the
# manager's storage has been initialized. Using this function is equivalent to
# calling cef_request_context_t::cef_request_context_get_global_context()-
# >GetDefaultCookieManager().
cef_cookie_manager_get_global_manager = _libraries['FIXME_STUB'].cef_cookie_manager_get_global_manager
cef_cookie_manager_get_global_manager.restype = ctypes.POINTER(struct__cef_cookie_manager_t)
# cef_cookie_manager_get_global_manager(callback)
cef_cookie_manager_get_global_manager.argtypes = [ctypes.POINTER(struct__cef_completion_callback_t)]
# Structure to implement for visiting cookie values. The functions of this
# structure will always be called on the UI thread.
# Structure to implement for visiting cookie values. The functions of this
# structure will always be called on the UI thread.
cef_cookie_visitor_t = struct__cef_cookie_visitor_t
# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::set_cookie().
# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::set_cookie().
cef_set_cookie_callback_t = struct__cef_set_cookie_callback_t
# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::delete_cookies().
# Structure to implement to be notified of asynchronous completion via
# cef_cookie_manager_t::delete_cookies().
cef_delete_cookies_callback_t = struct__cef_delete_cookies_callback_t
# Supports discovery of and communication with media devices on the local
# network via the Cast and DIAL protocols. The functions of this structure may
# be called on any browser process thread unless otherwise indicated.
# Supports discovery of and communication with media devices on the local
# network via the Cast and DIAL protocols. The functions of this structure may
# be called on any browser process thread unless otherwise indicated.
cef_media_router_t = struct__cef_media_router_t
# Returns the MediaRouter object associated with the global request context. If
# |callback| is non-NULL it will be executed asnychronously on the UI thread
# after the manager's storage has been initialized. Equivalent to calling
# cef_request_context_t::cef_request_context_get_global_context()-
# >get_media_router().
# Returns the MediaRouter object associated with the global request context. If
# |callback| is non-NULL it will be executed asnychronously on the UI thread
# after the manager's storage has been initialized. Equivalent to calling
# cef_request_context_t::cef_request_context_get_global_context()-
# >get_media_router().
cef_media_router_get_global = _libraries['FIXME_STUB'].cef_media_router_get_global
cef_media_router_get_global.restype = ctypes.POINTER(struct__cef_media_router_t)
# cef_media_router_get_global(callback)
cef_media_router_get_global.argtypes = [ctypes.POINTER(struct__cef_completion_callback_t)]
# Implemented by the client to observe MediaRouter events and registered via
# cef_media_router_t::AddObserver. The functions of this structure will be
# called on the browser process UI thread.
# Implemented by the client to observe MediaRouter events and registered via
# cef_media_router_t::AddObserver. The functions of this structure will be
# called on the browser process UI thread.
cef_media_observer_t = struct__cef_media_observer_t
# Represents the route between a media source and sink. Instances of this object
# are created via cef_media_router_t::CreateRoute and retrieved via
# cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing
# operation. The functions of this structure may be called on any browser
# process thread unless otherwise indicated.
# Represents the route between a media source and sink. Instances of this object
# are created via cef_media_router_t::CreateRoute and retrieved via
# cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing
# operation. The functions of this structure may be called on any browser
# process thread unless otherwise indicated.
cef_media_route_t = struct__cef_media_route_t
# Callback structure for cef_media_router_t::CreateRoute. The functions of this
# structure will be called on the browser process UI thread.
# Callback structure for cef_media_router_t::CreateRoute. The functions of this
# structure will be called on the browser process UI thread.
cef_media_route_create_callback_t = struct__cef_media_route_create_callback_t
# Represents a sink to which media can be routed. Instances of this object are
# retrieved via cef_media_observer_t::OnSinks. The functions of this structure
# may be called on any browser process thread unless otherwise indicated.
# Represents a sink to which media can be routed. Instances of this object are
# retrieved via cef_media_observer_t::OnSinks. The functions of this structure
# may be called on any browser process thread unless otherwise indicated.
cef_media_sink_t = struct__cef_media_sink_t
# Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this
# structure will be called on the browser process UI thread.
# Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this
# structure will be called on the browser process UI thread.
cef_media_sink_device_info_callback_t = struct__cef_media_sink_device_info_callback_t
# Represents a source from which media can be routed. Instances of this object
# are retrieved via cef_media_router_t::GetSource. The functions of this
# structure may be called on any browser process thread unless otherwise
# indicated.
# Represents a source from which media can be routed. Instances of this object
# are retrieved via cef_media_router_t::GetSource. The functions of this
# structure may be called on any browser process thread unless otherwise
# indicated.
cef_media_source_t = struct__cef_media_source_t
# Structure that manages custom preference registrations.
class struct__cef_preference_registrar_t(Structure):
    pass

struct__cef_preference_registrar_t._pack_ = 1 # source:False
struct__cef_preference_registrar_t._fields_ = [
    ('base', cef_base_scoped_t),
    ('add_preference', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_preference_registrar_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_value_t))),
]

# Structure that manages custom preference registrations.
# Structure that manages custom preference registrations.
cef_preference_registrar_t = struct__cef_preference_registrar_t
# Manage access to preferences. Many built-in preferences are registered by
# Chromium. Custom preferences can be registered in
# cef_browser_process_handler_t::OnRegisterCustomPreferences.
# Manage access to preferences. Many built-in preferences are registered by
# Chromium. Custom preferences can be registered in
# cef_browser_process_handler_t::OnRegisterCustomPreferences.
cef_preference_manager_t = struct__cef_preference_manager_t
# Returns the global preference manager object.
# Returns the global preference manager object.
cef_preference_manager_get_global = _libraries['FIXME_STUB'].cef_preference_manager_get_global
cef_preference_manager_get_global.restype = ctypes.POINTER(struct__cef_preference_manager_t)
# cef_preference_manager_get_global()
cef_preference_manager_get_global.argtypes = []
# Callback structure for cef_request_context_t::ResolveHost.
# Callback structure for cef_request_context_t::ResolveHost.
cef_resolve_callback_t = struct__cef_resolve_callback_t
# A request context provides request handling for a set of related browser or
# URL request objects. A request context can be specified when creating a new
# browser via the cef_browser_host_t static factory functions or when creating a
# new URL request via the cef_urlrequest_t static factory functions. Browser
# objects with different request contexts will never be hosted in the same
# render process. Browser objects with the same request context may or may not
# be hosted in the same render process depending on the process model. Browser
# objects created indirectly via the JavaScript window.open function or targeted
# links will share the same render process and the same request context as the
# source browser. When running in single-process mode there is only a single
# render process (the main process) and so all browsers created in single-
# process mode will share the same request context. This will be the first
# request context passed into a cef_browser_host_t static factory function and
# all other request context objects will be ignored.
# A request context provides request handling for a set of related browser or
# URL request objects. A request context can be specified when creating a new
# browser via the cef_browser_host_t static factory functions or when creating a
# new URL request via the cef_urlrequest_t static factory functions. Browser
# objects with different request contexts will never be hosted in the same
# render process. Browser objects with the same request context may or may not
# be hosted in the same render process depending on the process model. Browser
# objects created indirectly via the JavaScript window.open function or targeted
# links will share the same render process and the same request context as the
# source browser. When running in single-process mode there is only a single
# render process (the main process) and so all browsers created in single-
# process mode will share the same request context. This will be the first
# request context passed into a cef_browser_host_t static factory function and
# all other request context objects will be ignored.
cef_request_context_t = struct__cef_request_context_t
# Returns the global context object.
# Returns the global context object.
cef_request_context_get_global_context = _libraries['FIXME_STUB'].cef_request_context_get_global_context
cef_request_context_get_global_context.restype = ctypes.POINTER(struct__cef_request_context_t)
# cef_request_context_get_global_context()
cef_request_context_get_global_context.argtypes = []
# Creates a new context object with the specified |settings| and optional
# |handler|.
# Creates a new context object with the specified |settings| and optional
# |handler|.
cef_request_context_create_context = _libraries['FIXME_STUB'].cef_request_context_create_context
cef_request_context_create_context.restype = ctypes.POINTER(struct__cef_request_context_t)
# cef_request_context_create_context(settings, handler)
cef_request_context_create_context.argtypes = [ctypes.POINTER(struct__cef_request_context_settings_t), ctypes.POINTER(struct__cef_request_context_handler_t)]
# Creates a new context object that shares storage with |other| and uses an
# optional |handler|.
# Creates a new context object that shares storage with |other| and uses an
# optional |handler|.
cef_create_context_shared = _libraries['FIXME_STUB'].cef_create_context_shared
cef_create_context_shared.restype = ctypes.POINTER(struct__cef_request_context_t)
# cef_create_context_shared(other, handler)
cef_create_context_shared.argtypes = [ctypes.POINTER(struct__cef_request_context_t), ctypes.POINTER(struct__cef_request_context_handler_t)]
# Structure used to represent a browser. When used in the browser process the
# functions of this structure may be called on any thread unless otherwise
# indicated in the comments. When used in the render process the functions of
# this structure may only be called on the main thread.
# Structure used to represent a browser. When used in the browser process the
# functions of this structure may be called on any thread unless otherwise
# indicated in the comments. When used in the render process the functions of
# this structure may only be called on the main thread.
struct__cef_browser_t._pack_ = 1 # source:False
struct__cef_browser_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('get_host', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t))),
    ('can_go_back', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('go_back', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t))),
    ('can_go_forward', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('go_forward', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t))),
    ('is_loading', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('reload', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t))),
    ('reload_ignore_cache', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t))),
    ('stop_load', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t))),
    ('get_identifier', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('is_same', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_browser_t))),
    ('is_popup', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('has_document', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_t))),
    ('get_main_frame', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t))),
    ('get_focused_frame', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t))),
    ('get_frame_by_identifier', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_frame_by_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_frame_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_t))),
    ('get_frame_identifiers', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('get_frame_names', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_string_list_t))),
]

cef_browser_t = struct__cef_browser_t
# Callback structure for cef_browser_host_t::RunFileDialog. The functions of
# this structure will be called on the browser process UI thread.
# Callback structure for cef_browser_host_t::RunFileDialog. The functions of
# this structure will be called on the browser process UI thread.
cef_run_file_dialog_callback_t = struct__cef_run_file_dialog_callback_t
# Callback structure for cef_browser_host_t::GetNavigationEntries. The functions
# of this structure will be called on the browser process UI thread.
# Callback structure for cef_browser_host_t::GetNavigationEntries. The functions
# of this structure will be called on the browser process UI thread.
cef_navigation_entry_visitor_t = struct__cef_navigation_entry_visitor_t
# Callback structure for cef_browser_host_t::PrintToPDF. The functions of this
# structure will be called on the browser process UI thread.
# Callback structure for cef_browser_host_t::PrintToPDF. The functions of this
# structure will be called on the browser process UI thread.
cef_pdf_print_callback_t = struct__cef_pdf_print_callback_t
# Callback structure for cef_browser_host_t::DownloadImage. The functions of
# this structure will be called on the browser process UI thread.
# Callback structure for cef_browser_host_t::DownloadImage. The functions of
# this structure will be called on the browser process UI thread.
cef_download_image_callback_t = struct__cef_download_image_callback_t
# Structure used to represent the browser process aspects of a browser. The
# functions of this structure can only be called in the browser process. They
# may be called on any thread in that process unless otherwise indicated in the
# comments.
# Structure used to represent the browser process aspects of a browser. The
# functions of this structure can only be called in the browser process. They
# may be called on any thread in that process unless otherwise indicated in the
# comments.
cef_browser_host_t = struct__cef_browser_host_t
# Create a new browser using the window parameters specified by |windowInfo|.
# All values will be copied internally and the actual window (if any) will be
# created on the UI thread. If |request_context| is NULL the global request
# context will be used. This function can be called on any browser process
# thread and will not block. The optional |extra_info| parameter provides an
# opportunity to specify extra information specific to the created browser that
# will be passed to cef_render_process_handler_t::on_browser_created() in the
# render process.
# Create a new browser using the window parameters specified by |windowInfo|.
# All values will be copied internally and the actual window (if any) will be
# created on the UI thread. If |request_context| is NULL the global request
# context will be used. This function can be called on any browser process
# thread and will not block. The optional |extra_info| parameter provides an
# opportunity to specify extra information specific to the created browser that
# will be passed to cef_render_process_handler_t::on_browser_created() in the
# render process.
cef_browser_host_create_browser = _libraries['FIXME_STUB'].cef_browser_host_create_browser
cef_browser_host_create_browser.restype = ctypes.c_int32
# cef_browser_host_create_browser(windowInfo, client, url, settings, extra_info, request_context)
cef_browser_host_create_browser.argtypes = [ctypes.POINTER(struct__cef_window_info_t), ctypes.POINTER(struct__cef_client_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_browser_settings_t), ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_request_context_t)]
# Create a new browser using the window parameters specified by |windowInfo|. If
# |request_context| is NULL the global request context will be used. This
# function can only be called on the browser process UI thread. The optional
# |extra_info| parameter provides an opportunity to specify extra information
# specific to the created browser that will be passed to
# cef_render_process_handler_t::on_browser_created() in the render process.
# Create a new browser using the window parameters specified by |windowInfo|. If
# |request_context| is NULL the global request context will be used. This
# function can only be called on the browser process UI thread. The optional
# |extra_info| parameter provides an opportunity to specify extra information
# specific to the created browser that will be passed to
# cef_render_process_handler_t::on_browser_created() in the render process.
cef_browser_host_create_browser_sync = _libraries['FIXME_STUB'].cef_browser_host_create_browser_sync
cef_browser_host_create_browser_sync.restype = ctypes.POINTER(struct__cef_browser_t)
# cef_browser_host_create_browser_sync(windowInfo, client, url, settings, extra_info, request_context)
cef_browser_host_create_browser_sync.argtypes = [ctypes.POINTER(struct__cef_window_info_t), ctypes.POINTER(struct__cef_client_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_browser_settings_t), ctypes.POINTER(struct__cef_dictionary_value_t), ctypes.POINTER(struct__cef_request_context_t)]
# Returns the browser (if any) with the specified identifier.
# Returns the browser (if any) with the specified identifier.
cef_browser_host_get_browser_by_identifier = _libraries['FIXME_STUB'].cef_browser_host_get_browser_by_identifier
cef_browser_host_get_browser_by_identifier.restype = ctypes.POINTER(struct__cef_browser_t)
# cef_browser_host_get_browser_by_identifier(browser_id)
cef_browser_host_get_browser_by_identifier.argtypes = [ctypes.c_int32]
# Implement this structure to handle audio events.
# Implement this structure to handle audio events.
cef_audio_handler_t = struct__cef_audio_handler_t
# Implement this structure to handle events related to commands. The functions
# of this structure will be called on the UI thread.
# Implement this structure to handle events related to commands. The functions
# of this structure will be called on the UI thread.
cef_command_handler_t = struct__cef_command_handler_t
# Implement this structure to handle menu model events. The functions of this
# structure will be called on the browser process UI thread unless otherwise
# indicated.
class struct__cef_menu_model_delegate_t(Structure):
    pass

struct__cef_menu_model_delegate_t._pack_ = 1 # source:False
struct__cef_menu_model_delegate_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('execute_command', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32, c__EA_cef_event_flags_t)),
    ('mouse_outside_menu', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.POINTER(struct__cef_point_t))),
    ('unhandled_open_submenu', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('unhandled_close_submenu', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.c_int32)),
    ('menu_will_show', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t))),
    ('menu_closed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t))),
    ('format_label', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_menu_model_delegate_t), ctypes.POINTER(struct__cef_menu_model_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to handle menu model events. The functions of this
# structure will be called on the browser process UI thread unless otherwise
# indicated.
# Implement this structure to handle menu model events. The functions of this
# structure will be called on the browser process UI thread unless otherwise
# indicated.
cef_menu_model_delegate_t = struct__cef_menu_model_delegate_t
# Supports creation and modification of menus. See cef_menu_id_t for the command
# ids that have default implementations. All user-defined command ids should be
# between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of this
# structure can only be accessed on the browser process the UI thread.
# Supports creation and modification of menus. See cef_menu_id_t for the command
# ids that have default implementations. All user-defined command ids should be
# between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of this
# structure can only be accessed on the browser process the UI thread.
cef_menu_model_t = struct__cef_menu_model_t
# Create a new MenuModel with the specified |delegate|.
# Create a new MenuModel with the specified |delegate|.
cef_menu_model_create = _libraries['FIXME_STUB'].cef_menu_model_create
cef_menu_model_create.restype = ctypes.POINTER(struct__cef_menu_model_t)
# cef_menu_model_create(delegate)
cef_menu_model_create.argtypes = [ctypes.POINTER(struct__cef_menu_model_delegate_t)]
# Callback structure used for continuation of custom context menu display.
# Callback structure used for continuation of custom context menu display.
cef_run_context_menu_callback_t = struct__cef_run_context_menu_callback_t
# Callback structure used for continuation of custom quick menu display.
# Callback structure used for continuation of custom quick menu display.
cef_run_quick_menu_callback_t = struct__cef_run_quick_menu_callback_t
# Implement this structure to handle context menu events. The functions of this
# structure will be called on the UI thread.
# Implement this structure to handle context menu events. The functions of this
# structure will be called on the UI thread.
cef_context_menu_handler_t = struct__cef_context_menu_handler_t
# Provides information about the context menu state. The functions of this
# structure can only be accessed on browser process the UI thread.
# Provides information about the context menu state. The functions of this
# structure can only be accessed on browser process the UI thread.
cef_context_menu_params_t = struct__cef_context_menu_params_t
# Callback structure for asynchronous continuation of file dialog requests.
# Callback structure for asynchronous continuation of file dialog requests.
cef_file_dialog_callback_t = struct__cef_file_dialog_callback_t
# Implement this structure to handle dialog events. The functions of this
# structure will be called on the browser process UI thread.
# Implement this structure to handle dialog events. The functions of this
# structure will be called on the browser process UI thread.
cef_dialog_handler_t = struct__cef_dialog_handler_t
# Implement this structure to handle events related to browser display state.
# The functions of this structure will be called on the UI thread.
# Implement this structure to handle events related to browser display state.
# The functions of this structure will be called on the UI thread.
cef_display_handler_t = struct__cef_display_handler_t
# Structure used to represent a download item.
# Structure used to represent a download item.
cef_download_item_t = struct__cef_download_item_t
# Callback structure used to asynchronously continue a download.
# Callback structure used to asynchronously continue a download.
cef_before_download_callback_t = struct__cef_before_download_callback_t
# Callback structure used to asynchronously cancel a download.
# Callback structure used to asynchronously cancel a download.
cef_download_item_callback_t = struct__cef_download_item_callback_t
# Structure used to handle file downloads. The functions of this structure will
# called on the browser process UI thread.
# Structure used to handle file downloads. The functions of this structure will
# called on the browser process UI thread.
cef_download_handler_t = struct__cef_download_handler_t
# Implement this structure to handle events related to dragging. The functions
# of this structure will be called on the UI thread.
# Implement this structure to handle events related to dragging. The functions
# of this structure will be called on the UI thread.
cef_drag_handler_t = struct__cef_drag_handler_t
# Implement this structure to handle events related to find results. The
# functions of this structure will be called on the UI thread.
# Implement this structure to handle events related to find results. The
# functions of this structure will be called on the UI thread.
cef_find_handler_t = struct__cef_find_handler_t
# Implement this structure to handle events related to focus. The functions of
# this structure will be called on the UI thread.
# Implement this structure to handle events related to focus. The functions of
# this structure will be called on the UI thread.
cef_focus_handler_t = struct__cef_focus_handler_t
# Implement this structure to handle events related to cef_frame_t life span.
# The order of callbacks is:
# Implement this structure to handle events related to cef_frame_t life span.
# The order of callbacks is:
cef_frame_handler_t = struct__cef_frame_handler_t
# Callback structure used for asynchronous continuation of JavaScript dialog
# requests.
# Callback structure used for asynchronous continuation of JavaScript dialog
# requests.
cef_jsdialog_callback_t = struct__cef_jsdialog_callback_t
# Implement this structure to handle events related to JavaScript dialogs. The
# functions of this structure will be called on the UI thread.
# Implement this structure to handle events related to JavaScript dialogs. The
# functions of this structure will be called on the UI thread.
cef_jsdialog_handler_t = struct__cef_jsdialog_handler_t
# Implement this structure to handle events related to keyboard input. The
# functions of this structure will be called on the UI thread.
# Implement this structure to handle events related to keyboard input. The
# functions of this structure will be called on the UI thread.
cef_keyboard_handler_t = struct__cef_keyboard_handler_t
# Implement this structure to handle events related to browser life span. The
# functions of this structure will be called on the UI thread unless otherwise
# indicated.
# Implement this structure to handle events related to browser life span. The
# functions of this structure will be called on the UI thread unless otherwise
# indicated.
cef_life_span_handler_t = struct__cef_life_span_handler_t
# Implement this structure to handle events related to browser load status. The
# functions of this structure will be called on the browser process UI thread or
# render process main thread (TID_RENDERER).
# Implement this structure to handle events related to browser load status. The
# functions of this structure will be called on the browser process UI thread or
# render process main thread (TID_RENDERER).
cef_load_handler_t = struct__cef_load_handler_t
# Callback structure used for asynchronous continuation of media access
# permission requests.
# Callback structure used for asynchronous continuation of media access
# permission requests.
cef_media_access_callback_t = struct__cef_media_access_callback_t
# Callback structure used for asynchronous continuation of permission prompts.
# Callback structure used for asynchronous continuation of permission prompts.
cef_permission_prompt_callback_t = struct__cef_permission_prompt_callback_t
# Implement this structure to handle events related to permission requests. The
# functions of this structure will be called on the browser process UI thread.
# Implement this structure to handle events related to permission requests. The
# functions of this structure will be called on the browser process UI thread.
cef_permission_handler_t = struct__cef_permission_handler_t
# Structure representing print settings.
# Structure representing print settings.
cef_print_settings_t = struct__cef_print_settings_t
# Create a new cef_print_settings_t object.
# Create a new cef_print_settings_t object.
cef_print_settings_create = _libraries['FIXME_STUB'].cef_print_settings_create
cef_print_settings_create.restype = ctypes.POINTER(struct__cef_print_settings_t)
# cef_print_settings_create()
cef_print_settings_create.argtypes = []
# Callback structure for asynchronous continuation of print dialog requests.
# Callback structure for asynchronous continuation of print dialog requests.
cef_print_dialog_callback_t = struct__cef_print_dialog_callback_t
# Callback structure for asynchronous continuation of print job requests.
# Callback structure for asynchronous continuation of print job requests.
cef_print_job_callback_t = struct__cef_print_job_callback_t
# Implement this structure to handle printing on Linux. Each browser will have
# only one print job in progress at a time. The functions of this structure will
# be called on the browser process UI thread.
# Implement this structure to handle printing on Linux. Each browser will have
# only one print job in progress at a time. The functions of this structure will
# be called on the browser process UI thread.
cef_print_handler_t = struct__cef_print_handler_t
# Implement this structure to handle events when window rendering is disabled.
# The functions of this structure will be called on the UI thread.
# Implement this structure to handle events when window rendering is disabled.
# The functions of this structure will be called on the UI thread.
cef_render_handler_t = struct__cef_render_handler_t
# Callback structure used for asynchronous continuation of authentication
# requests.
# Callback structure used for asynchronous continuation of authentication
# requests.
cef_auth_callback_t = struct__cef_auth_callback_t
# Structure used to represent a web response. The functions of this structure
# may be called on any thread.
# Structure used to represent a web response. The functions of this structure
# may be called on any thread.
cef_response_t = struct__cef_response_t
# Create a new cef_response_t object.
# Create a new cef_response_t object.
cef_response_create = _libraries['FIXME_STUB'].cef_response_create
cef_response_create.restype = ctypes.POINTER(struct__cef_response_t)
# cef_response_create()
cef_response_create.argtypes = []
# Callback for asynchronous continuation of cef_resource_handler_t::skip().
# Callback for asynchronous continuation of cef_resource_handler_t::skip().
cef_resource_skip_callback_t = struct__cef_resource_skip_callback_t
# Callback for asynchronous continuation of cef_resource_handler_t::read().
# Callback for asynchronous continuation of cef_resource_handler_t::read().
cef_resource_read_callback_t = struct__cef_resource_read_callback_t
# Structure used to implement a custom request handler structure. The functions
# of this structure will be called on the IO thread unless otherwise indicated.
# Structure used to implement a custom request handler structure. The functions
# of this structure will be called on the IO thread unless otherwise indicated.
cef_resource_handler_t = struct__cef_resource_handler_t
# Implement this structure to filter resource response content. The functions of
# this structure will be called on the browser process IO thread.
# Implement this structure to filter resource response content. The functions of
# this structure will be called on the browser process IO thread.
cef_response_filter_t = struct__cef_response_filter_t
# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the IO thread unless otherwise
# indicated.
# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the IO thread unless otherwise
# indicated.
cef_resource_request_handler_t = struct__cef_resource_request_handler_t
# Implement this structure to filter cookies that may be sent or received from
# resource requests. The functions of this structure will be called on the IO
# thread unless otherwise indicated.
# Implement this structure to filter cookies that may be sent or received from
# resource requests. The functions of this structure will be called on the IO
# thread unless otherwise indicated.
cef_cookie_access_filter_t = struct__cef_cookie_access_filter_t
# Structure representing SSL information.
# Structure representing SSL information.
cef_sslinfo_t = struct__cef_sslinfo_t
# Returns true (1) if the certificate status represents an error.
# Returns true (1) if the certificate status represents an error.
cef_is_cert_status_error = _libraries['FIXME_STUB'].cef_is_cert_status_error
cef_is_cert_status_error.restype = ctypes.c_int32
# cef_is_cert_status_error(status)
cef_is_cert_status_error.argtypes = [cef_cert_status_t]
# Callback structure for asynchronous handling of an unresponsive process.
# Callback structure for asynchronous handling of an unresponsive process.
cef_unresponsive_process_callback_t = struct__cef_unresponsive_process_callback_t
# Callback structure used to select a client certificate for authentication.
# Callback structure used to select a client certificate for authentication.
cef_select_client_certificate_callback_t = struct__cef_select_client_certificate_callback_t
# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the thread indicated.
# Implement this structure to handle events related to browser requests. The
# functions of this structure will be called on the thread indicated.
cef_request_handler_t = struct__cef_request_handler_t
# Implement this structure to provide handler implementations.
# Implement this structure to provide handler implementations.
cef_client_t = struct__cef_client_t
# Structure used to create and/or parse command line arguments. Arguments with
# "--", "-" and, on Windows, "/" prefixes are considered switches. Switches will
# always precede any arguments without switch prefixes. Switches can optionally
# have a value specified using the "=" delimiter (e.g. "-switch=value"). An
# argument of "--" will terminate switch parsing with all subsequent tokens,
# regardless of prefix, being interpreted as non-switch arguments. Switch names
# should be lowercase ASCII and will be converted to such if necessary. Switch
# values will retain the original case and UTF8 encoding. This structure can be
# used before cef_initialize() is called.
class struct__cef_command_line_t(Structure):
    pass

struct__cef_command_line_t._pack_ = 1 # source:False
struct__cef_command_line_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_line_t))),
    ('is_read_only', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_line_t))),
    ('copy', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_command_line_t))),
    ('init_from_argv', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.c_int32, ctypes.POINTER(ctypes.POINTER(ctypes.c_char)))),
    ('init_from_string', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('reset', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t))),
    ('get_argv', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('get_command_line_string', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_command_line_t))),
    ('get_program', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_command_line_t))),
    ('set_program', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('has_switches', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_line_t))),
    ('has_switch', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_switch_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_switches', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_map_t))),
    ('append_switch', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('append_switch_with_value', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('has_arguments', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_command_line_t))),
    ('get_arguments', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_list_t))),
    ('append_argument', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('prepend_wrapper', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Structure used to create and/or parse command line arguments. Arguments with
# "--", "-" and, on Windows, "/" prefixes are considered switches. Switches will
# always precede any arguments without switch prefixes. Switches can optionally
# have a value specified using the "=" delimiter (e.g. "-switch=value"). An
# argument of "--" will terminate switch parsing with all subsequent tokens,
# regardless of prefix, being interpreted as non-switch arguments. Switch names
# should be lowercase ASCII and will be converted to such if necessary. Switch
# values will retain the original case and UTF8 encoding. This structure can be
# used before cef_initialize() is called.
# Structure used to create and/or parse command line arguments. Arguments with
# "--", "-" and, on Windows, "/" prefixes are considered switches. Switches will
# always precede any arguments without switch prefixes. Switches can optionally
# have a value specified using the "=" delimiter (e.g. "-switch=value"). An
# argument of "--" will terminate switch parsing with all subsequent tokens,
# regardless of prefix, being interpreted as non-switch arguments. Switch names
# should be lowercase ASCII and will be converted to such if necessary. Switch
# values will retain the original case and UTF8 encoding. This structure can be
# used before cef_initialize() is called.
cef_command_line_t = struct__cef_command_line_t
# Create a new cef_command_line_t instance.
# Create a new cef_command_line_t instance.
cef_command_line_create = _libraries['FIXME_STUB'].cef_command_line_create
cef_command_line_create.restype = ctypes.POINTER(struct__cef_command_line_t)
# cef_command_line_create()
cef_command_line_create.argtypes = []
# Returns the singleton global cef_command_line_t object. The returned object
# will be read-only.
# Returns the singleton global cef_command_line_t object. The returned object
# will be read-only.
cef_command_line_get_global = _libraries['FIXME_STUB'].cef_command_line_get_global
cef_command_line_get_global.restype = ctypes.POINTER(struct__cef_command_line_t)
# cef_command_line_get_global()
cef_command_line_get_global.argtypes = []
# Implement this structure to provide handler implementations. The handler
# instance will not be released until all objects related to the context have
# been destroyed.
# Implement this structure to provide handler implementations. The handler
# instance will not be released until all objects related to the context have
# been destroyed.
cef_request_context_handler_t = struct__cef_request_context_handler_t
# Structure used to implement browser process callbacks. The functions of this
# structure will be called on the browser process main thread unless otherwise
# indicated.
class struct__cef_browser_process_handler_t(Structure):
    pass

struct__cef_browser_process_handler_t._pack_ = 1 # source:False
struct__cef_browser_process_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_register_custom_preferences', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_process_handler_t), c__EA_cef_preferences_type_t, ctypes.POINTER(struct__cef_preference_registrar_t))),
    ('on_context_initialized', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_process_handler_t))),
    ('on_before_child_process_launch', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_process_handler_t), ctypes.POINTER(struct__cef_command_line_t))),
    ('on_already_running_app_relaunch', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_browser_process_handler_t), ctypes.POINTER(struct__cef_command_line_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('on_schedule_message_pump_work', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_browser_process_handler_t), ctypes.c_int64)),
    ('get_default_client', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_process_handler_t))),
    ('get_default_request_context_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_browser_process_handler_t))),
]

# Structure used to implement browser process callbacks. The functions of this
# structure will be called on the browser process main thread unless otherwise
# indicated.
# Structure used to implement browser process callbacks. The functions of this
# structure will be called on the browser process main thread unless otherwise
# indicated.
cef_browser_process_handler_t = struct__cef_browser_process_handler_t
# Implement this structure for asynchronous task execution. If the task is
# posted successfully and if the associated message loop is still running then
# the execute() function will be called on the target thread. If the task fails
# to post then the task object may be destroyed on the source thread instead of
# the target thread. For this reason be cautious when performing work in the
# task object destructor.
# Implement this structure for asynchronous task execution. If the task is
# posted successfully and if the associated message loop is still running then
# the execute() function will be called on the target thread. If the task fails
# to post then the task object may be destroyed on the source thread instead of
# the target thread. For this reason be cautious when performing work in the
# task object destructor.
cef_task_t = struct__cef_task_t
# Structure that asynchronously executes tasks on the associated thread. It is
# safe to call the functions of this structure on any thread.
# Structure that asynchronously executes tasks on the associated thread. It is
# safe to call the functions of this structure on any thread.
cef_task_runner_t = struct__cef_task_runner_t
# Returns the task runner for the current thread. Only CEF threads will have
# task runners. An NULL reference will be returned if this function is called on
# an invalid thread.
# Returns the task runner for the current thread. Only CEF threads will have
# task runners. An NULL reference will be returned if this function is called on
# an invalid thread.
cef_task_runner_get_for_current_thread = _libraries['FIXME_STUB'].cef_task_runner_get_for_current_thread
cef_task_runner_get_for_current_thread.restype = ctypes.POINTER(struct__cef_task_runner_t)
# cef_task_runner_get_for_current_thread()
cef_task_runner_get_for_current_thread.argtypes = []
# Returns the task runner for the specified CEF thread.
# Returns the task runner for the specified CEF thread.
cef_task_runner_get_for_thread = _libraries['FIXME_STUB'].cef_task_runner_get_for_thread
cef_task_runner_get_for_thread.restype = ctypes.POINTER(struct__cef_task_runner_t)
# cef_task_runner_get_for_thread(threadId)
cef_task_runner_get_for_thread.argtypes = [cef_thread_id_t]
# Returns true (1) if called on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread().
# Returns true (1) if called on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread().
cef_currently_on = _libraries['FIXME_STUB'].cef_currently_on
cef_currently_on.restype = ctypes.c_int32
# cef_currently_on(threadId)
cef_currently_on.argtypes = [cef_thread_id_t]
# Post a task for execution on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->PostTask(task).
# Post a task for execution on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->PostTask(task).
cef_post_task = _libraries['FIXME_STUB'].cef_post_task
cef_post_task.restype = ctypes.c_int32
# cef_post_task(threadId, task)
cef_post_task.argtypes = [cef_thread_id_t, ctypes.POINTER(struct__cef_task_t)]
# Post a task for delayed execution on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task, delay_ms).
# Post a task for delayed execution on the specified thread. Equivalent to using
# cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task, delay_ms).
int64_t = ctypes.c_int64
cef_post_delayed_task = _libraries['FIXME_STUB'].cef_post_delayed_task
cef_post_delayed_task.restype = ctypes.c_int32
# cef_post_delayed_task(threadId, task, delay_ms)
cef_post_delayed_task.argtypes = [cef_thread_id_t, ctypes.POINTER(struct__cef_task_t), int64_t]
# Structure representing a V8 context handle. V8 handles can only be accessed
# from the thread on which they are created. Valid threads for creating a V8
# handle include the render process main thread (TID_RENDERER) and WebWorker
# threads. A task runner for posting tasks on the associated thread can be
# retrieved via the cef_v8context_t::get_task_runner() function.
# Structure representing a V8 context handle. V8 handles can only be accessed
# from the thread on which they are created. Valid threads for creating a V8
# handle include the render process main thread (TID_RENDERER) and WebWorker
# threads. A task runner for posting tasks on the associated thread can be
# retrieved via the cef_v8context_t::get_task_runner() function.
cef_v8context_t = struct__cef_v8context_t
# Returns the current (top) context object in the V8 context stack.
# Returns the current (top) context object in the V8 context stack.
cef_v8context_get_current_context = _libraries['FIXME_STUB'].cef_v8context_get_current_context
cef_v8context_get_current_context.restype = ctypes.POINTER(struct__cef_v8context_t)
# cef_v8context_get_current_context()
cef_v8context_get_current_context.argtypes = []
# Returns the entered (bottom) context object in the V8 context stack.
# Returns the entered (bottom) context object in the V8 context stack.
cef_v8context_get_entered_context = _libraries['FIXME_STUB'].cef_v8context_get_entered_context
cef_v8context_get_entered_context.restype = ctypes.POINTER(struct__cef_v8context_t)
# cef_v8context_get_entered_context()
cef_v8context_get_entered_context.argtypes = []
# Returns true (1) if V8 is currently inside a context.
# Returns true (1) if V8 is currently inside a context.
cef_v8context_in_context = _libraries['FIXME_STUB'].cef_v8context_in_context
cef_v8context_in_context.restype = ctypes.c_int32
# cef_v8context_in_context()
cef_v8context_in_context.argtypes = []
# Structure that should be implemented to handle V8 function calls. The
# functions of this structure will be called on the thread associated with the
# V8 function.
# Structure that should be implemented to handle V8 function calls. The
# functions of this structure will be called on the thread associated with the
# V8 function.
cef_v8handler_t = struct__cef_v8handler_t
# Structure that should be implemented to handle V8 accessor calls. Accessor
# identifiers are registered by calling cef_v8value_t::set_value(). The
# functions of this structure will be called on the thread associated with the
# V8 accessor.
class struct__cef_v8accessor_t(Structure):
    pass

struct__cef_v8accessor_t._pack_ = 1 # source:False
struct__cef_v8accessor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8accessor_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8accessor_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Structure that should be implemented to handle V8 accessor calls. Accessor
# identifiers are registered by calling cef_v8value_t::set_value(). The
# functions of this structure will be called on the thread associated with the
# V8 accessor.
# Structure that should be implemented to handle V8 accessor calls. Accessor
# identifiers are registered by calling cef_v8value_t::set_value(). The
# functions of this structure will be called on the thread associated with the
# V8 accessor.
cef_v8accessor_t = struct__cef_v8accessor_t
# Structure that should be implemented to handle V8 interceptor calls. The
# functions of this structure will be called on the thread associated with the
# V8 interceptor. Interceptor's named property handlers (with first argument of
# type CefString) are called when object is indexed by string. Indexed property
# handlers (with first argument of type int) are called when object is indexed
# by integer.
class struct__cef_v8interceptor_t(Structure):
    pass

struct__cef_v8interceptor_t._pack_ = 1 # source:False
struct__cef_v8interceptor_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_byname', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8interceptor_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8interceptor_t), ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(ctypes.POINTER(struct__cef_v8value_t)), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_byname', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8interceptor_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('set_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8interceptor_t), ctypes.c_int32, ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_v8value_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Structure that should be implemented to handle V8 interceptor calls. The
# functions of this structure will be called on the thread associated with the
# V8 interceptor. Interceptor's named property handlers (with first argument of
# type CefString) are called when object is indexed by string. Indexed property
# handlers (with first argument of type int) are called when object is indexed
# by integer.
# Structure that should be implemented to handle V8 interceptor calls. The
# functions of this structure will be called on the thread associated with the
# V8 interceptor. Interceptor's named property handlers (with first argument of
# type CefString) are called when object is indexed by string. Indexed property
# handlers (with first argument of type int) are called when object is indexed
# by integer.
cef_v8interceptor_t = struct__cef_v8interceptor_t
# Structure representing a V8 exception. The functions of this structure may be
# called on any render process thread.
# Structure representing a V8 exception. The functions of this structure may be
# called on any render process thread.
cef_v8exception_t = struct__cef_v8exception_t
# Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.
# Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.
cef_v8array_buffer_release_callback_t = struct__cef_v8array_buffer_release_callback_t
# Structure representing a V8 value handle. V8 handles can only be accessed from
# the thread on which they are created. Valid threads for creating a V8 handle
# include the render process main thread (TID_RENDERER) and WebWorker threads. A
# task runner for posting tasks on the associated thread can be retrieved via
# the cef_v8context_t::get_task_runner() function.
# Structure representing a V8 value handle. V8 handles can only be accessed from
# the thread on which they are created. Valid threads for creating a V8 handle
# include the render process main thread (TID_RENDERER) and WebWorker threads. A
# task runner for posting tasks on the associated thread can be retrieved via
# the cef_v8context_t::get_task_runner() function.
cef_v8value_t = struct__cef_v8value_t
# Create a new cef_v8value_t object of type undefined.
# Create a new cef_v8value_t object of type undefined.
cef_v8value_create_undefined = _libraries['FIXME_STUB'].cef_v8value_create_undefined
cef_v8value_create_undefined.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_undefined()
cef_v8value_create_undefined.argtypes = []
# Create a new cef_v8value_t object of type null.
# Create a new cef_v8value_t object of type null.
cef_v8value_create_null = _libraries['FIXME_STUB'].cef_v8value_create_null
cef_v8value_create_null.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_null()
cef_v8value_create_null.argtypes = []
# Create a new cef_v8value_t object of type bool.
# Create a new cef_v8value_t object of type bool.
cef_v8value_create_bool = _libraries['FIXME_STUB'].cef_v8value_create_bool
cef_v8value_create_bool.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_bool(value)
cef_v8value_create_bool.argtypes = [ctypes.c_int32]
# Create a new cef_v8value_t object of type int.
# Create a new cef_v8value_t object of type int.
int32_t = ctypes.c_int32
cef_v8value_create_int = _libraries['FIXME_STUB'].cef_v8value_create_int
cef_v8value_create_int.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_int(value)
cef_v8value_create_int.argtypes = [int32_t]
# Create a new cef_v8value_t object of type unsigned int.
# Create a new cef_v8value_t object of type unsigned int.
uint32_t = ctypes.c_uint32
cef_v8value_create_uint = _libraries['FIXME_STUB'].cef_v8value_create_uint
cef_v8value_create_uint.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_uint(value)
cef_v8value_create_uint.argtypes = [uint32_t]
# Create a new cef_v8value_t object of type double.
# Create a new cef_v8value_t object of type double.
cef_v8value_create_double = _libraries['FIXME_STUB'].cef_v8value_create_double
cef_v8value_create_double.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_double(value)
cef_v8value_create_double.argtypes = [ctypes.c_double]
# Create a new cef_v8value_t object of type Date. This function should only be
# called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
# Create a new cef_v8value_t object of type Date. This function should only be
# called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
cef_v8value_create_date = _libraries['FIXME_STUB'].cef_v8value_create_date
cef_v8value_create_date.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_date(date)
cef_v8value_create_date.argtypes = [cef_basetime_t]
# Create a new cef_v8value_t object of type string.
# Create a new cef_v8value_t object of type string.
cef_v8value_create_string = _libraries['FIXME_STUB'].cef_v8value_create_string
cef_v8value_create_string.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_string(value)
cef_v8value_create_string.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Create a new cef_v8value_t object of type object with optional accessor and/or
# interceptor. This function should only be called from within the scope of a
# cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback, or
# in combination with calling enter() and exit() on a stored cef_v8context_t
# reference.
# Create a new cef_v8value_t object of type object with optional accessor and/or
# interceptor. This function should only be called from within the scope of a
# cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback, or
# in combination with calling enter() and exit() on a stored cef_v8context_t
# reference.
cef_v8value_create_object = _libraries['FIXME_STUB'].cef_v8value_create_object
cef_v8value_create_object.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_object(accessor, interceptor)
cef_v8value_create_object.argtypes = [ctypes.POINTER(struct__cef_v8accessor_t), ctypes.POINTER(struct__cef_v8interceptor_t)]
# Create a new cef_v8value_t object of type array with the specified |length|.
# If |length| is negative the returned array will have length 0. This function
# should only be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
# Create a new cef_v8value_t object of type array with the specified |length|.
# If |length| is negative the returned array will have length 0. This function
# should only be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
cef_v8value_create_array = _libraries['FIXME_STUB'].cef_v8value_create_array
cef_v8value_create_array.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_array(length)
cef_v8value_create_array.argtypes = [ctypes.c_int32]
# Create a new cef_v8value_t object of type ArrayBuffer which wraps the provided
# |buffer| of size |length| bytes. The ArrayBuffer is externalized, meaning that
# it does not own |buffer|. The caller is responsible for freeing |buffer| when
# requested via a call to cef_v8array_buffer_release_callback_t::ReleaseBuffer.
# This function should only be called from within the scope of a
# cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback, or
# in combination with calling enter() and exit() on a stored cef_v8context_t
# reference.
# Create a new cef_v8value_t object of type ArrayBuffer which wraps the provided
# |buffer| of size |length| bytes. The ArrayBuffer is externalized, meaning that
# it does not own |buffer|. The caller is responsible for freeing |buffer| when
# requested via a call to cef_v8array_buffer_release_callback_t::ReleaseBuffer.
# This function should only be called from within the scope of a
# cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback, or
# in combination with calling enter() and exit() on a stored cef_v8context_t
# reference.
cef_v8value_create_array_buffer = _libraries['FIXME_STUB'].cef_v8value_create_array_buffer
cef_v8value_create_array_buffer.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_array_buffer(buffer, length, release_callback)
cef_v8value_create_array_buffer.argtypes = [ctypes.POINTER(None), size_t, ctypes.POINTER(struct__cef_v8array_buffer_release_callback_t)]
# Create a new cef_v8value_t object of type ArrayBuffer which copies the
# provided |buffer| of size |length| bytes. This function should only be called
# from within the scope of a cef_render_process_handler_t, cef_v8handler_t or
# cef_v8accessor_t callback, or in combination with calling enter() and exit()
# on a stored cef_v8context_t reference.
# Create a new cef_v8value_t object of type ArrayBuffer which copies the
# provided |buffer| of size |length| bytes. This function should only be called
# from within the scope of a cef_render_process_handler_t, cef_v8handler_t or
# cef_v8accessor_t callback, or in combination with calling enter() and exit()
# on a stored cef_v8context_t reference.
cef_v8value_create_array_buffer_with_copy = _libraries['FIXME_STUB'].cef_v8value_create_array_buffer_with_copy
cef_v8value_create_array_buffer_with_copy.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_array_buffer_with_copy(buffer, length)
cef_v8value_create_array_buffer_with_copy.argtypes = [ctypes.POINTER(None), size_t]
# Create a new cef_v8value_t object of type function. This function should only
# be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
# Create a new cef_v8value_t object of type function. This function should only
# be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
cef_v8value_create_function = _libraries['FIXME_STUB'].cef_v8value_create_function
cef_v8value_create_function.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_function(name, handler)
cef_v8value_create_function.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8handler_t)]
# Create a new cef_v8value_t object of type Promise. This function should only
# be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
# Create a new cef_v8value_t object of type Promise. This function should only
# be called from within the scope of a cef_render_process_handler_t,
# cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
# enter() and exit() on a stored cef_v8context_t reference.
cef_v8value_create_promise = _libraries['FIXME_STUB'].cef_v8value_create_promise
cef_v8value_create_promise.restype = ctypes.POINTER(struct__cef_v8value_t)
# cef_v8value_create_promise()
cef_v8value_create_promise.argtypes = []
# Structure representing a V8 stack trace handle. V8 handles can only be
# accessed from the thread on which they are created. Valid threads for creating
# a V8 handle include the render process main thread (TID_RENDERER) and
# WebWorker threads. A task runner for posting tasks on the associated thread
# can be retrieved via the cef_v8context_t::get_task_runner() function.
class struct__cef_v8stack_trace_t(Structure):
    pass

class struct__cef_v8stack_frame_t(Structure):
    pass

struct__cef_v8stack_trace_t._pack_ = 1 # source:False
struct__cef_v8stack_trace_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_trace_t))),
    ('get_frame_count', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_trace_t))),
    ('get_frame', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8stack_trace_t), ctypes.c_int32)),
]

# Structure representing a V8 stack trace handle. V8 handles can only be
# accessed from the thread on which they are created. Valid threads for creating
# a V8 handle include the render process main thread (TID_RENDERER) and
# WebWorker threads. A task runner for posting tasks on the associated thread
# can be retrieved via the cef_v8context_t::get_task_runner() function.
# Structure representing a V8 stack trace handle. V8 handles can only be
# accessed from the thread on which they are created. Valid threads for creating
# a V8 handle include the render process main thread (TID_RENDERER) and
# WebWorker threads. A task runner for posting tasks on the associated thread
# can be retrieved via the cef_v8context_t::get_task_runner() function.
cef_v8stack_trace_t = struct__cef_v8stack_trace_t
# Returns the stack trace for the currently active context. |frame_limit| is the
# maximum number of frames that will be captured.
# Returns the stack trace for the currently active context. |frame_limit| is the
# maximum number of frames that will be captured.
cef_v8stack_trace_get_current = _libraries['FIXME_STUB'].cef_v8stack_trace_get_current
cef_v8stack_trace_get_current.restype = ctypes.POINTER(struct__cef_v8stack_trace_t)
# cef_v8stack_trace_get_current(frame_limit)
cef_v8stack_trace_get_current.argtypes = [ctypes.c_int32]
# Structure representing a V8 stack frame handle. V8 handles can only be
# accessed from the thread on which they are created. Valid threads for creating
# a V8 handle include the render process main thread (TID_RENDERER) and
# WebWorker threads. A task runner for posting tasks on the associated thread
# can be retrieved via the cef_v8context_t::get_task_runner() function.
# Structure representing a V8 stack frame handle. V8 handles can only be
# accessed from the thread on which they are created. Valid threads for creating
# a V8 handle include the render process main thread (TID_RENDERER) and
# WebWorker threads. A task runner for posting tasks on the associated thread
# can be retrieved via the cef_v8context_t::get_task_runner() function.
struct__cef_v8stack_frame_t._pack_ = 1 # source:False
struct__cef_v8stack_frame_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('get_script_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('get_script_name_or_source_url', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('get_function_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('get_line_number', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('get_column', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('is_eval', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_frame_t))),
    ('is_constructor', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_v8stack_frame_t))),
]

cef_v8stack_frame_t = struct__cef_v8stack_frame_t
# Register a new V8 extension with the specified JavaScript extension code and
# handler. Functions implemented by the handler are prototyped using the keyword
# 'native'. The calling of a native function is restricted to the scope in which
# the prototype of the native function is defined. This function may only be
# called on the render process main thread.
# Register a new V8 extension with the specified JavaScript extension code and
# handler. Functions implemented by the handler are prototyped using the keyword
# 'native'. The calling of a native function is restricted to the scope in which
# the prototype of the native function is defined. This function may only be
# called on the render process main thread.
cef_register_extension = _libraries['FIXME_STUB'].cef_register_extension
cef_register_extension.restype = ctypes.c_int32
# cef_register_extension(extension_name, javascript_code, handler)
cef_register_extension.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_v8handler_t)]
# Structure used to implement render process callbacks. The functions of this
# structure will be called on the render process main thread (TID_RENDERER)
# unless otherwise indicated.
class struct__cef_render_process_handler_t(Structure):
    pass

struct__cef_render_process_handler_t._pack_ = 1 # source:False
struct__cef_render_process_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_web_kit_initialized', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t))),
    ('on_browser_created', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_dictionary_value_t))),
    ('on_browser_destroyed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t))),
    ('get_load_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_render_process_handler_t))),
    ('on_context_created', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_v8context_t))),
    ('on_context_released', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_v8context_t))),
    ('on_uncaught_exception', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_v8context_t), ctypes.POINTER(struct__cef_v8exception_t), ctypes.POINTER(struct__cef_v8stack_trace_t))),
    ('on_focused_node_changed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), ctypes.POINTER(struct__cef_domnode_t))),
    ('on_process_message_received', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_render_process_handler_t), ctypes.POINTER(struct__cef_browser_t), ctypes.POINTER(struct__cef_frame_t), c__EA_cef_process_id_t, ctypes.POINTER(struct__cef_process_message_t))),
]

# Structure used to implement render process callbacks. The functions of this
# structure will be called on the render process main thread (TID_RENDERER)
# unless otherwise indicated.
# Structure used to implement render process callbacks. The functions of this
# structure will be called on the render process main thread (TID_RENDERER)
# unless otherwise indicated.
cef_render_process_handler_t = struct__cef_render_process_handler_t
# Structure used to implement a custom resource bundle structure. See
# CefSettings for additional options related to resource bundle loading. The
# functions of this structure may be called on multiple threads.
class struct__cef_resource_bundle_handler_t(Structure):
    pass

struct__cef_resource_bundle_handler_t._pack_ = 1 # source:False
struct__cef_resource_bundle_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_localized_string', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_bundle_handler_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_data_resource', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_bundle_handler_t), ctypes.c_int32, ctypes.POINTER(ctypes.POINTER(None)), ctypes.POINTER(ctypes.c_uint64))),
    ('get_data_resource_for_scale', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_resource_bundle_handler_t), ctypes.c_int32, c__EA_cef_scale_factor_t, ctypes.POINTER(ctypes.POINTER(None)), ctypes.POINTER(ctypes.c_uint64))),
]

# Structure used to implement a custom resource bundle structure. See
# CefSettings for additional options related to resource bundle loading. The
# functions of this structure may be called on multiple threads.
# Structure used to implement a custom resource bundle structure. See
# CefSettings for additional options related to resource bundle loading. The
# functions of this structure may be called on multiple threads.
cef_resource_bundle_handler_t = struct__cef_resource_bundle_handler_t
# Structure that manages custom scheme registrations.
class struct__cef_scheme_registrar_t(Structure):
    pass

struct__cef_scheme_registrar_t._pack_ = 1 # source:False
struct__cef_scheme_registrar_t._fields_ = [
    ('base', cef_base_scoped_t),
    ('add_custom_scheme', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_scheme_registrar_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
]

# Structure that manages custom scheme registrations.
# Structure that manages custom scheme registrations.
cef_scheme_registrar_t = struct__cef_scheme_registrar_t
# Structure that creates cef_resource_handler_t instances for handling scheme
# requests. The functions of this structure will always be called on the IO
# thread.
# Structure that creates cef_resource_handler_t instances for handling scheme
# requests. The functions of this structure will always be called on the IO
# thread.
cef_scheme_handler_factory_t = struct__cef_scheme_handler_factory_t
# Register a scheme handler factory with the global request context. An NULL
# |domain_name| value for a standard scheme will cause the factory to match all
# domain names. The |domain_name| value will be ignored for non-standard
# schemes. If |scheme_name| is a built-in scheme and no handler is returned by
# |factory| then the built-in scheme handler factory will be called. If
# |scheme_name| is a custom scheme then you must also implement the
# cef_app_t::on_register_custom_schemes() function in all processes. This
# function may be called multiple times to change or remove the factory that
# matches the specified |scheme_name| and optional |domain_name|. Returns false
# (0) if an error occurs. This function may be called on any thread in the
# browser process. Using this function is equivalent to calling cef_reques
# t_context_t::cef_request_context_get_global_context()-
# >register_scheme_handler_factory().
# Register a scheme handler factory with the global request context. An NULL
# |domain_name| value for a standard scheme will cause the factory to match all
# domain names. The |domain_name| value will be ignored for non-standard
# schemes. If |scheme_name| is a built-in scheme and no handler is returned by
# |factory| then the built-in scheme handler factory will be called. If
# |scheme_name| is a custom scheme then you must also implement the
# cef_app_t::on_register_custom_schemes() function in all processes. This
# function may be called multiple times to change or remove the factory that
# matches the specified |scheme_name| and optional |domain_name|. Returns false
# (0) if an error occurs. This function may be called on any thread in the
# browser process. Using this function is equivalent to calling cef_reques
# t_context_t::cef_request_context_get_global_context()-
# >register_scheme_handler_factory().
cef_register_scheme_handler_factory = _libraries['FIXME_STUB'].cef_register_scheme_handler_factory
cef_register_scheme_handler_factory.restype = ctypes.c_int32
# cef_register_scheme_handler_factory(scheme_name, domain_name, factory)
cef_register_scheme_handler_factory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_scheme_handler_factory_t)]
# Clear all scheme handler factories registered with the global request context.
# Returns false (0) on error. This function may be called on any thread in the
# browser process. Using this function is equivalent to calling
# cef_request_context_t::cef_request_context_get_global_context()-
# >clear_scheme_handler_factories().
# Clear all scheme handler factories registered with the global request context.
# Returns false (0) on error. This function may be called on any thread in the
# browser process. Using this function is equivalent to calling
# cef_request_context_t::cef_request_context_get_global_context()-
# >clear_scheme_handler_factories().
cef_clear_scheme_handler_factories = _libraries['FIXME_STUB'].cef_clear_scheme_handler_factories
cef_clear_scheme_handler_factories.restype = ctypes.c_int32
# cef_clear_scheme_handler_factories()
cef_clear_scheme_handler_factories.argtypes = []
# Implement this structure to provide handler implementations. Methods will be
# called by the process and/or thread indicated.
# Implement this structure to provide handler implementations. Methods will be
# called by the process and/or thread indicated.
class struct__cef_app_t(Structure):
    pass

struct__cef_app_t._pack_ = 1 # source:False
struct__cef_app_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_before_command_line_processing', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_app_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_command_line_t))),
    ('on_register_custom_schemes', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_app_t), ctypes.POINTER(struct__cef_scheme_registrar_t))),
    ('get_resource_bundle_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_app_t))),
    ('get_browser_process_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_app_t))),
    ('get_render_process_handler', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_app_t))),
]

cef_app_t = struct__cef_app_t
# This function should be called from the application entry point function to
# execute a secondary process. It can be used to run secondary processes from
# the browser client executable (default behavior) or from a separate executable
# specified by the cef_settings_t.browser_subprocess_path value. If called for
# the browser process (identified by no "type" command-line value) it will
# return immediately with a value of -1. If called for a recognized secondary
# process it will block until the process should exit and then return the
# process exit code. The |application| parameter may be NULL. The
# |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
# cef_sandbox_win.h for details).
# This function should be called from the application entry point function to
# execute a secondary process. It can be used to run secondary processes from
# the browser client executable (default behavior) or from a separate executable
# specified by the cef_settings_t.browser_subprocess_path value. If called for
# the browser process (identified by no "type" command-line value) it will
# return immediately with a value of -1. If called for a recognized secondary
# process it will block until the process should exit and then return the
# process exit code. The |application| parameter may be NULL. The
# |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
# cef_sandbox_win.h for details).
cef_execute_process = _libraries['FIXME_STUB'].cef_execute_process
cef_execute_process.restype = ctypes.c_int32
# cef_execute_process(args, application, windows_sandbox_info)
cef_execute_process.argtypes = [ctypes.POINTER(struct__cef_main_args_t), ctypes.POINTER(struct__cef_app_t), ctypes.POINTER(None)]
# This function should be called on the main application thread to initialize
# the CEF browser process. The |application| parameter may be NULL. Returns true
# (1) if initialization succeeds. Returns false (0) if initialization fails or
# if early exit is desired (for example, due to process singleton relaunch
# behavior). If this function returns false (0) then the application should exit
# immediately without calling any other CEF functions except, optionally,
# CefGetErrorCode. The |windows_sandbox_info| parameter is only used on Windows
# and may be NULL (see cef_sandbox_win.h for details).
# This function should be called on the main application thread to initialize
# the CEF browser process. The |application| parameter may be NULL. Returns true
# (1) if initialization succeeds. Returns false (0) if initialization fails or
# if early exit is desired (for example, due to process singleton relaunch
# behavior). If this function returns false (0) then the application should exit
# immediately without calling any other CEF functions except, optionally,
# CefGetErrorCode. The |windows_sandbox_info| parameter is only used on Windows
# and may be NULL (see cef_sandbox_win.h for details).
cef_initialize = _libraries['FIXME_STUB'].cef_initialize
cef_initialize.restype = ctypes.c_int32
# cef_initialize(args, settings, application, windows_sandbox_info)
cef_initialize.argtypes = [ctypes.POINTER(struct__cef_main_args_t), ctypes.POINTER(struct__cef_settings_t), ctypes.POINTER(struct__cef_app_t), ctypes.POINTER(None)]
# This function can optionally be called on the main application thread after
# CefInitialize to retrieve the initialization exit code. When CefInitialize
# returns true (1) the exit code will be 0 (CEF_RESULT_CODE_NORMAL_EXIT).
# Otherwise, see cef_resultcode_t for possible exit code values including
# browser process initialization errors and normal early exit conditions (such
# as CEF_RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED for process singleton relaunch
# behavior).
# This function can optionally be called on the main application thread after
# CefInitialize to retrieve the initialization exit code. When CefInitialize
# returns true (1) the exit code will be 0 (CEF_RESULT_CODE_NORMAL_EXIT).
# Otherwise, see cef_resultcode_t for possible exit code values including
# browser process initialization errors and normal early exit conditions (such
# as CEF_RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED for process singleton relaunch
# behavior).
cef_get_exit_code = _libraries['FIXME_STUB'].cef_get_exit_code
cef_get_exit_code.restype = ctypes.c_int32
# cef_get_exit_code()
cef_get_exit_code.argtypes = []
# This function should be called on the main application thread to shut down the
# CEF browser process before the application exits. Do not call any other CEF
# functions after calling this function.
# This function should be called on the main application thread to shut down the
# CEF browser process before the application exits. Do not call any other CEF
# functions after calling this function.
cef_shutdown = _libraries['FIXME_STUB'].cef_shutdown
cef_shutdown.restype = None
# cef_shutdown()
cef_shutdown.argtypes = []
# Perform a single iteration of CEF message loop processing. This function is
# provided for cases where the CEF message loop must be integrated into an
# existing application message loop. Use of this function is not recommended for
# most users; use either the cef_run_message_loop() function or
# cef_settings_t.multi_threaded_message_loop if possible. When using this
# function care must be taken to balance performance against excessive CPU
# usage. It is recommended to enable the cef_settings_t.external_message_pump
# option when using this function so that
# cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
# facilitate the scheduling process. This function should only be called on the
# main application thread and only if cef_initialize() is called with a
# cef_settings_t.multi_threaded_message_loop value of false (0). This function
# will not block.
# Perform a single iteration of CEF message loop processing. This function is
# provided for cases where the CEF message loop must be integrated into an
# existing application message loop. Use of this function is not recommended for
# most users; use either the cef_run_message_loop() function or
# cef_settings_t.multi_threaded_message_loop if possible. When using this
# function care must be taken to balance performance against excessive CPU
# usage. It is recommended to enable the cef_settings_t.external_message_pump
# option when using this function so that
# cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
# facilitate the scheduling process. This function should only be called on the
# main application thread and only if cef_initialize() is called with a
# cef_settings_t.multi_threaded_message_loop value of false (0). This function
# will not block.
cef_do_message_loop_work = _libraries['FIXME_STUB'].cef_do_message_loop_work
cef_do_message_loop_work.restype = None
# cef_do_message_loop_work()
cef_do_message_loop_work.argtypes = []
# Run the CEF message loop. Use this function instead of an application-
# provided message loop to get the best balance between performance and CPU
# usage. This function should only be called on the main application thread and
# only if cef_initialize() is called with a
# cef_settings_t.multi_threaded_message_loop value of false (0). This function
# will block until a quit message is received by the system.
# Run the CEF message loop. Use this function instead of an application-
# provided message loop to get the best balance between performance and CPU
# usage. This function should only be called on the main application thread and
# only if cef_initialize() is called with a
# cef_settings_t.multi_threaded_message_loop value of false (0). This function
# will block until a quit message is received by the system.
cef_run_message_loop = _libraries['FIXME_STUB'].cef_run_message_loop
cef_run_message_loop.restype = None
# cef_run_message_loop()
cef_run_message_loop.argtypes = []
# Quit the CEF message loop that was started by calling cef_run_message_loop().
# This function should only be called on the main application thread and only if
# cef_run_message_loop() was used.
# Quit the CEF message loop that was started by calling cef_run_message_loop().
# This function should only be called on the main application thread and only if
# cef_run_message_loop() was used.
cef_quit_message_loop = _libraries['FIXME_STUB'].cef_quit_message_loop
cef_quit_message_loop.restype = None
# cef_quit_message_loop()
cef_quit_message_loop.argtypes = []
# Crash reporting is configured using an INI-style config file named
# "crash_reporter.cfg". On Windows and Linux this file must be placed next to
# the main application executable. On macOS this file must be placed in the top-
# level app bundle Resources directory (e.g.
# "<appname>.app/Contents/Resources"). File contents are as follows:
# Crash reporting is configured using an INI-style config file named
# "crash_reporter.cfg". On Windows and Linux this file must be placed next to
# the main application executable. On macOS this file must be placed in the top-
# level app bundle Resources directory (e.g.
# "<appname>.app/Contents/Resources"). File contents are as follows:
cef_crash_reporting_enabled = _libraries['FIXME_STUB'].cef_crash_reporting_enabled
cef_crash_reporting_enabled.restype = ctypes.c_int32
# cef_crash_reporting_enabled()
cef_crash_reporting_enabled.argtypes = []
# Sets or clears a specific key-value pair from the crash metadata.
# Sets or clears a specific key-value pair from the crash metadata.
cef_set_crash_key_value = _libraries['FIXME_STUB'].cef_set_crash_key_value
cef_set_crash_key_value.restype = None
# cef_set_crash_key_value(key, value)
cef_set_crash_key_value.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Creates a directory and all parent directories if they don't already exist.
# Returns true (1) on successful creation or if the directory already exists.
# The directory is only readable by the current user. Calling this function on
# the browser process UI or IO threads is not allowed.
# Creates a directory and all parent directories if they don't already exist.
# Returns true (1) on successful creation or if the directory already exists.
# The directory is only readable by the current user. Calling this function on
# the browser process UI or IO threads is not allowed.
cef_create_directory = _libraries['FIXME_STUB'].cef_create_directory
cef_create_directory.restype = ctypes.c_int32
# cef_create_directory(full_path)
cef_create_directory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Get the temporary directory provided by the system.
# Get the temporary directory provided by the system.
cef_get_temp_directory = _libraries['FIXME_STUB'].cef_get_temp_directory
cef_get_temp_directory.restype = ctypes.c_int32
# cef_get_temp_directory(temp_dir)
cef_get_temp_directory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Creates a new directory. On Windows if |prefix| is provided the new directory
# name is in the format of "prefixyyyy". Returns true (1) on success and sets
# |new_temp_path| to the full path of the directory that was created. The
# directory is only readable by the current user. Calling this function on the
# browser process UI or IO threads is not allowed.
# Creates a new directory. On Windows if |prefix| is provided the new directory
# name is in the format of "prefixyyyy". Returns true (1) on success and sets
# |new_temp_path| to the full path of the directory that was created. The
# directory is only readable by the current user. Calling this function on the
# browser process UI or IO threads is not allowed.
cef_create_new_temp_directory = _libraries['FIXME_STUB'].cef_create_new_temp_directory
cef_create_new_temp_directory.restype = ctypes.c_int32
# cef_create_new_temp_directory(prefix, new_temp_path)
cef_create_new_temp_directory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Creates a directory within another directory. Extra characters will be
# appended to |prefix| to ensure that the new directory does not have the same
# name as an existing directory. Returns true (1) on success and sets |new_dir|
# to the full path of the directory that was created. The directory is only
# readable by the current user. Calling this function on the browser process UI
# or IO threads is not allowed.
# Creates a directory within another directory. Extra characters will be
# appended to |prefix| to ensure that the new directory does not have the same
# name as an existing directory. Returns true (1) on success and sets |new_dir|
# to the full path of the directory that was created. The directory is only
# readable by the current user. Calling this function on the browser process UI
# or IO threads is not allowed.
cef_create_temp_directory_in_directory = _libraries['FIXME_STUB'].cef_create_temp_directory_in_directory
cef_create_temp_directory_in_directory.restype = ctypes.c_int32
# cef_create_temp_directory_in_directory(base_dir, prefix, new_dir)
cef_create_temp_directory_in_directory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Returns true (1) if the given path exists and is a directory. Calling this
# function on the browser process UI or IO threads is not allowed.
# Returns true (1) if the given path exists and is a directory. Calling this
# function on the browser process UI or IO threads is not allowed.
cef_directory_exists = _libraries['FIXME_STUB'].cef_directory_exists
cef_directory_exists.restype = ctypes.c_int32
# cef_directory_exists(path)
cef_directory_exists.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Deletes the given path whether it's a file or a directory. If |path| is a
# directory all contents will be deleted. If |recursive| is true (1) any sub-
# directories and their contents will also be deleted (equivalent to executing
# "rm -rf", so use with caution). On POSIX environments if |path| is a symbolic
# link then only the symlink will be deleted. Returns true (1) on successful
# deletion or if |path| does not exist. Calling this function on the browser
# process UI or IO threads is not allowed.
# Deletes the given path whether it's a file or a directory. If |path| is a
# directory all contents will be deleted. If |recursive| is true (1) any sub-
# directories and their contents will also be deleted (equivalent to executing
# "rm -rf", so use with caution). On POSIX environments if |path| is a symbolic
# link then only the symlink will be deleted. Returns true (1) on successful
# deletion or if |path| does not exist. Calling this function on the browser
# process UI or IO threads is not allowed.
cef_delete_file = _libraries['FIXME_STUB'].cef_delete_file
cef_delete_file.restype = ctypes.c_int32
# cef_delete_file(path, recursive)
cef_delete_file.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# Writes the contents of |src_dir| into a zip archive at |dest_file|. If
# |include_hidden_files| is true (1) files starting with "." will be included.
# Returns true (1) on success. Calling this function on the browser process UI
# or IO threads is not allowed.
# Writes the contents of |src_dir| into a zip archive at |dest_file|. If
# |include_hidden_files| is true (1) files starting with "." will be included.
# Returns true (1) on success. Calling this function on the browser process UI
# or IO threads is not allowed.
cef_zip_directory = _libraries['FIXME_STUB'].cef_zip_directory
cef_zip_directory.restype = ctypes.c_int32
# cef_zip_directory(src_dir, dest_file, include_hidden_files)
cef_zip_directory.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# Loads the existing "Certificate Revocation Lists" file that is managed by
# Google Chrome. This file can generally be found in Chrome's User Data
# directory (e.g. "C:\Users\[User]\AppData\Local\Google\Chrome\User Data\" on
# Windows) and is updated periodically by Chrome's component updater service.
# Must be called in the browser process after the context has been initialized.
# See https://dev.chromium.org/Home/chromium-security/crlsets for background.
# Loads the existing "Certificate Revocation Lists" file that is managed by
# Google Chrome. This file can generally be found in Chrome's User Data
# directory (e.g. "C:\Users\[User]\AppData\Local\Google\Chrome\User Data\" on
# Windows) and is updated periodically by Chrome's component updater service.
# Must be called in the browser process after the context has been initialized.
# See https://dev.chromium.org/Home/chromium-security/crlsets for background.
cef_load_crlsets_file = _libraries['FIXME_STUB'].cef_load_crlsets_file
cef_load_crlsets_file.restype = None
# cef_load_crlsets_file(path)
cef_load_crlsets_file.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Returns true (1) if the application text direction is right-to-left.
# Returns true (1) if the application text direction is right-to-left.
cef_is_rtl = _libraries['FIXME_STUB'].cef_is_rtl
cef_is_rtl.restype = ctypes.c_int32
# cef_is_rtl()
cef_is_rtl.argtypes = []
# Add an entry to the cross-origin access whitelist.
# Add an entry to the cross-origin access whitelist.
cef_add_cross_origin_whitelist_entry = _libraries['FIXME_STUB'].cef_add_cross_origin_whitelist_entry
cef_add_cross_origin_whitelist_entry.restype = ctypes.c_int32
# cef_add_cross_origin_whitelist_entry(source_origin, target_protocol, target_domain, allow_target_subdomains)
cef_add_cross_origin_whitelist_entry.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# Remove an entry from the cross-origin access whitelist. Returns false (0) if
# |source_origin| is invalid or the whitelist cannot be accessed.
# Remove an entry from the cross-origin access whitelist. Returns false (0) if
# |source_origin| is invalid or the whitelist cannot be accessed.
cef_remove_cross_origin_whitelist_entry = _libraries['FIXME_STUB'].cef_remove_cross_origin_whitelist_entry
cef_remove_cross_origin_whitelist_entry.restype = ctypes.c_int32
# cef_remove_cross_origin_whitelist_entry(source_origin, target_protocol, target_domain, allow_target_subdomains)
cef_remove_cross_origin_whitelist_entry.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# Remove all entries from the cross-origin access whitelist. Returns false (0)
# if the whitelist cannot be accessed.
# Remove all entries from the cross-origin access whitelist. Returns false (0)
# if the whitelist cannot be accessed.
cef_clear_cross_origin_whitelist = _libraries['FIXME_STUB'].cef_clear_cross_origin_whitelist
cef_clear_cross_origin_whitelist.restype = ctypes.c_int32
# cef_clear_cross_origin_whitelist()
cef_clear_cross_origin_whitelist.argtypes = []
# Combines specified |base_url| and |relative_url| into |resolved_url|. Returns
# false (0) if one of the URLs is NULL or invalid.
# Combines specified |base_url| and |relative_url| into |resolved_url|. Returns
# false (0) if one of the URLs is NULL or invalid.
cef_resolve_url = _libraries['FIXME_STUB'].cef_resolve_url
cef_resolve_url.restype = ctypes.c_int32
# cef_resolve_url(base_url, relative_url, resolved_url)
cef_resolve_url.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# Parse the specified |url| into its component parts. Returns false (0) if the
# URL is NULL or invalid.
# Parse the specified |url| into its component parts. Returns false (0) if the
# URL is NULL or invalid.
cef_parse_url = _libraries['FIXME_STUB'].cef_parse_url
cef_parse_url.restype = ctypes.c_int32
# cef_parse_url(url, parts)
cef_parse_url.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_urlparts_t)]
# Creates a URL from the specified |parts|, which must contain a non-NULL spec
# or a non-NULL host and path (at a minimum), but not both. Returns false (0) if
# |parts| isn't initialized as described.
# Creates a URL from the specified |parts|, which must contain a non-NULL spec
# or a non-NULL host and path (at a minimum), but not both. Returns false (0) if
# |parts| isn't initialized as described.
cef_create_url = _libraries['FIXME_STUB'].cef_create_url
cef_create_url.restype = ctypes.c_int32
# cef_create_url(parts, url)
cef_create_url.argtypes = [ctypes.POINTER(struct__cef_urlparts_t), ctypes.POINTER(struct__cef_string_utf16_t)]
# This is a convenience function for formatting a URL in a concise and human-
# friendly way to help users make security-related decisions (or in other
# circumstances when people need to distinguish sites, origins, or otherwise-
# simplified URLs from each other). Internationalized domain names (IDN) may be
# presented in Unicode if the conversion is considered safe. The returned value
# will (a) omit the path for standard schemes, excepting file and filesystem,
# and (b) omit the port if it is the default for the scheme. Do not use this for
# URLs which will be parsed or sent to other applications.
# This is a convenience function for formatting a URL in a concise and human-
# friendly way to help users make security-related decisions (or in other
# circumstances when people need to distinguish sites, origins, or otherwise-
# simplified URLs from each other). Internationalized domain names (IDN) may be
# presented in Unicode if the conversion is considered safe. The returned value
# will (a) omit the path for standard schemes, excepting file and filesystem,
# and (b) omit the port if it is the default for the scheme. Do not use this for
# URLs which will be parsed or sent to other applications.
cef_format_url_for_security_display = _libraries['FIXME_STUB'].cef_format_url_for_security_display
cef_format_url_for_security_display.restype = cef_string_userfree_t
# cef_format_url_for_security_display(origin_url)
cef_format_url_for_security_display.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Returns the mime type for the specified file extension or an NULL string if
# unknown.
# Returns the mime type for the specified file extension or an NULL string if
# unknown.
cef_get_mime_type = _libraries['FIXME_STUB'].cef_get_mime_type
cef_get_mime_type.restype = cef_string_userfree_t
# cef_get_mime_type(extension)
cef_get_mime_type.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Get the extensions associated with the given mime type. This should be passed
# in lower case. There could be multiple extensions for a given mime type, like
# "html,htm" for "text/html", or "txt,text,html,..." for "text/*". Any existing
# elements in the provided vector will not be erased.
# Get the extensions associated with the given mime type. This should be passed
# in lower case. There could be multiple extensions for a given mime type, like
# "html,htm" for "text/html", or "txt,text,html,..." for "text/*". Any existing
# elements in the provided vector will not be erased.
cef_get_extensions_for_mime_type = _libraries['FIXME_STUB'].cef_get_extensions_for_mime_type
cef_get_extensions_for_mime_type.restype = None
# cef_get_extensions_for_mime_type(mime_type, extensions)
cef_get_extensions_for_mime_type.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), cef_string_list_t]
# Encodes |data| as a base64 string.
# Encodes |data| as a base64 string.
cef_base64encode = _libraries['FIXME_STUB'].cef_base64encode
cef_base64encode.restype = cef_string_userfree_t
# cef_base64encode(data, data_size)
cef_base64encode.argtypes = [ctypes.POINTER(None), size_t]
# Decodes the base64 encoded string |data|. The returned value will be NULL if
# the decoding fails.
# Decodes the base64 encoded string |data|. The returned value will be NULL if
# the decoding fails.
cef_base64decode = _libraries['FIXME_STUB'].cef_base64decode
cef_base64decode.restype = ctypes.POINTER(struct__cef_binary_value_t)
# cef_base64decode(data)
cef_base64decode.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t)]
# Escapes characters in |text| which are unsuitable for use as a query parameter
# value. Everything except alphanumerics and -_.!~*'() will be converted to
# "%XX". If |use_plus| is true (1) spaces will change to "+". The result is
# basically the same as encodeURIComponent in Javacript.
# Escapes characters in |text| which are unsuitable for use as a query parameter
# value. Everything except alphanumerics and -_.!~*'() will be converted to
# "%XX". If |use_plus| is true (1) spaces will change to "+". The result is
# basically the same as encodeURIComponent in Javacript.
cef_uriencode = _libraries['FIXME_STUB'].cef_uriencode
cef_uriencode.restype = cef_string_userfree_t
# cef_uriencode(text, use_plus)
cef_uriencode.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32]
# Unescapes |text| and returns the result. Unescaping consists of looking for
# the exact pattern "%XX" where each X is a hex digit and converting to the
# character with the numerical value of those digits (e.g. "i%20=%203%3b"
# unescapes to "i = 3;"). If |convert_to_utf8| is true (1) this function will
# attempt to interpret the initial decoded result as UTF-8. If the result is
# convertable into UTF-8 it will be returned as converted. Otherwise the initial
# decoded result will be returned. The |unescape_rule| parameter supports
# further customization the decoding process.
# Unescapes |text| and returns the result. Unescaping consists of looking for
# the exact pattern "%XX" where each X is a hex digit and converting to the
# character with the numerical value of those digits (e.g. "i%20=%203%3b"
# unescapes to "i = 3;"). If |convert_to_utf8| is true (1) this function will
# attempt to interpret the initial decoded result as UTF-8. If the result is
# convertable into UTF-8 it will be returned as converted. Otherwise the initial
# decoded result will be returned. The |unescape_rule| parameter supports
# further customization the decoding process.
cef_uridecode = _libraries['FIXME_STUB'].cef_uridecode
cef_uridecode.restype = cef_string_userfree_t
# cef_uridecode(text, convert_to_utf8, unescape_rule)
cef_uridecode.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32, cef_uri_unescape_rule_t]
# Parses the specified |json_string| and returns a dictionary or list
# representation. If JSON parsing fails this function returns NULL.
# Parses the specified |json_string| and returns a dictionary or list
# representation. If JSON parsing fails this function returns NULL.
cef_parse_json = _libraries['FIXME_STUB'].cef_parse_json
cef_parse_json.restype = ctypes.POINTER(struct__cef_value_t)
# cef_parse_json(json_string, options)
cef_parse_json.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), cef_json_parser_options_t]
# Parses the specified UTF8-encoded |json| buffer of size |json_size| and
# returns a dictionary or list representation. If JSON parsing fails this
# function returns NULL.
# Parses the specified UTF8-encoded |json| buffer of size |json_size| and
# returns a dictionary or list representation. If JSON parsing fails this
# function returns NULL.
cef_parse_json_buffer = _libraries['FIXME_STUB'].cef_parse_json_buffer
cef_parse_json_buffer.restype = ctypes.POINTER(struct__cef_value_t)
# cef_parse_json_buffer(json, json_size, options)
cef_parse_json_buffer.argtypes = [ctypes.POINTER(None), size_t, cef_json_parser_options_t]
# Parses the specified |json_string| and returns a dictionary or list
# representation. If JSON parsing fails this function returns NULL and populates
# |error_msg_out| with a formatted error message.
# Parses the specified |json_string| and returns a dictionary or list
# representation. If JSON parsing fails this function returns NULL and populates
# |error_msg_out| with a formatted error message.
cef_parse_jsonand_return_error = _libraries['FIXME_STUB'].cef_parse_jsonand_return_error
cef_parse_jsonand_return_error.restype = ctypes.POINTER(struct__cef_value_t)
# cef_parse_jsonand_return_error(json_string, options, error_msg_out)
cef_parse_jsonand_return_error.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), cef_json_parser_options_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Generates a JSON string from the specified root |node| which should be a
# dictionary or list value. Returns an NULL string on failure. This function
# requires exclusive access to |node| including any underlying data.
# Generates a JSON string from the specified root |node| which should be a
# dictionary or list value. Returns an NULL string on failure. This function
# requires exclusive access to |node| including any underlying data.
cef_write_json = _libraries['FIXME_STUB'].cef_write_json
cef_write_json.restype = cef_string_userfree_t
# cef_write_json(node, options)
cef_write_json.argtypes = [ctypes.POINTER(struct__cef_value_t), cef_json_writer_options_t]
# Retrieve the path associated with the specified |key|. Returns true (1) on
# success. Can be called on any thread in the browser process.
# Retrieve the path associated with the specified |key|. Returns true (1) on
# success. Can be called on any thread in the browser process.
cef_get_path = _libraries['FIXME_STUB'].cef_get_path
cef_get_path.restype = ctypes.c_int32
# cef_get_path(key, path)
cef_get_path.argtypes = [cef_path_key_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Launches the process specified via |command_line|. Returns true (1) upon
# success. Must be called on the browser process TID_PROCESS_LAUNCHER thread.
# Launches the process specified via |command_line|. Returns true (1) upon
# success. Must be called on the browser process TID_PROCESS_LAUNCHER thread.
cef_launch_process = _libraries['FIXME_STUB'].cef_launch_process
cef_launch_process.restype = ctypes.c_int32
# cef_launch_process(command_line)
cef_launch_process.argtypes = [ctypes.POINTER(struct__cef_command_line_t)]
# Structure used for retrieving resources from the resource bundle (*.pak) files
# loaded by CEF during startup or via the cef_resource_bundle_handler_t returned
# from cef_app_t::GetResourceBundleHandler. See CefSettings for additional
# options related to resource bundle loading. The functions of this structure
# may be called on any thread unless otherwise indicated.
class struct__cef_resource_bundle_t(Structure):
    pass

struct__cef_resource_bundle_t._pack_ = 1 # source:False
struct__cef_resource_bundle_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_localized_string', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_bundle_t), ctypes.c_int32)),
    ('get_data_resource', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_bundle_t), ctypes.c_int32)),
    ('get_data_resource_for_scale', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_resource_bundle_t), ctypes.c_int32, c__EA_cef_scale_factor_t)),
]

# Structure used for retrieving resources from the resource bundle (*.pak) files
# loaded by CEF during startup or via the cef_resource_bundle_handler_t returned
# from cef_app_t::GetResourceBundleHandler. See CefSettings for additional
# options related to resource bundle loading. The functions of this structure
# may be called on any thread unless otherwise indicated.
# Structure used for retrieving resources from the resource bundle (*.pak) files
# loaded by CEF during startup or via the cef_resource_bundle_handler_t returned
# from cef_app_t::GetResourceBundleHandler. See CefSettings for additional
# options related to resource bundle loading. The functions of this structure
# may be called on any thread unless otherwise indicated.
cef_resource_bundle_t = struct__cef_resource_bundle_t
# Returns the global resource bundle instance.
# Returns the global resource bundle instance.
cef_resource_bundle_get_global = _libraries['FIXME_STUB'].cef_resource_bundle_get_global
cef_resource_bundle_get_global.restype = ctypes.POINTER(struct__cef_resource_bundle_t)
# cef_resource_bundle_get_global()
cef_resource_bundle_get_global.argtypes = []
# Structure representing a server that supports HTTP and WebSocket requests.
# Server capacity is limited and is intended to handle only a small number of
# simultaneous connections (e.g. for communicating between applications on
# localhost). The functions of this structure are safe to call from any thread
# in the brower process unless otherwise indicated.
class struct__cef_server_t(Structure):
    pass

struct__cef_server_t._pack_ = 1 # source:False
struct__cef_server_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_task_runner', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_server_t))),
    ('shutdown', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t))),
    ('is_running', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_server_t))),
    ('get_address', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_server_t))),
    ('has_connection', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_server_t))),
    ('is_valid_connection', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('send_http200response', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('send_http404response', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('send_http500response', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t))),
    ('send_http_response', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int64, ctypes.POINTER(struct__cef_string_multimap_t))),
    ('send_raw_data', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(None), ctypes.c_uint64)),
    ('close_connection', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('send_web_socket_message', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(None), ctypes.c_uint64)),
]

# Structure representing a server that supports HTTP and WebSocket requests.
# Server capacity is limited and is intended to handle only a small number of
# simultaneous connections (e.g. for communicating between applications on
# localhost). The functions of this structure are safe to call from any thread
# in the brower process unless otherwise indicated.
# Structure representing a server that supports HTTP and WebSocket requests.
# Server capacity is limited and is intended to handle only a small number of
# simultaneous connections (e.g. for communicating between applications on
# localhost). The functions of this structure are safe to call from any thread
# in the brower process unless otherwise indicated.
cef_server_t = struct__cef_server_t
# Create a new server that binds to |address| and |port|. |address| must be a
# valid IPv4 or IPv6 address (e.g. 127.0.0.1 or ::1) and |port| must be a port
# number outside of the reserved range (e.g. between 1025 and 65535 on most
# platforms). |backlog| is the maximum number of pending connections. A new
# thread will be created for each CreateServer call (the "dedicated server
# thread"). It is therefore recommended to use a different cef_server_handler_t
# instance for each CreateServer call to avoid thread safety issues in the
# cef_server_handler_t implementation. The cef_server_handler_t::OnServerCreated
# function will be called on the dedicated server thread to report success or
# failure. See cef_server_handler_t::OnServerCreated documentation for a
# description of server lifespan.
# Create a new server that binds to |address| and |port|. |address| must be a
# valid IPv4 or IPv6 address (e.g. 127.0.0.1 or ::1) and |port| must be a port
# number outside of the reserved range (e.g. between 1025 and 65535 on most
# platforms). |backlog| is the maximum number of pending connections. A new
# thread will be created for each CreateServer call (the "dedicated server
# thread"). It is therefore recommended to use a different cef_server_handler_t
# instance for each CreateServer call to avoid thread safety issues in the
# cef_server_handler_t implementation. The cef_server_handler_t::OnServerCreated
# function will be called on the dedicated server thread to report success or
# failure. See cef_server_handler_t::OnServerCreated documentation for a
# description of server lifespan.
uint16_t = ctypes.c_uint16
class struct__cef_server_handler_t(Structure):
    pass

cef_server_create = _libraries['FIXME_STUB'].cef_server_create
cef_server_create.restype = None
# cef_server_create(address, port, backlog, handler)
cef_server_create.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), uint16_t, ctypes.c_int32, ctypes.POINTER(struct__cef_server_handler_t)]
# Implement this structure to handle HTTP server requests. A new thread will be
# created for each cef_server_t::CreateServer call (the "dedicated server
# thread"), and the functions of this structure will be called on that thread.
# It is therefore recommended to use a different cef_server_handler_t instance
# for each cef_server_t::CreateServer call to avoid thread safety issues in the
# cef_server_handler_t implementation.
# Implement this structure to handle HTTP server requests. A new thread will be
# created for each cef_server_t::CreateServer call (the "dedicated server
# thread"), and the functions of this structure will be called on that thread.
# It is therefore recommended to use a different cef_server_handler_t instance
# for each cef_server_t::CreateServer call to avoid thread safety issues in the
# cef_server_handler_t implementation.
struct__cef_server_handler_t._pack_ = 1 # source:False
struct__cef_server_handler_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_server_created', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t))),
    ('on_server_destroyed', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t))),
    ('on_client_connected', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('on_client_disconnected', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('on_http_request', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_request_t))),
    ('on_web_socket_request', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_callback_t))),
    ('on_web_socket_connected', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32)),
    ('on_web_socket_message', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_server_handler_t), ctypes.POINTER(struct__cef_server_t), ctypes.c_int32, ctypes.POINTER(None), ctypes.c_uint64)),
]

cef_server_handler_t = struct__cef_server_handler_t
# Structure that builds a cef_process_message_t containing a shared memory
# region. This structure is not thread-safe but may be used exclusively on a
# different thread from the one which constructed it.
class struct__cef_shared_process_message_builder_t(Structure):
    pass

struct__cef_shared_process_message_builder_t._pack_ = 1 # source:False
struct__cef_shared_process_message_builder_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('is_valid', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_shared_process_message_builder_t))),
    ('size', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_shared_process_message_builder_t))),
    ('memory', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_shared_process_message_builder_t))),
    ('build', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_shared_process_message_builder_t))),
]

# Structure that builds a cef_process_message_t containing a shared memory
# region. This structure is not thread-safe but may be used exclusively on a
# different thread from the one which constructed it.
# Structure that builds a cef_process_message_t containing a shared memory
# region. This structure is not thread-safe but may be used exclusively on a
# different thread from the one which constructed it.
cef_shared_process_message_builder_t = struct__cef_shared_process_message_builder_t
# Creates a new cef_shared_process_message_builder_t with the specified |name|
# and shared memory region of specified |byte_size|.
# Creates a new cef_shared_process_message_builder_t with the specified |name|
# and shared memory region of specified |byte_size|.
cef_shared_process_message_builder_create = _libraries['FIXME_STUB'].cef_shared_process_message_builder_create
cef_shared_process_message_builder_create.restype = ctypes.POINTER(struct__cef_shared_process_message_builder_t)
# cef_shared_process_message_builder_create(name, byte_size)
cef_shared_process_message_builder_create.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), size_t]
# Structure that facilitates managing the browser-related tasks. The functions
# of this structure may only be called on the UI thread.
class struct__cef_task_manager_t(Structure):
    pass

struct__cef_task_manager_t._pack_ = 1 # source:False
struct__cef_task_manager_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_tasks_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_task_manager_t))),
    ('get_task_ids_list', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_manager_t), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.c_int64))),
    ('get_task_info', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_manager_t), ctypes.c_int64, ctypes.POINTER(struct__cef_task_info_t))),
    ('kill_task', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_task_manager_t), ctypes.c_int64)),
    ('get_task_id_for_browser_id', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_task_manager_t), ctypes.c_int32)),
]

# Structure that facilitates managing the browser-related tasks. The functions
# of this structure may only be called on the UI thread.
# Structure that facilitates managing the browser-related tasks. The functions
# of this structure may only be called on the UI thread.
cef_task_manager_t = struct__cef_task_manager_t
# Returns the global task manager object. Returns nullptr if the function was
# called from the incorrect thread.
# Returns the global task manager object. Returns nullptr if the function was
# called from the incorrect thread.
cef_task_manager_get = _libraries['FIXME_STUB'].cef_task_manager_get
cef_task_manager_get.restype = ctypes.POINTER(struct__cef_task_manager_t)
# cef_task_manager_get()
cef_task_manager_get.argtypes = []
cef_platform_thread_id_t = ctypes.c_int32
# Returns the current platform thread ID.
# Returns the current platform thread ID.
cef_get_current_platform_thread_id = _libraries['FIXME_STUB'].cef_get_current_platform_thread_id
cef_get_current_platform_thread_id.restype = cef_platform_thread_id_t
# cef_get_current_platform_thread_id()
cef_get_current_platform_thread_id.argtypes = []
class struct__opaque_pthread_t(Structure):
    pass

cef_platform_thread_handle_t = ctypes.POINTER(struct__opaque_pthread_t)
# Returns the current platform thread handle.
# Returns the current platform thread handle.
cef_get_current_platform_thread_handle = _libraries['FIXME_STUB'].cef_get_current_platform_thread_handle
cef_get_current_platform_thread_handle.restype = cef_platform_thread_handle_t
# cef_get_current_platform_thread_handle()
cef_get_current_platform_thread_handle.argtypes = []
# A simple thread abstraction that establishes a message loop on a new thread.
# The consumer uses cef_task_runner_t to execute code on the thread's message
# loop. The thread is terminated when the cef_thread_t object is destroyed or
# stop() is called. All pending tasks queued on the thread's message loop will
# run to completion before the thread is terminated. cef_thread_create() can be
# called on any valid CEF thread in either the browser or render process. This
# structure should only be used for tasks that require a dedicated thread. In
# most cases you can post tasks to an existing CEF thread instead of creating a
# new one; see cef_task.h for details.
class struct__cef_thread_t(Structure):
    pass

struct__cef_thread_t._pack_ = 1 # source:False
struct__cef_thread_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('get_task_runner', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_thread_t))),
    ('get_platform_thread_id', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_thread_t))),
    ('stop', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_thread_t))),
    ('is_running', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_thread_t))),
]

# A simple thread abstraction that establishes a message loop on a new thread.
# The consumer uses cef_task_runner_t to execute code on the thread's message
# loop. The thread is terminated when the cef_thread_t object is destroyed or
# stop() is called. All pending tasks queued on the thread's message loop will
# run to completion before the thread is terminated. cef_thread_create() can be
# called on any valid CEF thread in either the browser or render process. This
# structure should only be used for tasks that require a dedicated thread. In
# most cases you can post tasks to an existing CEF thread instead of creating a
# new one; see cef_task.h for details.
# A simple thread abstraction that establishes a message loop on a new thread.
# The consumer uses cef_task_runner_t to execute code on the thread's message
# loop. The thread is terminated when the cef_thread_t object is destroyed or
# stop() is called. All pending tasks queued on the thread's message loop will
# run to completion before the thread is terminated. cef_thread_create() can be
# called on any valid CEF thread in either the browser or render process. This
# structure should only be used for tasks that require a dedicated thread. In
# most cases you can post tasks to an existing CEF thread instead of creating a
# new one; see cef_task.h for details.
cef_thread_t = struct__cef_thread_t
# Create and start a new thread. This function does not block waiting for the
# thread to run initialization. |display_name| is the name that will be used to
# identify the thread. |priority| is the thread execution priority.
# |message_loop_type| indicates the set of asynchronous events that the thread
# can process. If |stoppable| is true (1) the thread will stopped and joined on
# destruction or when stop() is called; otherwise, the thread cannot be stopped
# and will be leaked on shutdown. On Windows the |com_init_mode| value specifies
# how COM will be initialized for the thread. If |com_init_mode| is set to
# COM_INIT_MODE_STA then |message_loop_type| must be set to ML_TYPE_UI.
# Create and start a new thread. This function does not block waiting for the
# thread to run initialization. |display_name| is the name that will be used to
# identify the thread. |priority| is the thread execution priority.
# |message_loop_type| indicates the set of asynchronous events that the thread
# can process. If |stoppable| is true (1) the thread will stopped and joined on
# destruction or when stop() is called; otherwise, the thread cannot be stopped
# and will be leaked on shutdown. On Windows the |com_init_mode| value specifies
# how COM will be initialized for the thread. If |com_init_mode| is set to
# COM_INIT_MODE_STA then |message_loop_type| must be set to ML_TYPE_UI.
cef_thread_create = _libraries['FIXME_STUB'].cef_thread_create
cef_thread_create.restype = ctypes.POINTER(struct__cef_thread_t)
# cef_thread_create(display_name, priority, message_loop_type, stoppable, com_init_mode)
cef_thread_create.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), cef_thread_priority_t, cef_message_loop_type_t, ctypes.c_int32, cef_com_init_mode_t]
# Implement this structure to receive notification when tracing has completed.
# The functions of this structure will be called on the browser process UI
# thread.
class struct__cef_end_tracing_callback_t(Structure):
    pass

struct__cef_end_tracing_callback_t._pack_ = 1 # source:False
struct__cef_end_tracing_callback_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('on_end_tracing_complete', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_end_tracing_callback_t), ctypes.POINTER(struct__cef_string_utf16_t))),
]

# Implement this structure to receive notification when tracing has completed.
# The functions of this structure will be called on the browser process UI
# thread.
# Implement this structure to receive notification when tracing has completed.
# The functions of this structure will be called on the browser process UI
# thread.
cef_end_tracing_callback_t = struct__cef_end_tracing_callback_t
# Start tracing events on all processes. Tracing is initialized asynchronously
# and |callback| will be executed on the UI thread after initialization is
# complete.
# Start tracing events on all processes. Tracing is initialized asynchronously
# and |callback| will be executed on the UI thread after initialization is
# complete.
cef_begin_tracing = _libraries['FIXME_STUB'].cef_begin_tracing
cef_begin_tracing.restype = ctypes.c_int32
# cef_begin_tracing(categories, callback)
cef_begin_tracing.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_completion_callback_t)]
# Stop tracing events on all processes.
# Stop tracing events on all processes.
cef_end_tracing = _libraries['FIXME_STUB'].cef_end_tracing
cef_end_tracing.restype = ctypes.c_int32
# cef_end_tracing(tracing_file, callback)
cef_end_tracing.argtypes = [ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_end_tracing_callback_t)]
# Returns the current system trace time or, if none is defined, the current
# high-res time. Can be used by clients to synchronize with the time information
# in trace events.
# Returns the current system trace time or, if none is defined, the current
# high-res time. Can be used by clients to synchronize with the time information
# in trace events.
cef_now_from_system_trace_time = _libraries['FIXME_STUB'].cef_now_from_system_trace_time
cef_now_from_system_trace_time.restype = int64_t
# cef_now_from_system_trace_time()
cef_now_from_system_trace_time.argtypes = []
# Structure used to make a URL request. URL requests are not associated with a
# browser instance so no cef_client_t callbacks will be executed. URL requests
# can be created on any valid CEF thread in either the browser or render
# process. Once created the functions of the URL request object must be accessed
# on the same thread that created it.
# Structure used to make a URL request. URL requests are not associated with a
# browser instance so no cef_client_t callbacks will be executed. URL requests
# can be created on any valid CEF thread in either the browser or render
# process. Once created the functions of the URL request object must be accessed
# on the same thread that created it.
cef_urlrequest_t = struct__cef_urlrequest_t
# Create a new URL request that is not associated with a specific browser or
# frame. Use cef_frame_t::CreateURLRequest instead if you want the request to
# have this association, in which case it may be handled differently (see
# documentation on that function). A request created with this function may only
# originate from the browser process, and will behave as follows: - It may be
# intercepted by the client via CefResourceRequestHandler or
# CefSchemeHandlerFactory. - POST data may only contain only a single element of
# type PDE_TYPE_FILE or PDE_TYPE_BYTES. - If |request_context| is empty the
# global request context will be used.
# Create a new URL request that is not associated with a specific browser or
# frame. Use cef_frame_t::CreateURLRequest instead if you want the request to
# have this association, in which case it may be handled differently (see
# documentation on that function). A request created with this function may only
# originate from the browser process, and will behave as follows: - It may be
# intercepted by the client via CefResourceRequestHandler or
# CefSchemeHandlerFactory. - POST data may only contain only a single element of
# type PDE_TYPE_FILE or PDE_TYPE_BYTES. - If |request_context| is empty the
# global request context will be used.
cef_urlrequest_create = _libraries['FIXME_STUB'].cef_urlrequest_create
cef_urlrequest_create.restype = ctypes.POINTER(struct__cef_urlrequest_t)
# cef_urlrequest_create(request, client, request_context)
cef_urlrequest_create.argtypes = [ctypes.POINTER(struct__cef_request_t), ctypes.POINTER(struct__cef_urlrequest_client_t), ctypes.POINTER(struct__cef_request_context_t)]
# Structure that should be implemented by the cef_urlrequest_t client. The
# functions of this structure will be called on the same thread that created the
# request unless otherwise documented.
# Structure that should be implemented by the cef_urlrequest_t client. The
# functions of this structure will be called on the same thread that created the
# request unless otherwise documented.
cef_urlrequest_client_t = struct__cef_urlrequest_client_t
# WaitableEvent is a thread synchronization tool that allows one thread to wait
# for another thread to finish some work. This is equivalent to using a
# Lock+ConditionVariable to protect a simple boolean value. However, using
# WaitableEvent in conjunction with a Lock to wait for a more complex state
# change (e.g., for an item to be added to a queue) is not recommended. In that
# case consider using a ConditionVariable instead of a WaitableEvent. It is safe
# to create and/or signal a WaitableEvent from any thread. Blocking on a
# WaitableEvent by calling the *wait() functions is not allowed on the browser
# process UI or IO threads.
class struct__cef_waitable_event_t(Structure):
    pass

struct__cef_waitable_event_t._pack_ = 1 # source:False
struct__cef_waitable_event_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('reset', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_waitable_event_t))),
    ('signal', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_waitable_event_t))),
    ('is_signaled', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_waitable_event_t))),
    ('wait', ctypes.CFUNCTYPE(None, ctypes.POINTER(struct__cef_waitable_event_t))),
    ('timed_wait', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_waitable_event_t), ctypes.c_int64)),
]

# WaitableEvent is a thread synchronization tool that allows one thread to wait
# for another thread to finish some work. This is equivalent to using a
# Lock+ConditionVariable to protect a simple boolean value. However, using
# WaitableEvent in conjunction with a Lock to wait for a more complex state
# change (e.g., for an item to be added to a queue) is not recommended. In that
# case consider using a ConditionVariable instead of a WaitableEvent. It is safe
# to create and/or signal a WaitableEvent from any thread. Blocking on a
# WaitableEvent by calling the *wait() functions is not allowed on the browser
# process UI or IO threads.
# WaitableEvent is a thread synchronization tool that allows one thread to wait
# for another thread to finish some work. This is equivalent to using a
# Lock+ConditionVariable to protect a simple boolean value. However, using
# WaitableEvent in conjunction with a Lock to wait for a more complex state
# change (e.g., for an item to be added to a queue) is not recommended. In that
# case consider using a ConditionVariable instead of a WaitableEvent. It is safe
# to create and/or signal a WaitableEvent from any thread. Blocking on a
# WaitableEvent by calling the *wait() functions is not allowed on the browser
# process UI or IO threads.
cef_waitable_event_t = struct__cef_waitable_event_t
# Create a new waitable event. If |automatic_reset| is true (1) then the event
# state is automatically reset to un-signaled after a single waiting thread has
# been released; otherwise, the state remains signaled until reset() is called
# manually. If |initially_signaled| is true (1) then the event will start in the
# signaled state.
# Create a new waitable event. If |automatic_reset| is true (1) then the event
# state is automatically reset to un-signaled after a single waiting thread has
# been released; otherwise, the state remains signaled until reset() is called
# manually. If |initially_signaled| is true (1) then the event will start in the
# signaled state.
cef_waitable_event_create = _libraries['FIXME_STUB'].cef_waitable_event_create
cef_waitable_event_create.restype = ctypes.POINTER(struct__cef_waitable_event_t)
# cef_waitable_event_create(automatic_reset, initially_signaled)
cef_waitable_event_create.argtypes = [ctypes.c_int32, ctypes.c_int32]
# Structure that supports the reading of XML data via the libxml streaming API.
# The functions of this structure should only be called on the thread that
# creates the object.
class struct__cef_xml_reader_t(Structure):
    pass

struct__cef_xml_reader_t._pack_ = 1 # source:False
struct__cef_xml_reader_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('move_to_next_node', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('close', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('has_error', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_error', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_type', ctypes.CFUNCTYPE(c__EA_cef_xml_node_type_t, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_depth', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_local_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_prefix', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_qualified_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_namespace_uri', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_base_uri', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_xml_lang', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('is_empty_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('has_value', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_value', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('has_attributes', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_attribute_count', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_attribute_byindex', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.c_int32)),
    ('get_attribute_byqname', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_attribute_bylname', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('get_inner_xml', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_outer_xml', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('get_line_number', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('move_to_attribute_byindex', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.c_int32)),
    ('move_to_attribute_byqname', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('move_to_attribute_bylname', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('move_to_first_attribute', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('move_to_next_attribute', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
    ('move_to_carrying_element', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_xml_reader_t))),
]

# Structure that supports the reading of XML data via the libxml streaming API.
# The functions of this structure should only be called on the thread that
# creates the object.
# Structure that supports the reading of XML data via the libxml streaming API.
# The functions of this structure should only be called on the thread that
# creates the object.
cef_xml_reader_t = struct__cef_xml_reader_t
# Create a new cef_xml_reader_t object. The returned object's functions can only
# be called from the thread that created the object.
# Create a new cef_xml_reader_t object. The returned object's functions can only
# be called from the thread that created the object.
cef_xml_reader_create = _libraries['FIXME_STUB'].cef_xml_reader_create
cef_xml_reader_create.restype = ctypes.POINTER(struct__cef_xml_reader_t)
# cef_xml_reader_create(stream, encodingType, URI)
cef_xml_reader_create.argtypes = [ctypes.POINTER(struct__cef_stream_reader_t), cef_xml_encoding_type_t, ctypes.POINTER(struct__cef_string_utf16_t)]
# Structure that supports the reading of zip archives via the zlib unzip API.
# The functions of this structure should only be called on the thread that
# creates the object.
class struct__cef_zip_reader_t(Structure):
    pass

struct__cef_zip_reader_t._pack_ = 1 # source:False
struct__cef_zip_reader_t._fields_ = [
    ('base', cef_base_ref_counted_t),
    ('move_to_first_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('move_to_next_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('move_to_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t), ctypes.POINTER(struct__cef_string_utf16_t), ctypes.c_int32)),
    ('close', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('get_file_name', ctypes.CFUNCTYPE(ctypes.c_uint64, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('get_file_size', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('get_file_last_modified', ctypes.CFUNCTYPE(struct__cef_basetime_t, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('open_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t), ctypes.POINTER(struct__cef_string_utf16_t))),
    ('close_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('read_file', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t), ctypes.POINTER(None), ctypes.c_uint64)),
    ('tell', ctypes.CFUNCTYPE(ctypes.c_int64, ctypes.POINTER(struct__cef_zip_reader_t))),
    ('eof', ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(struct__cef_zip_reader_t))),
]

# Structure that supports the reading of zip archives via the zlib unzip API.
# The functions of this structure should only be called on the thread that
# creates the object.
# Structure that supports the reading of zip archives via the zlib unzip API.
# The functions of this structure should only be called on the thread that
# creates the object.
cef_zip_reader_t = struct__cef_zip_reader_t
# Create a new cef_zip_reader_t object. The returned object's functions can only
# be called from the thread that created the object.
# Create a new cef_zip_reader_t object. The returned object's functions can only
# be called from the thread that created the object.
cef_zip_reader_create = _libraries['FIXME_STUB'].cef_zip_reader_create
cef_zip_reader_create.restype = ctypes.POINTER(struct__cef_zip_reader_t)
# cef_zip_reader_create(stream)
cef_zip_reader_create.argtypes = [ctypes.POINTER(struct__cef_stream_reader_t)]
cef_version_info = _libraries['FIXME_STUB'].cef_version_info
cef_version_info.restype = ctypes.c_int32
# cef_version_info(entry)
cef_version_info.argtypes = [ctypes.c_int32]
class struct___darwin_pthread_handler_rec(Structure):
    pass

struct__opaque_pthread_t._pack_ = 1 # source:False
struct__opaque_pthread_t._fields_ = [
    ('__sig', ctypes.c_int64),
    ('__cleanup_stack', ctypes.POINTER(struct___darwin_pthread_handler_rec)),
    ('__opaque', ctypes.c_char * 8176),
]

struct___darwin_pthread_handler_rec._pack_ = 1 # source:False
struct___darwin_pthread_handler_rec._fields_ = [
    ('__routine', ctypes.CFUNCTYPE(None, ctypes.POINTER(None))),
    ('__arg', ctypes.POINTER(None)),
    ('__next', ctypes.POINTER(struct___darwin_pthread_handler_rec)),
]

__all__ = \
    ['CEF_ALPHA_TYPE_OPAQUE', 'CEF_ALPHA_TYPE_POSTMULTIPLIED',
    'CEF_ALPHA_TYPE_PREMULTIPLIED', 'CEF_AXIS_ALIGNMENT_CENTER',
    'CEF_AXIS_ALIGNMENT_END', 'CEF_AXIS_ALIGNMENT_START',
    'CEF_AXIS_ALIGNMENT_STRETCH', 'CEF_BUTTON_STATE_DISABLED',
    'CEF_BUTTON_STATE_HOVERED', 'CEF_BUTTON_STATE_NORMAL',
    'CEF_BUTTON_STATE_PRESSED', 'CEF_CHANNEL_LAYOUT_1_1',
    'CEF_CHANNEL_LAYOUT_2POINT1', 'CEF_CHANNEL_LAYOUT_2_1',
    'CEF_CHANNEL_LAYOUT_2_2', 'CEF_CHANNEL_LAYOUT_3_1',
    'CEF_CHANNEL_LAYOUT_3_1_BACK', 'CEF_CHANNEL_LAYOUT_4_0',
    'CEF_CHANNEL_LAYOUT_4_1', 'CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE',
    'CEF_CHANNEL_LAYOUT_5_0', 'CEF_CHANNEL_LAYOUT_5_0_BACK',
    'CEF_CHANNEL_LAYOUT_5_1', 'CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX',
    'CEF_CHANNEL_LAYOUT_5_1_BACK', 'CEF_CHANNEL_LAYOUT_6_0',
    'CEF_CHANNEL_LAYOUT_6_0_FRONT', 'CEF_CHANNEL_LAYOUT_6_1',
    'CEF_CHANNEL_LAYOUT_6_1_BACK', 'CEF_CHANNEL_LAYOUT_6_1_FRONT',
    'CEF_CHANNEL_LAYOUT_7_0', 'CEF_CHANNEL_LAYOUT_7_0_FRONT',
    'CEF_CHANNEL_LAYOUT_7_1', 'CEF_CHANNEL_LAYOUT_7_1_WIDE',
    'CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK',
    'CEF_CHANNEL_LAYOUT_BITSTREAM', 'CEF_CHANNEL_LAYOUT_DISCRETE',
    'CEF_CHANNEL_LAYOUT_HEXAGONAL', 'CEF_CHANNEL_LAYOUT_MAX',
    'CEF_CHANNEL_LAYOUT_MONO', 'CEF_CHANNEL_LAYOUT_NONE',
    'CEF_CHANNEL_LAYOUT_OCTAGONAL', 'CEF_CHANNEL_LAYOUT_QUAD',
    'CEF_CHANNEL_LAYOUT_STEREO',
    'CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC',
    'CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX',
    'CEF_CHANNEL_LAYOUT_SURROUND', 'CEF_CHANNEL_LAYOUT_UNSUPPORTED',
    'CEF_COLOR_TYPE_BGRA_8888', 'CEF_COLOR_TYPE_RGBA_8888',
    'CEF_COLOR_VARIANT_DARK', 'CEF_COLOR_VARIANT_EXPRESSIVE',
    'CEF_COLOR_VARIANT_LIGHT', 'CEF_COLOR_VARIANT_NEUTRAL',
    'CEF_COLOR_VARIANT_SYSTEM', 'CEF_COLOR_VARIANT_TONAL_SPOT',
    'CEF_COLOR_VARIANT_VIBRANT',
    'CEF_CONTENT_SETTING_TOP_LEVEL_TPCD_ORIGIN_TRIAL',
    'CEF_CONTENT_SETTING_TYPE_ADS',
    'CEF_CONTENT_SETTING_TYPE_ADS_DATA',
    'CEF_CONTENT_SETTING_TYPE_ALL_SCREEN_CAPTURE',
    'CEF_CONTENT_SETTING_TYPE_ANTI_ABUSE',
    'CEF_CONTENT_SETTING_TYPE_APP_BANNER',
    'CEF_CONTENT_SETTING_TYPE_AR',
    'CEF_CONTENT_SETTING_TYPE_AUTOMATIC_DOWNLOADS',
    'CEF_CONTENT_SETTING_TYPE_AUTOMATIC_FULLSCREEN',
    'CEF_CONTENT_SETTING_TYPE_AUTOPLAY',
    'CEF_CONTENT_SETTING_TYPE_AUTO_DARK_WEB_CONTENT',
    'CEF_CONTENT_SETTING_TYPE_AUTO_PICTURE_IN_PICTURE',
    'CEF_CONTENT_SETTING_TYPE_AUTO_SELECT_CERTIFICATE',
    'CEF_CONTENT_SETTING_TYPE_BACKGROUND_FETCH',
    'CEF_CONTENT_SETTING_TYPE_BACKGROUND_SYNC',
    'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_GUARD',
    'CEF_CONTENT_SETTING_TYPE_BLUETOOTH_SCANNING',
    'CEF_CONTENT_SETTING_TYPE_CAMERA_PAN_TILT_ZOOM',
    'CEF_CONTENT_SETTING_TYPE_CAPTURED_SURFACE_CONTROL',
    'CEF_CONTENT_SETTING_TYPE_CLIENT_HINTS',
    'CEF_CONTENT_SETTING_TYPE_CLIPBOARD_READ_WRITE',
    'CEF_CONTENT_SETTING_TYPE_CLIPBOARD_SANITIZED_WRITE',
    'CEF_CONTENT_SETTING_TYPE_COOKIES',
    'CEF_CONTENT_SETTING_TYPE_COOKIE_CONTROLS_METADATA',
    'CEF_CONTENT_SETTING_TYPE_DEPRECATED_ACCESSIBILITY_EVENTS',
    'CEF_CONTENT_SETTING_TYPE_DEPRECATED_FEDERATED_IDENTITY_ACTIVE_SESSION',
    'CEF_CONTENT_SETTING_TYPE_DEPRECATED_PPAPI_BROKER',
    'CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS',
    'CEF_CONTENT_SETTING_TYPE_DIRECT_SOCKETS_PRIVATE_NETWORK_ACCESS',
    'CEF_CONTENT_SETTING_TYPE_DISPLAY_CAPTURE',
    'CEF_CONTENT_SETTING_TYPE_DISPLAY_MEDIA_SYSTEM_AUDIO',
    'CEF_CONTENT_SETTING_TYPE_DURABLE_STORAGE',
    'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_API',
    'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_AUTO_REAUTHN_PERMISSION',
    'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_REGISTRATION',
    'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_SIGNIN_STATUS',
    'CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_SHARING',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_EXTENDED_PERMISSION',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_RESTORE_PERMISSION',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_LAST_PICKED_DIRECTORY',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_READ_GUARD',
    'CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_WRITE_GUARD',
    'CEF_CONTENT_SETTING_TYPE_FORMFILL_METADATA',
    'CEF_CONTENT_SETTING_TYPE_GEOLOCATION',
    'CEF_CONTENT_SETTING_TYPE_HAND_TRACKING',
    'CEF_CONTENT_SETTING_TYPE_HID_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_HID_GUARD',
    'CEF_CONTENT_SETTING_TYPE_HTTPS_ENFORCED',
    'CEF_CONTENT_SETTING_TYPE_HTTP_ALLOWED',
    'CEF_CONTENT_SETTING_TYPE_IDLE_DETECTION',
    'CEF_CONTENT_SETTING_TYPE_IMAGES',
    'CEF_CONTENT_SETTING_TYPE_IMPORTANT_SITE_INFO',
    'CEF_CONTENT_SETTING_TYPE_INSECURE_PRIVATE_NETWORK',
    'CEF_CONTENT_SETTING_TYPE_INTENT_PICKER_DISPLAY',
    'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT',
    'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_JIT',
    'CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_OPTIMIZER',
    'CEF_CONTENT_SETTING_TYPE_KEYBOARD_LOCK',
    'CEF_CONTENT_SETTING_TYPE_LEGACY_COOKIE_ACCESS',
    'CEF_CONTENT_SETTING_TYPE_LOCAL_FONTS',
    'CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_CAMERA',
    'CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_MIC',
    'CEF_CONTENT_SETTING_TYPE_MEDIA_ENGAGEMENT',
    'CEF_CONTENT_SETTING_TYPE_MIDI',
    'CEF_CONTENT_SETTING_TYPE_MIDI_SYSEX',
    'CEF_CONTENT_SETTING_TYPE_MIXEDSCRIPT',
    'CEF_CONTENT_SETTING_TYPE_NFC',
    'CEF_CONTENT_SETTING_TYPE_NOTIFICATIONS',
    'CEF_CONTENT_SETTING_TYPE_NOTIFICATION_INTERACTIONS',
    'CEF_CONTENT_SETTING_TYPE_NOTIFICATION_PERMISSION_REVIEW',
    'CEF_CONTENT_SETTING_TYPE_PASSWORD_PROTECTION',
    'CEF_CONTENT_SETTING_TYPE_PAYMENT_HANDLER',
    'CEF_CONTENT_SETTING_TYPE_PERIODIC_BACKGROUND_SYNC',
    'CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOBLOCKER_DATA',
    'CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOREVOCATION_DATA',
    'CEF_CONTENT_SETTING_TYPE_POINTER_LOCK',
    'CEF_CONTENT_SETTING_TYPE_POPUPS',
    'CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_GUARD',
    'CEF_CONTENT_SETTING_TYPE_PROTECTED_MEDIA_IDENTIFIER',
    'CEF_CONTENT_SETTING_TYPE_PROTOCOL_HANDLERS',
    'CEF_CONTENT_SETTING_TYPE_REDUCED_ACCEPT_LANGUAGE',
    'CEF_CONTENT_SETTING_TYPE_REQUEST_DESKTOP_SITE',
    'CEF_CONTENT_SETTING_TYPE_REVOKED_ABUSIVE_NOTIFICATION_PERMISSIONS',
    'CEF_CONTENT_SETTING_TYPE_REVOKED_UNUSED_SITE_PERMISSIONS',
    'CEF_CONTENT_SETTING_TYPE_SAFE_BROWSING_URL_CHECK_DATA',
    'CEF_CONTENT_SETTING_TYPE_SENSORS',
    'CEF_CONTENT_SETTING_TYPE_SERIAL_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_SERIAL_GUARD',
    'CEF_CONTENT_SETTING_TYPE_SITE_ENGAGEMENT',
    'CEF_CONTENT_SETTING_TYPE_SMART_CARD_DATA',
    'CEF_CONTENT_SETTING_TYPE_SMART_CARD_GUARD',
    'CEF_CONTENT_SETTING_TYPE_SOUND',
    'CEF_CONTENT_SETTING_TYPE_SPEAKER_SELECTION',
    'CEF_CONTENT_SETTING_TYPE_SSL_CERT_DECISIONS',
    'CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS',
    'CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS_HEADER_ORIGIN_TRIAL',
    'CEF_CONTENT_SETTING_TYPE_SUB_APP_INSTALLATION_PROMPTS',
    'CEF_CONTENT_SETTING_TYPE_THIRD_PARTY_STORAGE_PARTITIONING',
    'CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_STORAGE_ACCESS',
    'CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_TPCD_TRIAL',
    'CEF_CONTENT_SETTING_TYPE_TPCD_HEURISTICS_GRANTS',
    'CEF_CONTENT_SETTING_TYPE_TPCD_METADATA_GRANTS',
    'CEF_CONTENT_SETTING_TYPE_TPCD_TRIAL',
    'CEF_CONTENT_SETTING_TYPE_TRACKING_PROTECTION',
    'CEF_CONTENT_SETTING_TYPE_USB_CHOOSER_DATA',
    'CEF_CONTENT_SETTING_TYPE_USB_GUARD',
    'CEF_CONTENT_SETTING_TYPE_VR',
    'CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SCREEN',
    'CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SYSTEM',
    'CEF_CONTENT_SETTING_TYPE_WEB_APP_INSTALLATION',
    'CEF_CONTENT_SETTING_TYPE_WEB_PRINTING',
    'CEF_CONTENT_SETTING_TYPE_WINDOW_MANAGEMENT',
    'CEF_CONTENT_SETTING_VALUE_ALLOW',
    'CEF_CONTENT_SETTING_VALUE_ASK',
    'CEF_CONTENT_SETTING_VALUE_BLOCK',
    'CEF_CONTENT_SETTING_VALUE_DEFAULT',
    'CEF_CONTENT_SETTING_VALUE_DETECT_IMPORTANT_CONTENT',
    'CEF_CONTENT_SETTING_VALUE_NUM_VALUES',
    'CEF_CONTENT_SETTING_VALUE_SESSION_ONLY',
    'CEF_COOKIE_PRIORITY_HIGH', 'CEF_COOKIE_PRIORITY_LOW',
    'CEF_COOKIE_PRIORITY_MEDIUM', 'CEF_COOKIE_SAME_SITE_LAX_MODE',
    'CEF_COOKIE_SAME_SITE_NO_RESTRICTION',
    'CEF_COOKIE_SAME_SITE_STRICT_MODE',
    'CEF_COOKIE_SAME_SITE_UNSPECIFIED', 'CEF_CPAIT_BOOKMARK_STAR',
    'CEF_CPAIT_CLICK_TO_CALL', 'CEF_CPAIT_COOKIE_CONTROLS',
    'CEF_CPAIT_DISCOUNTS', 'CEF_CPAIT_FILE_SYSTEM_ACCESS',
    'CEF_CPAIT_FIND', 'CEF_CPAIT_INTENT_PICKER',
    'CEF_CPAIT_LENS_OVERLAY', 'CEF_CPAIT_LOCAL_CARD_MIGRATION',
    'CEF_CPAIT_MANAGE_PASSWORDS', 'CEF_CPAIT_MANDATORY_REAUTH',
    'CEF_CPAIT_MAX_VALUE', 'CEF_CPAIT_MEMORY_SAVER',
    'CEF_CPAIT_PAYMENTS_OFFER_NOTIFICATION',
    'CEF_CPAIT_PRICE_INSIGHTS', 'CEF_CPAIT_PRICE_READ_ANYTHING',
    'CEF_CPAIT_PRICE_TRACKING', 'CEF_CPAIT_PRODUCT_SPECIFICATIONS',
    'CEF_CPAIT_PWA_INSTALL', 'CEF_CPAIT_QR_CODE_GENERATOR_DEPRECATED',
    'CEF_CPAIT_READER_MODE_DEPRECATED',
    'CEF_CPAIT_SAVE_AUTOFILL_ADDRESS', 'CEF_CPAIT_SAVE_CARD',
    'CEF_CPAIT_SAVE_IBAN', 'CEF_CPAIT_SEND_TAB_TO_SELF_DEPRECATED',
    'CEF_CPAIT_SHARING_HUB', 'CEF_CPAIT_SIDE_SEARCH',
    'CEF_CPAIT_SMS_REMOTE_FETCHER', 'CEF_CPAIT_TRANSLATE',
    'CEF_CPAIT_VIRTUAL_CARD_ENROLL',
    'CEF_CPAIT_VIRTUAL_CARD_MANUAL_FALLBACK', 'CEF_CPAIT_ZOOM',
    'CEF_CTBT_CAST', 'CEF_CTBT_DOWNLOAD', 'CEF_CTBT_MAX_VALUE',
    'CEF_CTBT_SEND_TAB_TO_SELF', 'CEF_CTBT_SIDE_PANEL',
    'CEF_CTT_LOCATION', 'CEF_CTT_NONE', 'CEF_CTT_NORMAL',
    'CEF_CUS_DASH', 'CEF_CUS_DOT', 'CEF_CUS_NONE', 'CEF_CUS_SOLID',
    'CEF_DOCKING_MODE_BOTTOM_LEFT', 'CEF_DOCKING_MODE_BOTTOM_RIGHT',
    'CEF_DOCKING_MODE_CUSTOM', 'CEF_DOCKING_MODE_TOP_LEFT',
    'CEF_DOCKING_MODE_TOP_RIGHT',
    'CEF_DOWNLOAD_INTERRUPT_REASON_CRASH',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_BLOCKED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_FAILED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_HASH_MISMATCH',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NO_SPACE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SAME_AS_SOURCE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SECURITY_CHECK_FAILED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_SHORT',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR',
    'CEF_DOWNLOAD_INTERRUPT_REASON_FILE_VIRUS_INFECTED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_DISCONNECTED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_FAILED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_SERVER_DOWN',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT',
    'CEF_DOWNLOAD_INTERRUPT_REASON_NONE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_BAD_CONTENT',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CERT_PROBLEM',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CONTENT_LENGTH_MISMATCH',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FAILED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FORBIDDEN',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_NO_RANGE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNAUTHORIZED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNREACHABLE',
    'CEF_DOWNLOAD_INTERRUPT_REASON_USER_CANCELED',
    'CEF_DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN',
    'CEF_GESTURE_COMMAND_BACK', 'CEF_GESTURE_COMMAND_FORWARD',
    'CEF_HORIZONTAL_ALIGNMENT_CENTER',
    'CEF_HORIZONTAL_ALIGNMENT_LEFT', 'CEF_HORIZONTAL_ALIGNMENT_RIGHT',
    'CEF_MEDIA_PERMISSION_DESKTOP_AUDIO_CAPTURE',
    'CEF_MEDIA_PERMISSION_DESKTOP_VIDEO_CAPTURE',
    'CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE',
    'CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE',
    'CEF_MEDIA_PERMISSION_NONE', 'CEF_MENU_ANCHOR_BOTTOMCENTER',
    'CEF_MENU_ANCHOR_TOPLEFT', 'CEF_MENU_ANCHOR_TOPRIGHT',
    'CEF_MENU_COLOR_BACKGROUND', 'CEF_MENU_COLOR_BACKGROUND_HOVERED',
    'CEF_MENU_COLOR_COUNT', 'CEF_MENU_COLOR_TEXT',
    'CEF_MENU_COLOR_TEXT_ACCELERATOR',
    'CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED',
    'CEF_MENU_COLOR_TEXT_HOVERED', 'CEF_MRCR_CANCELLED',
    'CEF_MRCR_INVALID_ORIGIN', 'CEF_MRCR_NO_SUPPORTED_PROVIDER',
    'CEF_MRCR_OK', 'CEF_MRCR_ROUTE_ALREADY_EXISTS',
    'CEF_MRCR_ROUTE_ALREADY_TERMINATED', 'CEF_MRCR_ROUTE_NOT_FOUND',
    'CEF_MRCR_SINK_NOT_FOUND', 'CEF_MRCR_TIMED_OUT',
    'CEF_MRCR_UNKNOWN_ERROR', 'CEF_MRCS_CLOSED', 'CEF_MRCS_CONNECTED',
    'CEF_MRCS_CONNECTING', 'CEF_MRCS_TERMINATED', 'CEF_MRCS_UNKNOWN',
    'CEF_MSIT_CAST', 'CEF_MSIT_CAST_AUDIO',
    'CEF_MSIT_CAST_AUDIO_GROUP', 'CEF_MSIT_EDUCATION',
    'CEF_MSIT_GENERIC', 'CEF_MSIT_HANGOUT', 'CEF_MSIT_MEETING',
    'CEF_MSIT_TOTAL_COUNT', 'CEF_MSIT_WIRED_DISPLAY',
    'CEF_PERMISSION_RESULT_ACCEPT', 'CEF_PERMISSION_RESULT_DENY',
    'CEF_PERMISSION_RESULT_DISMISS', 'CEF_PERMISSION_RESULT_IGNORE',
    'CEF_PERMISSION_TYPE_AR_SESSION',
    'CEF_PERMISSION_TYPE_CAMERA_PAN_TILT_ZOOM',
    'CEF_PERMISSION_TYPE_CAMERA_STREAM',
    'CEF_PERMISSION_TYPE_CAPTURED_SURFACE_CONTROL',
    'CEF_PERMISSION_TYPE_CLIPBOARD', 'CEF_PERMISSION_TYPE_DISK_QUOTA',
    'CEF_PERMISSION_TYPE_FILE_SYSTEM_ACCESS',
    'CEF_PERMISSION_TYPE_GEOLOCATION',
    'CEF_PERMISSION_TYPE_HAND_TRACKING',
    'CEF_PERMISSION_TYPE_IDENTITY_PROVIDER',
    'CEF_PERMISSION_TYPE_IDLE_DETECTION',
    'CEF_PERMISSION_TYPE_KEYBOARD_LOCK',
    'CEF_PERMISSION_TYPE_LOCAL_FONTS',
    'CEF_PERMISSION_TYPE_MIC_STREAM',
    'CEF_PERMISSION_TYPE_MIDI_SYSEX',
    'CEF_PERMISSION_TYPE_MULTIPLE_DOWNLOADS',
    'CEF_PERMISSION_TYPE_NONE', 'CEF_PERMISSION_TYPE_NOTIFICATIONS',
    'CEF_PERMISSION_TYPE_POINTER_LOCK',
    'CEF_PERMISSION_TYPE_PROTECTED_MEDIA_IDENTIFIER',
    'CEF_PERMISSION_TYPE_REGISTER_PROTOCOL_HANDLER',
    'CEF_PERMISSION_TYPE_STORAGE_ACCESS',
    'CEF_PERMISSION_TYPE_TOP_LEVEL_STORAGE_ACCESS',
    'CEF_PERMISSION_TYPE_VR_SESSION',
    'CEF_PERMISSION_TYPE_WEB_APP_INSTALLATION',
    'CEF_PERMISSION_TYPE_WINDOW_MANAGEMENT',
    'CEF_POINTER_TYPE_ERASER', 'CEF_POINTER_TYPE_MOUSE',
    'CEF_POINTER_TYPE_PEN', 'CEF_POINTER_TYPE_TOUCH',
    'CEF_POINTER_TYPE_UNKNOWN', 'CEF_PREFERENCES_TYPE_GLOBAL',
    'CEF_PREFERENCES_TYPE_REQUEST_CONTEXT',
    'CEF_RESULT_CODE_CHROME_FIRST', 'CEF_RESULT_CODE_CHROME_LAST',
    'CEF_RESULT_CODE_CLOUD_POLICY_ENROLLMENT_FAILED',
    'CEF_RESULT_CODE_GPU_DEAD_ON_ARRIVAL',
    'CEF_RESULT_CODE_GPU_EXIT_ON_CONTEXT_LOST',
    'CEF_RESULT_CODE_HUNG', 'CEF_RESULT_CODE_INVALID_SANDBOX_STATE',
    'CEF_RESULT_CODE_KILLED', 'CEF_RESULT_CODE_KILLED_BAD_MESSAGE',
    'CEF_RESULT_CODE_MISSING_DATA', 'CEF_RESULT_CODE_NORMAL_EXIT',
    'CEF_RESULT_CODE_NORMAL_EXIT_PACK_EXTENSION_SUCCESS',
    'CEF_RESULT_CODE_NORMAL_EXIT_PROCESS_NOTIFIED',
    'CEF_RESULT_CODE_PACK_EXTENSION_ERROR',
    'CEF_RESULT_CODE_PROFILE_IN_USE',
    'CEF_RESULT_CODE_SANDBOX_FATAL_BROKER_SHUTDOWN_HUNG',
    'CEF_RESULT_CODE_SANDBOX_FATAL_CACHEDISABLE',
    'CEF_RESULT_CODE_SANDBOX_FATAL_CLOSEHANDLES',
    'CEF_RESULT_CODE_SANDBOX_FATAL_DROPTOKEN',
    'CEF_RESULT_CODE_SANDBOX_FATAL_FIRST',
    'CEF_RESULT_CODE_SANDBOX_FATAL_FLUSHANDLES',
    'CEF_RESULT_CODE_SANDBOX_FATAL_INTEGRITY',
    'CEF_RESULT_CODE_SANDBOX_FATAL_LAST',
    'CEF_RESULT_CODE_SANDBOX_FATAL_MEMORY_EXCEEDED',
    'CEF_RESULT_CODE_SANDBOX_FATAL_MITIGATION',
    'CEF_RESULT_CODE_SANDBOX_FATAL_WARMUP',
    'CEF_RESULT_CODE_SYSTEM_RESOURCE_EXHAUSTED',
    'CEF_RESULT_CODE_UNSUPPORTED_PARAM', 'CEF_RUNTIME_STYLE_ALLOY',
    'CEF_RUNTIME_STYLE_CHROME', 'CEF_RUNTIME_STYLE_DEFAULT',
    'CEF_SCHEME_OPTION_CORS_ENABLED',
    'CEF_SCHEME_OPTION_CSP_BYPASSING',
    'CEF_SCHEME_OPTION_DISPLAY_ISOLATED',
    'CEF_SCHEME_OPTION_FETCH_ENABLED', 'CEF_SCHEME_OPTION_LOCAL',
    'CEF_SCHEME_OPTION_NONE', 'CEF_SCHEME_OPTION_SECURE',
    'CEF_SCHEME_OPTION_STANDARD', 'CEF_SHOW_STATE_FULLSCREEN',
    'CEF_SHOW_STATE_HIDDEN', 'CEF_SHOW_STATE_MAXIMIZED',
    'CEF_SHOW_STATE_MINIMIZED', 'CEF_SHOW_STATE_NORMAL',
    'CEF_TASK_TYPE_BROWSER', 'CEF_TASK_TYPE_DEDICATED_WORKER',
    'CEF_TASK_TYPE_EXTENSION', 'CEF_TASK_TYPE_GPU',
    'CEF_TASK_TYPE_GUEST', 'CEF_TASK_TYPE_PLUGIN',
    'CEF_TASK_TYPE_RENDERER', 'CEF_TASK_TYPE_SANDBOX_HELPER',
    'CEF_TASK_TYPE_SERVICE_WORKER', 'CEF_TASK_TYPE_SHARED_WORKER',
    'CEF_TASK_TYPE_UNKNOWN', 'CEF_TASK_TYPE_UTILITY',
    'CEF_TASK_TYPE_ZYGOTE', 'CEF_TEST_CERT_EXPIRED',
    'CEF_TEST_CERT_OK_DOMAIN', 'CEF_TEST_CERT_OK_IP',
    'CEF_TET_CANCELLED', 'CEF_TET_MOVED', 'CEF_TET_PRESSED',
    'CEF_TET_RELEASED', 'CEF_TEXT_INPUT_MODE_DECIMAL',
    'CEF_TEXT_INPUT_MODE_DEFAULT', 'CEF_TEXT_INPUT_MODE_EMAIL',
    'CEF_TEXT_INPUT_MODE_MAX', 'CEF_TEXT_INPUT_MODE_NONE',
    'CEF_TEXT_INPUT_MODE_NUMERIC', 'CEF_TEXT_INPUT_MODE_SEARCH',
    'CEF_TEXT_INPUT_MODE_TEL', 'CEF_TEXT_INPUT_MODE_TEXT',
    'CEF_TEXT_INPUT_MODE_URL', 'CEF_TEXT_STYLE_BOLD',
    'CEF_TEXT_STYLE_DIAGONAL_STRIKE', 'CEF_TEXT_STYLE_ITALIC',
    'CEF_TEXT_STYLE_STRIKE', 'CEF_TEXT_STYLE_UNDERLINE',
    'CEF_TFC_COPY', 'CEF_TFC_CUT', 'CEF_TFC_DELETE', 'CEF_TFC_PASTE',
    'CEF_TFC_SELECT_ALL', 'CEF_TFC_UNDO', 'CEF_THS_FLAG_ALPHA',
    'CEF_THS_FLAG_ENABLED', 'CEF_THS_FLAG_NONE',
    'CEF_THS_FLAG_ORIENTATION', 'CEF_THS_FLAG_ORIGIN',
    'CEF_WOD_CURRENT_TAB', 'CEF_WOD_IGNORE_ACTION',
    'CEF_WOD_MAX_VALUE', 'CEF_WOD_NEW_BACKGROUND_TAB',
    'CEF_WOD_NEW_FOREGROUND_TAB', 'CEF_WOD_NEW_PICTURE_IN_PICTURE',
    'CEF_WOD_NEW_POPUP', 'CEF_WOD_NEW_WINDOW',
    'CEF_WOD_OFF_THE_RECORD', 'CEF_WOD_SAVE_TO_DISK',
    'CEF_WOD_SINGLETON_TAB', 'CEF_WOD_SWITCH_TO_TAB',
    'CEF_WOD_UNKNOWN', 'CEF_ZOOM_COMMAND_IN', 'CEF_ZOOM_COMMAND_OUT',
    'CEF_ZOOM_COMMAND_RESET', 'CERT_STATUS_AUTHORITY_INVALID',
    'CERT_STATUS_COMMON_NAME_INVALID',
    'CERT_STATUS_CT_COMPLIANCE_FAILED', 'CERT_STATUS_DATE_INVALID',
    'CERT_STATUS_INVALID', 'CERT_STATUS_IS_EV',
    'CERT_STATUS_NAME_CONSTRAINT_VIOLATION', 'CERT_STATUS_NONE',
    'CERT_STATUS_NON_UNIQUE_NAME',
    'CERT_STATUS_NO_REVOCATION_MECHANISM',
    'CERT_STATUS_PINNED_KEY_MISSING', 'CERT_STATUS_REVOKED',
    'CERT_STATUS_REV_CHECKING_ENABLED',
    'CERT_STATUS_SHA1_SIGNATURE_PRESENT',
    'CERT_STATUS_UNABLE_TO_CHECK_REVOCATION',
    'CERT_STATUS_VALIDITY_TOO_LONG', 'CERT_STATUS_WEAK_KEY',
    'CERT_STATUS_WEAK_SIGNATURE_ALGORITHM', 'CM_EDITFLAG_CAN_COPY',
    'CM_EDITFLAG_CAN_CUT', 'CM_EDITFLAG_CAN_DELETE',
    'CM_EDITFLAG_CAN_EDIT_RICHLY', 'CM_EDITFLAG_CAN_PASTE',
    'CM_EDITFLAG_CAN_REDO', 'CM_EDITFLAG_CAN_SELECT_ALL',
    'CM_EDITFLAG_CAN_TRANSLATE', 'CM_EDITFLAG_CAN_UNDO',
    'CM_EDITFLAG_NONE', 'CM_MEDIAFLAG_CAN_LOOP',
    'CM_MEDIAFLAG_CAN_PICTURE_IN_PICTURE', 'CM_MEDIAFLAG_CAN_PRINT',
    'CM_MEDIAFLAG_CAN_ROTATE', 'CM_MEDIAFLAG_CAN_SAVE',
    'CM_MEDIAFLAG_CAN_TOGGLE_CONTROLS', 'CM_MEDIAFLAG_CONTROLS',
    'CM_MEDIAFLAG_HAS_AUDIO', 'CM_MEDIAFLAG_IN_ERROR',
    'CM_MEDIAFLAG_LOOP', 'CM_MEDIAFLAG_MUTED', 'CM_MEDIAFLAG_NONE',
    'CM_MEDIAFLAG_PAUSED', 'CM_MEDIAFLAG_PICTURE_IN_PICTURE',
    'CM_MEDIATYPE_AUDIO', 'CM_MEDIATYPE_CANVAS', 'CM_MEDIATYPE_FILE',
    'CM_MEDIATYPE_IMAGE', 'CM_MEDIATYPE_NONE', 'CM_MEDIATYPE_PLUGIN',
    'CM_MEDIATYPE_VIDEO', 'CM_TYPEFLAG_EDITABLE', 'CM_TYPEFLAG_FRAME',
    'CM_TYPEFLAG_LINK', 'CM_TYPEFLAG_MEDIA', 'CM_TYPEFLAG_NONE',
    'CM_TYPEFLAG_PAGE', 'CM_TYPEFLAG_SELECTION', 'COLOR_MODEL_BLACK',
    'COLOR_MODEL_CMY', 'COLOR_MODEL_CMYK', 'COLOR_MODEL_CMY_K',
    'COLOR_MODEL_COLOR', 'COLOR_MODEL_COLORMODE_COLOR',
    'COLOR_MODEL_COLORMODE_MONOCHROME', 'COLOR_MODEL_GRAY',
    'COLOR_MODEL_GRAYSCALE', 'COLOR_MODEL_HP_COLOR_BLACK',
    'COLOR_MODEL_HP_COLOR_COLOR', 'COLOR_MODEL_KCMY',
    'COLOR_MODEL_PRINTOUTMODE_NORMAL',
    'COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY',
    'COLOR_MODEL_PROCESSCOLORMODEL_CMYK',
    'COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE',
    'COLOR_MODEL_PROCESSCOLORMODEL_RGB', 'COLOR_MODEL_RGB',
    'COLOR_MODEL_RGB16', 'COLOR_MODEL_RGBA', 'COLOR_MODEL_UNKNOWN',
    'COM_INIT_MODE_MTA', 'COM_INIT_MODE_NONE', 'COM_INIT_MODE_STA',
    'CT_ALIAS', 'CT_CELL', 'CT_COLUMNRESIZE', 'CT_CONTEXTMENU',
    'CT_COPY', 'CT_CROSS', 'CT_CUSTOM', 'CT_DND_COPY', 'CT_DND_LINK',
    'CT_DND_MOVE', 'CT_DND_NONE', 'CT_EASTPANNING', 'CT_EASTRESIZE',
    'CT_EASTWESTRESIZE', 'CT_GRAB', 'CT_GRABBING', 'CT_HAND',
    'CT_HELP', 'CT_IBEAM', 'CT_MIDDLEPANNING',
    'CT_MIDDLE_PANNING_HORIZONTAL', 'CT_MIDDLE_PANNING_VERTICAL',
    'CT_MOVE', 'CT_NODROP', 'CT_NONE', 'CT_NORTHEASTPANNING',
    'CT_NORTHEASTRESIZE', 'CT_NORTHEASTSOUTHWESTRESIZE',
    'CT_NORTHPANNING', 'CT_NORTHRESIZE', 'CT_NORTHSOUTHRESIZE',
    'CT_NORTHWESTPANNING', 'CT_NORTHWESTRESIZE',
    'CT_NORTHWESTSOUTHEASTRESIZE', 'CT_NOTALLOWED', 'CT_POINTER',
    'CT_PROGRESS', 'CT_ROWRESIZE', 'CT_SOUTHEASTPANNING',
    'CT_SOUTHEASTRESIZE', 'CT_SOUTHPANNING', 'CT_SOUTHRESIZE',
    'CT_SOUTHWESTPANNING', 'CT_SOUTHWESTRESIZE', 'CT_VERTICALTEXT',
    'CT_WAIT', 'CT_WESTPANNING', 'CT_WESTRESIZE', 'CT_ZOOMIN',
    'CT_ZOOMOUT', 'DOM_DOCUMENT_TYPE_HTML',
    'DOM_DOCUMENT_TYPE_PLUGIN', 'DOM_DOCUMENT_TYPE_UNKNOWN',
    'DOM_DOCUMENT_TYPE_XHTML',
    'DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED',
    'DOM_EVENT_CATEGORY_CLIPBOARD', 'DOM_EVENT_CATEGORY_COMPOSITION',
    'DOM_EVENT_CATEGORY_DRAG', 'DOM_EVENT_CATEGORY_KEYBOARD',
    'DOM_EVENT_CATEGORY_MESSAGE', 'DOM_EVENT_CATEGORY_MOUSE',
    'DOM_EVENT_CATEGORY_MUTATION', 'DOM_EVENT_CATEGORY_OVERFLOW',
    'DOM_EVENT_CATEGORY_PAGE_TRANSITION',
    'DOM_EVENT_CATEGORY_POPSTATE', 'DOM_EVENT_CATEGORY_PROGRESS',
    'DOM_EVENT_CATEGORY_TEXT', 'DOM_EVENT_CATEGORY_UI',
    'DOM_EVENT_CATEGORY_UNKNOWN', 'DOM_EVENT_CATEGORY_WHEEL',
    'DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS',
    'DOM_EVENT_PHASE_AT_TARGET', 'DOM_EVENT_PHASE_BUBBLING',
    'DOM_EVENT_PHASE_CAPTURING', 'DOM_EVENT_PHASE_UNKNOWN',
    'DOM_FORM_CONTROL_TYPE_BUTTON_BUTTON',
    'DOM_FORM_CONTROL_TYPE_BUTTON_POPOVER',
    'DOM_FORM_CONTROL_TYPE_BUTTON_RESET',
    'DOM_FORM_CONTROL_TYPE_BUTTON_SUBMIT',
    'DOM_FORM_CONTROL_TYPE_FIELDSET',
    'DOM_FORM_CONTROL_TYPE_INPUT_BUTTON',
    'DOM_FORM_CONTROL_TYPE_INPUT_CHECKBOX',
    'DOM_FORM_CONTROL_TYPE_INPUT_COLOR',
    'DOM_FORM_CONTROL_TYPE_INPUT_DATE',
    'DOM_FORM_CONTROL_TYPE_INPUT_DATETIME_LOCAL',
    'DOM_FORM_CONTROL_TYPE_INPUT_EMAIL',
    'DOM_FORM_CONTROL_TYPE_INPUT_FILE',
    'DOM_FORM_CONTROL_TYPE_INPUT_HIDDEN',
    'DOM_FORM_CONTROL_TYPE_INPUT_IMAGE',
    'DOM_FORM_CONTROL_TYPE_INPUT_MONTH',
    'DOM_FORM_CONTROL_TYPE_INPUT_NUMBER',
    'DOM_FORM_CONTROL_TYPE_INPUT_PASSWORD',
    'DOM_FORM_CONTROL_TYPE_INPUT_RADIO',
    'DOM_FORM_CONTROL_TYPE_INPUT_RANGE',
    'DOM_FORM_CONTROL_TYPE_INPUT_RESET',
    'DOM_FORM_CONTROL_TYPE_INPUT_SEARCH',
    'DOM_FORM_CONTROL_TYPE_INPUT_SUBMIT',
    'DOM_FORM_CONTROL_TYPE_INPUT_TELEPHONE',
    'DOM_FORM_CONTROL_TYPE_INPUT_TEXT',
    'DOM_FORM_CONTROL_TYPE_INPUT_TIME',
    'DOM_FORM_CONTROL_TYPE_INPUT_URL',
    'DOM_FORM_CONTROL_TYPE_INPUT_WEEK',
    'DOM_FORM_CONTROL_TYPE_OUTPUT',
    'DOM_FORM_CONTROL_TYPE_SELECT_MULTIPLE',
    'DOM_FORM_CONTROL_TYPE_SELECT_ONE',
    'DOM_FORM_CONTROL_TYPE_TEXT_AREA',
    'DOM_FORM_CONTROL_TYPE_UNSUPPORTED', 'DOM_NODE_TYPE_ATTRIBUTE',
    'DOM_NODE_TYPE_CDATA_SECTION', 'DOM_NODE_TYPE_COMMENT',
    'DOM_NODE_TYPE_DOCUMENT', 'DOM_NODE_TYPE_DOCUMENT_FRAGMENT',
    'DOM_NODE_TYPE_DOCUMENT_TYPE', 'DOM_NODE_TYPE_ELEMENT',
    'DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS', 'DOM_NODE_TYPE_TEXT',
    'DOM_NODE_TYPE_UNSUPPORTED', 'DRAG_OPERATION_COPY',
    'DRAG_OPERATION_DELETE', 'DRAG_OPERATION_EVERY',
    'DRAG_OPERATION_GENERIC', 'DRAG_OPERATION_LINK',
    'DRAG_OPERATION_MOVE', 'DRAG_OPERATION_NONE',
    'DRAG_OPERATION_PRIVATE', 'DUPLEX_MODE_LONG_EDGE',
    'DUPLEX_MODE_SHORT_EDGE', 'DUPLEX_MODE_SIMPLEX',
    'DUPLEX_MODE_UNKNOWN', 'ERR_ABORTED', 'ERR_ACCESS_DENIED',
    'ERR_ADDRESS_INVALID', 'ERR_ADDRESS_IN_USE',
    'ERR_ADDRESS_UNREACHABLE', 'ERR_ADD_USER_CERT_FAILED',
    'ERR_ALPN_NEGOTIATION_FAILED', 'ERR_BAD_SSL_CLIENT_AUTH_CERT',
    'ERR_BLOCKED_BY_ADMINISTRATOR', 'ERR_BLOCKED_BY_CLIENT',
    'ERR_BLOCKED_BY_CSP', 'ERR_BLOCKED_BY_ORB',
    'ERR_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_CHECKS',
    'ERR_BLOCKED_BY_RESPONSE',
    'ERR_CACHED_IP_ADDRESS_SPACE_BLOCKED_BY_PRIVATE_NETWORK_ACCESS_POLICY',
    'ERR_CACHE_AUTH_FAILURE_AFTER_READ',
    'ERR_CACHE_CHECKSUM_MISMATCH', 'ERR_CACHE_CHECKSUM_READ_FAILURE',
    'ERR_CACHE_CREATE_FAILURE', 'ERR_CACHE_DOOM_FAILURE',
    'ERR_CACHE_ENTRY_NOT_SUITABLE', 'ERR_CACHE_LOCK_TIMEOUT',
    'ERR_CACHE_MISS', 'ERR_CACHE_OPEN_FAILURE',
    'ERR_CACHE_OPEN_OR_CREATE_FAILURE',
    'ERR_CACHE_OPERATION_NOT_SUPPORTED', 'ERR_CACHE_RACE',
    'ERR_CACHE_READ_FAILURE', 'ERR_CACHE_WRITE_FAILURE',
    'ERR_CERTIFICATE_TRANSPARENCY_REQUIRED',
    'ERR_CERT_AUTHORITY_INVALID', 'ERR_CERT_COMMON_NAME_INVALID',
    'ERR_CERT_CONTAINS_ERRORS', 'ERR_CERT_DATABASE_CHANGED',
    'ERR_CERT_DATE_INVALID', 'ERR_CERT_END', 'ERR_CERT_INVALID',
    'ERR_CERT_KNOWN_INTERCEPTION_BLOCKED',
    'ERR_CERT_NAME_CONSTRAINT_VIOLATION', 'ERR_CERT_NON_UNIQUE_NAME',
    'ERR_CERT_NO_REVOCATION_MECHANISM', 'ERR_CERT_REVOKED',
    'ERR_CERT_SYMANTEC_LEGACY', 'ERR_CERT_UNABLE_TO_CHECK_REVOCATION',
    'ERR_CERT_VALIDITY_TOO_LONG', 'ERR_CERT_VERIFIER_CHANGED',
    'ERR_CERT_WEAK_KEY', 'ERR_CERT_WEAK_SIGNATURE_ALGORITHM',
    'ERR_CLEARTEXT_NOT_PERMITTED',
    'ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED', 'ERR_CONNECTION_ABORTED',
    'ERR_CONNECTION_CLOSED', 'ERR_CONNECTION_FAILED',
    'ERR_CONNECTION_REFUSED', 'ERR_CONNECTION_RESET',
    'ERR_CONNECTION_TIMED_OUT', 'ERR_CONTENT_DECODING_FAILED',
    'ERR_CONTENT_DECODING_INIT_FAILED', 'ERR_CONTENT_LENGTH_MISMATCH',
    'ERR_CONTEXT_SHUT_DOWN',
    'ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED',
    'ERR_CT_STH_INCOMPLETE', 'ERR_CT_STH_PARSING_FAILED',
    'ERR_DICTIONARY_LOAD_FAILED', 'ERR_DISALLOWED_URL_SCHEME',
    'ERR_DNS_CACHE_MISS', 'ERR_DNS_MALFORMED_RESPONSE',
    'ERR_DNS_NAME_HTTPS_ONLY', 'ERR_DNS_NO_MATCHING_SUPPORTED_ALPN',
    'ERR_DNS_REQUEST_CANCELLED', 'ERR_DNS_SEARCH_EMPTY',
    'ERR_DNS_SECURE_PROBE_RECORD_INVALID',
    'ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED',
    'ERR_DNS_SERVER_FAILED', 'ERR_DNS_SERVER_REQUIRES_TCP',
    'ERR_DNS_SORT_ERROR', 'ERR_DNS_TIMED_OUT',
    'ERR_EARLY_DATA_REJECTED', 'ERR_ECH_FALLBACK_CERTIFICATE_INVALID',
    'ERR_ECH_NOT_NEGOTIATED', 'ERR_EMPTY_RESPONSE',
    'ERR_ENCODING_CONVERSION_FAILED', 'ERR_ENCODING_DETECTION_FAILED',
    'ERR_FAILED', 'ERR_FILE_EXISTS', 'ERR_FILE_NOT_FOUND',
    'ERR_FILE_NO_SPACE', 'ERR_FILE_PATH_TOO_LONG', 'ERR_FILE_TOO_BIG',
    'ERR_FILE_VIRUS_INFECTED', 'ERR_H2_OR_QUIC_REQUIRED',
    'ERR_HOST_RESOLVER_QUEUE_TOO_LARGE',
    'ERR_HTTP2_COMPRESSION_ERROR', 'ERR_HTTP2_FLOW_CONTROL_ERROR',
    'ERR_HTTP2_FRAME_SIZE_ERROR',
    'ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY',
    'ERR_HTTP2_PING_FAILED', 'ERR_HTTP2_PROTOCOL_ERROR',
    'ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED',
    'ERR_HTTP2_SERVER_REFUSED_STREAM', 'ERR_HTTP2_STREAM_CLOSED',
    'ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT',
    'ERR_HTTP_1_1_REQUIRED', 'ERR_HTTP_RESPONSE_CODE_FAILURE',
    'ERR_ICANN_NAME_COLLISION', 'ERR_IMPORT_CA_CERT_FAILED',
    'ERR_IMPORT_CA_CERT_NOT_CA', 'ERR_IMPORT_CERT_ALREADY_EXISTS',
    'ERR_IMPORT_SERVER_CERT_FAILED',
    'ERR_INCOMPLETE_CHUNKED_ENCODING', 'ERR_INCOMPLETE_HTTP2_HEADERS',
    'ERR_INCONSISTENT_IP_ADDRESS_SPACE', 'ERR_INSECURE_RESPONSE',
    'ERR_INSUFFICIENT_RESOURCES', 'ERR_INTERNET_DISCONNECTED',
    'ERR_INVALID_ARGUMENT', 'ERR_INVALID_AUTH_CREDENTIALS',
    'ERR_INVALID_CHUNKED_ENCODING', 'ERR_INVALID_ECH_CONFIG_LIST',
    'ERR_INVALID_HANDLE', 'ERR_INVALID_HTTP_RESPONSE',
    'ERR_INVALID_REDIRECT', 'ERR_INVALID_RESPONSE',
    'ERR_INVALID_SIGNED_EXCHANGE', 'ERR_INVALID_URL',
    'ERR_INVALID_WEB_BUNDLE', 'ERR_IO_PENDING',
    'ERR_KEY_GENERATION_FAILED', 'ERR_MALFORMED_IDENTITY',
    'ERR_MANDATORY_PROXY_CONFIGURATION_FAILED',
    'ERR_METHOD_NOT_SUPPORTED', 'ERR_MISCONFIGURED_AUTH_ENVIRONMENT',
    'ERR_MISSING_AUTH_CREDENTIALS', 'ERR_MSG_TOO_BIG',
    'ERR_NAME_NOT_RESOLVED', 'ERR_NAME_RESOLUTION_FAILED',
    'ERR_NETWORK_ACCESS_DENIED', 'ERR_NETWORK_ACCESS_REVOKED',
    'ERR_NETWORK_CHANGED', 'ERR_NETWORK_IO_SUSPENDED', 'ERR_NONE',
    'ERR_NOT_IMPLEMENTED', 'ERR_NO_BUFFER_SPACE',
    'ERR_NO_PRIVATE_KEY_FOR_CERT', 'ERR_NO_SSL_VERSIONS_ENABLED',
    'ERR_NO_SUPPORTED_PROXIES', 'ERR_OUT_OF_MEMORY',
    'ERR_PAC_NOT_IN_DHCP', 'ERR_PAC_SCRIPT_FAILED',
    'ERR_PAC_SCRIPT_TERMINATED', 'ERR_PKCS12_IMPORT_BAD_PASSWORD',
    'ERR_PKCS12_IMPORT_FAILED', 'ERR_PKCS12_IMPORT_INVALID_FILE',
    'ERR_PKCS12_IMPORT_INVALID_MAC', 'ERR_PKCS12_IMPORT_UNSUPPORTED',
    'ERR_PRECONNECT_MAX_SOCKET_LIMIT',
    'ERR_PRIVATE_KEY_EXPORT_FAILED', 'ERR_PROXY_AUTH_REQUESTED',
    'ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION',
    'ERR_PROXY_AUTH_UNSUPPORTED', 'ERR_PROXY_CERTIFICATE_INVALID',
    'ERR_PROXY_CONNECTION_FAILED', 'ERR_PROXY_HTTP_1_1_REQUIRED',
    'ERR_QUIC_CERT_ROOT_NOT_KNOWN',
    'ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED',
    'ERR_QUIC_HANDSHAKE_FAILED', 'ERR_QUIC_PROTOCOL_ERROR',
    'ERR_READ_IF_READY_NOT_IMPLEMENTED',
    'ERR_REQUEST_RANGE_NOT_SATISFIABLE',
    'ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN',
    'ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION',
    'ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH',
    'ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION',
    'ERR_RESPONSE_HEADERS_TOO_BIG', 'ERR_RESPONSE_HEADERS_TRUNCATED',
    'ERR_SELF_SIGNED_CERT_GENERATION_FAILED',
    'ERR_SOCKET_IS_CONNECTED', 'ERR_SOCKET_NOT_CONNECTED',
    'ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE',
    'ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE',
    'ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR',
    'ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR',
    'ERR_SOCKS_CONNECTION_FAILED',
    'ERR_SOCKS_CONNECTION_HOST_UNREACHABLE',
    'ERR_SSL_BAD_PEER_PUBLIC_KEY', 'ERR_SSL_BAD_RECORD_MAC_ALERT',
    'ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT',
    'ERR_SSL_CLIENT_AUTH_CERT_NEEDED',
    'ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY',
    'ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS',
    'ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED',
    'ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED',
    'ERR_SSL_DECOMPRESSION_FAILURE_ALERT',
    'ERR_SSL_DECRYPT_ERROR_ALERT', 'ERR_SSL_HANDSHAKE_NOT_COMPLETED',
    'ERR_SSL_KEY_USAGE_INCOMPATIBLE', 'ERR_SSL_NO_RENEGOTIATION',
    'ERR_SSL_OBSOLETE_CIPHER', 'ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN',
    'ERR_SSL_PROTOCOL_ERROR', 'ERR_SSL_RENEGOTIATION_REQUESTED',
    'ERR_SSL_SERVER_CERT_BAD_FORMAT', 'ERR_SSL_SERVER_CERT_CHANGED',
    'ERR_SSL_UNRECOGNIZED_NAME_ALERT',
    'ERR_SSL_VERSION_OR_CIPHER_MISMATCH',
    'ERR_SYN_REPLY_NOT_RECEIVED', 'ERR_TEMPORARILY_THROTTLED',
    'ERR_TIMED_OUT', 'ERR_TLS13_DOWNGRADE_DETECTED',
    'ERR_TOO_MANY_ACCEPT_CH_RESTARTS', 'ERR_TOO_MANY_REDIRECTS',
    'ERR_TOO_MANY_RETRIES', 'ERR_TRUST_TOKEN_OPERATION_FAILED',
    'ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST',
    'ERR_TUNNEL_CONNECTION_FAILED',
    'ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH',
    'ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS', 'ERR_UNEXPECTED',
    'ERR_UNEXPECTED_CONTENT_DICTIONARY_HEADER',
    'ERR_UNEXPECTED_PROXY_AUTH',
    'ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS',
    'ERR_UNKNOWN_URL_SCHEME',
    'ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT',
    'ERR_UNSAFE_PORT', 'ERR_UNSAFE_REDIRECT',
    'ERR_UNSUPPORTED_AUTH_SCHEME', 'ERR_UPLOAD_FILE_CHANGED',
    'ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED',
    'ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES',
    'ERR_WRONG_VERSION_ON_EARLY_DATA', 'ERR_WS_PROTOCOL_ERROR',
    'ERR_WS_THROTTLE_QUEUE_TOO_LARGE', 'ERR_WS_UPGRADE',
    'ERR_ZSTD_WINDOW_SIZE_TOO_BIG', 'EVENTFLAG_ALTGR_DOWN',
    'EVENTFLAG_ALT_DOWN', 'EVENTFLAG_CAPS_LOCK_ON',
    'EVENTFLAG_COMMAND_DOWN', 'EVENTFLAG_CONTROL_DOWN',
    'EVENTFLAG_IS_KEY_PAD', 'EVENTFLAG_IS_LEFT',
    'EVENTFLAG_IS_REPEAT', 'EVENTFLAG_IS_RIGHT',
    'EVENTFLAG_LEFT_MOUSE_BUTTON', 'EVENTFLAG_MIDDLE_MOUSE_BUTTON',
    'EVENTFLAG_NONE', 'EVENTFLAG_NUM_LOCK_ON',
    'EVENTFLAG_RIGHT_MOUSE_BUTTON', 'EVENTFLAG_SHIFT_DOWN',
    'FILE_DIALOG_OPEN', 'FILE_DIALOG_OPEN_FOLDER',
    'FILE_DIALOG_OPEN_MULTIPLE', 'FILE_DIALOG_SAVE',
    'FOCUS_SOURCE_NAVIGATION', 'FOCUS_SOURCE_SYSTEM',
    'JSDIALOGTYPE_ALERT', 'JSDIALOGTYPE_CONFIRM',
    'JSDIALOGTYPE_PROMPT', 'JSON_PARSER_ALLOW_TRAILING_COMMAS',
    'JSON_PARSER_RFC', 'JSON_WRITER_DEFAULT',
    'JSON_WRITER_OMIT_BINARY_VALUES',
    'JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION',
    'JSON_WRITER_PRETTY_PRINT', 'KEYEVENT_CHAR', 'KEYEVENT_KEYDOWN',
    'KEYEVENT_KEYUP', 'KEYEVENT_RAWKEYDOWN', 'LOGSEVERITY_DEBUG',
    'LOGSEVERITY_DEFAULT', 'LOGSEVERITY_DISABLE', 'LOGSEVERITY_ERROR',
    'LOGSEVERITY_FATAL', 'LOGSEVERITY_INFO', 'LOGSEVERITY_VERBOSE',
    'LOGSEVERITY_WARNING', 'LOG_ITEMS_DEFAULT',
    'LOG_ITEMS_FLAG_PROCESS_ID', 'LOG_ITEMS_FLAG_THREAD_ID',
    'LOG_ITEMS_FLAG_TICK_COUNT', 'LOG_ITEMS_FLAG_TIME_STAMP',
    'LOG_ITEMS_NONE', 'MBT_LEFT', 'MBT_MIDDLE', 'MBT_RIGHT',
    'MENUITEMTYPE_CHECK', 'MENUITEMTYPE_COMMAND', 'MENUITEMTYPE_NONE',
    'MENUITEMTYPE_RADIO', 'MENUITEMTYPE_SEPARATOR',
    'MENUITEMTYPE_SUBMENU', 'MENU_ID_ADD_TO_DICTIONARY',
    'MENU_ID_BACK', 'MENU_ID_COPY', 'MENU_ID_CUSTOM_FIRST',
    'MENU_ID_CUSTOM_LAST', 'MENU_ID_CUT', 'MENU_ID_DELETE',
    'MENU_ID_FIND', 'MENU_ID_FORWARD',
    'MENU_ID_NO_SPELLING_SUGGESTIONS', 'MENU_ID_PASTE',
    'MENU_ID_PASTE_MATCH_STYLE', 'MENU_ID_PRINT', 'MENU_ID_REDO',
    'MENU_ID_RELOAD', 'MENU_ID_RELOAD_NOCACHE', 'MENU_ID_SELECT_ALL',
    'MENU_ID_SPELLCHECK_SUGGESTION_0',
    'MENU_ID_SPELLCHECK_SUGGESTION_1',
    'MENU_ID_SPELLCHECK_SUGGESTION_2',
    'MENU_ID_SPELLCHECK_SUGGESTION_3',
    'MENU_ID_SPELLCHECK_SUGGESTION_4',
    'MENU_ID_SPELLCHECK_SUGGESTION_LAST', 'MENU_ID_STOPLOAD',
    'MENU_ID_UNDO', 'MENU_ID_USER_FIRST', 'MENU_ID_USER_LAST',
    'MENU_ID_VIEW_SOURCE', 'ML_TYPE_DEFAULT', 'ML_TYPE_IO',
    'ML_TYPE_UI', 'NAVIGATION_BACK_FORWARD',
    'NAVIGATION_FORM_RESUBMITTED', 'NAVIGATION_FORM_SUBMITTED',
    'NAVIGATION_LINK_CLICKED', 'NAVIGATION_OTHER',
    'NAVIGATION_RELOAD', 'PDE_TYPE_BYTES', 'PDE_TYPE_EMPTY',
    'PDE_TYPE_FILE', 'PDF_PRINT_MARGIN_CUSTOM',
    'PDF_PRINT_MARGIN_DEFAULT', 'PDF_PRINT_MARGIN_NONE', 'PET_POPUP',
    'PET_VIEW', 'PID_BROWSER', 'PID_RENDERER', 'PK_DIR_CURRENT',
    'PK_DIR_EXE', 'PK_DIR_MODULE', 'PK_DIR_RESOURCES', 'PK_DIR_TEMP',
    'PK_FILE_EXE', 'PK_FILE_MODULE', 'PK_LOCAL_APP_DATA',
    'PK_USER_DATA', 'QM_EDITFLAG_CAN_COPY', 'QM_EDITFLAG_CAN_CUT',
    'QM_EDITFLAG_CAN_ELLIPSIS', 'QM_EDITFLAG_CAN_PASTE',
    'QM_EDITFLAG_NONE',
    'REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN',
    'REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE',
    'REFERRER_POLICY_DEFAULT', 'REFERRER_POLICY_LAST_VALUE',
    'REFERRER_POLICY_NEVER_CLEAR_REFERRER',
    'REFERRER_POLICY_NO_REFERRER', 'REFERRER_POLICY_ORIGIN',
    'REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE',
    'REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN',
    'REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN',
    'RESPONSE_FILTER_DONE', 'RESPONSE_FILTER_ERROR',
    'RESPONSE_FILTER_NEED_MORE_DATA', 'RT_CSP_REPORT', 'RT_FAVICON',
    'RT_FONT_RESOURCE', 'RT_IMAGE', 'RT_MAIN_FRAME', 'RT_MEDIA',
    'RT_NAVIGATION_PRELOAD_MAIN_FRAME',
    'RT_NAVIGATION_PRELOAD_SUB_FRAME', 'RT_OBJECT', 'RT_PING',
    'RT_PLUGIN_RESOURCE', 'RT_PREFETCH', 'RT_SCRIPT',
    'RT_SERVICE_WORKER', 'RT_SHARED_WORKER', 'RT_STYLESHEET',
    'RT_SUB_FRAME', 'RT_SUB_RESOURCE', 'RT_WORKER', 'RT_XHR',
    'RV_CANCEL', 'RV_CONTINUE', 'RV_CONTINUE_ASYNC',
    'SCALE_FACTOR_100P', 'SCALE_FACTOR_125P', 'SCALE_FACTOR_133P',
    'SCALE_FACTOR_140P', 'SCALE_FACTOR_150P', 'SCALE_FACTOR_180P',
    'SCALE_FACTOR_200P', 'SCALE_FACTOR_250P', 'SCALE_FACTOR_300P',
    'SCALE_FACTOR_NONE', 'SSL_CONNECTION_VERSION_QUIC',
    'SSL_CONNECTION_VERSION_SSL2', 'SSL_CONNECTION_VERSION_SSL3',
    'SSL_CONNECTION_VERSION_TLS1', 'SSL_CONNECTION_VERSION_TLS1_1',
    'SSL_CONNECTION_VERSION_TLS1_2', 'SSL_CONNECTION_VERSION_TLS1_3',
    'SSL_CONNECTION_VERSION_UNKNOWN',
    'SSL_CONTENT_DISPLAYED_INSECURE_CONTENT',
    'SSL_CONTENT_NORMAL_CONTENT', 'SSL_CONTENT_RAN_INSECURE_CONTENT',
    'STATE_DEFAULT', 'STATE_DISABLED', 'STATE_ENABLED',
    'ST_LOCALSTORAGE', 'ST_SESSIONSTORAGE', 'TID_FILE_BACKGROUND',
    'TID_FILE_USER_BLOCKING', 'TID_FILE_USER_VISIBLE', 'TID_IO',
    'TID_PROCESS_LAUNCHER', 'TID_RENDERER', 'TID_UI', 'TP_BACKGROUND',
    'TP_DISPLAY', 'TP_NORMAL', 'TP_REALTIME_AUDIO',
    'TS_ABNORMAL_TERMINATION', 'TS_INTEGRITY_FAILURE',
    'TS_LAUNCH_FAILED', 'TS_PROCESS_CRASHED', 'TS_PROCESS_OOM',
    'TS_PROCESS_WAS_KILLED', 'TT_AUTO_BOOKMARK', 'TT_AUTO_SUBFRAME',
    'TT_AUTO_TOPLEVEL', 'TT_BLOCKED_FLAG', 'TT_CHAIN_END_FLAG',
    'TT_CHAIN_START_FLAG', 'TT_CLIENT_REDIRECT_FLAG',
    'TT_DIRECT_LOAD_FLAG', 'TT_EXPLICIT', 'TT_FORM_SUBMIT',
    'TT_FORWARD_BACK_FLAG', 'TT_FROM_API_FLAG', 'TT_GENERATED',
    'TT_HOME_PAGE_FLAG', 'TT_IS_REDIRECT_MASK', 'TT_KEYWORD',
    'TT_KEYWORD_GENERATED', 'TT_LINK', 'TT_MANUAL_SUBFRAME',
    'TT_QUALIFIER_MASK', 'TT_RELOAD', 'TT_SERVER_REDIRECT_FLAG',
    'TT_SOURCE_MASK', 'UR_CANCELED', 'UR_FAILED',
    'UR_FLAG_ALLOW_STORED_CREDENTIALS', 'UR_FLAG_DISABLE_CACHE',
    'UR_FLAG_NONE', 'UR_FLAG_NO_DOWNLOAD_DATA',
    'UR_FLAG_NO_RETRY_ON_5XX', 'UR_FLAG_ONLY_FROM_CACHE',
    'UR_FLAG_REPORT_UPLOAD_PROGRESS', 'UR_FLAG_SKIP_CACHE',
    'UR_FLAG_STOP_ON_REDIRECT', 'UR_IO_PENDING', 'UR_SUCCESS',
    'UR_UNKNOWN', 'UU_NONE', 'UU_NORMAL', 'UU_PATH_SEPARATORS',
    'UU_REPLACE_PLUS_WITH_SPACE', 'UU_SPACES',
    'UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS',
    'V8_PROPERTY_ATTRIBUTE_DONTDELETE',
    'V8_PROPERTY_ATTRIBUTE_DONTENUM', 'V8_PROPERTY_ATTRIBUTE_NONE',
    'V8_PROPERTY_ATTRIBUTE_READONLY', 'VTYPE_BINARY', 'VTYPE_BOOL',
    'VTYPE_DICTIONARY', 'VTYPE_DOUBLE', 'VTYPE_INT', 'VTYPE_INVALID',
    'VTYPE_LIST', 'VTYPE_NULL', 'VTYPE_STRING', 'XML_ENCODING_ASCII',
    'XML_ENCODING_NONE', 'XML_ENCODING_UTF16BE',
    'XML_ENCODING_UTF16LE', 'XML_ENCODING_UTF8', 'XML_NODE_ATTRIBUTE',
    'XML_NODE_CDATA', 'XML_NODE_COMMENT', 'XML_NODE_DOCUMENT_TYPE',
    'XML_NODE_ELEMENT_END', 'XML_NODE_ELEMENT_START',
    'XML_NODE_ENTITY_REFERENCE', 'XML_NODE_PROCESSING_INSTRUCTION',
    'XML_NODE_TEXT', 'XML_NODE_UNSUPPORTED', 'XML_NODE_WHITESPACE',
    'c__EA_cef_alpha_type_t', 'c__EA_cef_axis_alignment_t',
    'c__EA_cef_button_state_t', 'c__EA_cef_cert_status_t',
    'c__EA_cef_channel_layout_t',
    'c__EA_cef_chrome_page_action_icon_type_t',
    'c__EA_cef_chrome_toolbar_button_type_t',
    'c__EA_cef_chrome_toolbar_type_t', 'c__EA_cef_color_model_t',
    'c__EA_cef_color_type_t', 'c__EA_cef_color_variant_t',
    'c__EA_cef_com_init_mode_t',
    'c__EA_cef_composition_underline_style_t',
    'c__EA_cef_content_setting_types_t',
    'c__EA_cef_content_setting_values_t',
    'c__EA_cef_context_menu_edit_state_flags_t',
    'c__EA_cef_context_menu_media_state_flags_t',
    'c__EA_cef_context_menu_media_type_t',
    'c__EA_cef_context_menu_type_flags_t',
    'c__EA_cef_cookie_priority_t', 'c__EA_cef_cookie_same_site_t',
    'c__EA_cef_cursor_type_t', 'c__EA_cef_docking_mode_t',
    'c__EA_cef_dom_document_type_t', 'c__EA_cef_dom_event_category_t',
    'c__EA_cef_dom_event_phase_t',
    'c__EA_cef_dom_form_control_type_t', 'c__EA_cef_dom_node_type_t',
    'c__EA_cef_download_interrupt_reason_t',
    'c__EA_cef_drag_operations_mask_t', 'c__EA_cef_duplex_mode_t',
    'c__EA_cef_errorcode_t', 'c__EA_cef_event_flags_t',
    'c__EA_cef_file_dialog_mode_t', 'c__EA_cef_focus_source_t',
    'c__EA_cef_gesture_command_t', 'c__EA_cef_horizontal_alignment_t',
    'c__EA_cef_jsdialog_type_t', 'c__EA_cef_json_parser_options_t',
    'c__EA_cef_json_writer_options_t', 'c__EA_cef_key_event_type_t',
    'c__EA_cef_log_items_t', 'c__EA_cef_log_severity_t',
    'c__EA_cef_media_access_permission_types_t',
    'c__EA_cef_media_route_connection_state_t',
    'c__EA_cef_media_route_create_result_t',
    'c__EA_cef_media_sink_icon_type_t',
    'c__EA_cef_menu_anchor_position_t', 'c__EA_cef_menu_color_type_t',
    'c__EA_cef_menu_id_t', 'c__EA_cef_menu_item_type_t',
    'c__EA_cef_message_loop_type_t', 'c__EA_cef_mouse_button_type_t',
    'c__EA_cef_navigation_type_t', 'c__EA_cef_paint_element_type_t',
    'c__EA_cef_path_key_t', 'c__EA_cef_pdf_print_margin_type_t',
    'c__EA_cef_permission_request_result_t',
    'c__EA_cef_permission_request_types_t',
    'c__EA_cef_pointer_type_t', 'c__EA_cef_postdataelement_type_t',
    'c__EA_cef_preferences_type_t', 'c__EA_cef_process_id_t',
    'c__EA_cef_quick_menu_edit_state_flags_t',
    'c__EA_cef_referrer_policy_t', 'c__EA_cef_resource_type_t',
    'c__EA_cef_response_filter_status_t', 'c__EA_cef_resultcode_t',
    'c__EA_cef_return_value_t', 'c__EA_cef_runtime_style_t',
    'c__EA_cef_scale_factor_t', 'c__EA_cef_scheme_options_t',
    'c__EA_cef_show_state_t', 'c__EA_cef_ssl_content_status_t',
    'c__EA_cef_ssl_version_t', 'c__EA_cef_state_t',
    'c__EA_cef_storage_type_t', 'c__EA_cef_task_type_t',
    'c__EA_cef_termination_status_t', 'c__EA_cef_test_cert_type_t',
    'c__EA_cef_text_field_commands_t', 'c__EA_cef_text_input_mode_t',
    'c__EA_cef_text_style_t', 'c__EA_cef_thread_id_t',
    'c__EA_cef_thread_priority_t', 'c__EA_cef_touch_event_type_t',
    'c__EA_cef_touch_handle_state_flags_t',
    'c__EA_cef_transition_type_t', 'c__EA_cef_uri_unescape_rule_t',
    'c__EA_cef_urlrequest_flags_t', 'c__EA_cef_urlrequest_status_t',
    'c__EA_cef_v8_propertyattribute_t', 'c__EA_cef_value_type_t',
    'c__EA_cef_window_open_disposition_t',
    'c__EA_cef_xml_encoding_type_t', 'c__EA_cef_xml_node_type_t',
    'c__EA_cef_zoom_command_t', 'cef_accelerated_paint_info_t',
    'cef_accessibility_handler_t',
    'cef_add_cross_origin_whitelist_entry', 'cef_alpha_type_t',
    'cef_alpha_type_t__enumvalues', 'cef_app_t',
    'cef_audio_handler_t', 'cef_audio_parameters_t',
    'cef_auth_callback_t', 'cef_axis_alignment_t',
    'cef_axis_alignment_t__enumvalues', 'cef_base64decode',
    'cef_base64encode', 'cef_base_ref_counted_t', 'cef_base_scoped_t',
    'cef_basetime_now', 'cef_basetime_t',
    'cef_before_download_callback_t', 'cef_begin_tracing',
    'cef_binary_value_create', 'cef_binary_value_t',
    'cef_box_layout_settings_t', 'cef_browser_host_create_browser',
    'cef_browser_host_create_browser_sync',
    'cef_browser_host_get_browser_by_identifier',
    'cef_browser_host_t', 'cef_browser_process_handler_t',
    'cef_browser_settings_t', 'cef_browser_t', 'cef_button_state_t',
    'cef_button_state_t__enumvalues', 'cef_callback_t',
    'cef_cert_status_t', 'cef_cert_status_t__enumvalues',
    'cef_channel_layout_t', 'cef_channel_layout_t__enumvalues',
    'cef_char_t', 'cef_chrome_page_action_icon_type_t',
    'cef_chrome_page_action_icon_type_t__enumvalues',
    'cef_chrome_toolbar_button_type_t',
    'cef_chrome_toolbar_button_type_t__enumvalues',
    'cef_chrome_toolbar_type_t',
    'cef_chrome_toolbar_type_t__enumvalues',
    'cef_clear_cross_origin_whitelist',
    'cef_clear_scheme_handler_factories', 'cef_client_t',
    'cef_color_model_t', 'cef_color_model_t__enumvalues',
    'cef_color_t', 'cef_color_type_t', 'cef_color_type_t__enumvalues',
    'cef_color_variant_t', 'cef_color_variant_t__enumvalues',
    'cef_com_init_mode_t', 'cef_com_init_mode_t__enumvalues',
    'cef_command_handler_t', 'cef_command_line_create',
    'cef_command_line_get_global', 'cef_command_line_t',
    'cef_completion_callback_t', 'cef_composition_underline_style_t',
    'cef_composition_underline_style_t__enumvalues',
    'cef_composition_underline_t', 'cef_content_setting_types_t',
    'cef_content_setting_types_t__enumvalues',
    'cef_content_setting_values_t',
    'cef_content_setting_values_t__enumvalues',
    'cef_context_menu_edit_state_flags_t',
    'cef_context_menu_edit_state_flags_t__enumvalues',
    'cef_context_menu_handler_t',
    'cef_context_menu_media_state_flags_t',
    'cef_context_menu_media_state_flags_t__enumvalues',
    'cef_context_menu_media_type_t',
    'cef_context_menu_media_type_t__enumvalues',
    'cef_context_menu_params_t', 'cef_context_menu_type_flags_t',
    'cef_context_menu_type_flags_t__enumvalues',
    'cef_cookie_access_filter_t',
    'cef_cookie_manager_get_global_manager', 'cef_cookie_manager_t',
    'cef_cookie_priority_t', 'cef_cookie_priority_t__enumvalues',
    'cef_cookie_same_site_t', 'cef_cookie_same_site_t__enumvalues',
    'cef_cookie_t', 'cef_cookie_visitor_t',
    'cef_crash_reporting_enabled', 'cef_create_context_shared',
    'cef_create_directory', 'cef_create_new_temp_directory',
    'cef_create_temp_directory_in_directory', 'cef_create_url',
    'cef_currently_on', 'cef_cursor_info_t', 'cef_cursor_type_t',
    'cef_cursor_type_t__enumvalues', 'cef_delete_cookies_callback_t',
    'cef_delete_file', 'cef_dev_tools_message_observer_t',
    'cef_dialog_handler_t', 'cef_dictionary_value_create',
    'cef_dictionary_value_t', 'cef_directory_exists',
    'cef_display_handler_t', 'cef_do_message_loop_work',
    'cef_docking_mode_t', 'cef_docking_mode_t__enumvalues',
    'cef_dom_document_type_t', 'cef_dom_document_type_t__enumvalues',
    'cef_dom_event_category_t',
    'cef_dom_event_category_t__enumvalues', 'cef_dom_event_phase_t',
    'cef_dom_event_phase_t__enumvalues',
    'cef_dom_form_control_type_t',
    'cef_dom_form_control_type_t__enumvalues', 'cef_dom_node_type_t',
    'cef_dom_node_type_t__enumvalues', 'cef_domdocument_t',
    'cef_domnode_t', 'cef_domvisitor_t', 'cef_download_handler_t',
    'cef_download_image_callback_t',
    'cef_download_interrupt_reason_t',
    'cef_download_interrupt_reason_t__enumvalues',
    'cef_download_item_callback_t', 'cef_download_item_t',
    'cef_drag_data_create', 'cef_drag_data_t', 'cef_drag_handler_t',
    'cef_drag_operations_mask_t',
    'cef_drag_operations_mask_t__enumvalues',
    'cef_draggable_region_t', 'cef_duplex_mode_t',
    'cef_duplex_mode_t__enumvalues', 'cef_end_tracing',
    'cef_end_tracing_callback_t', 'cef_errorcode_t',
    'cef_errorcode_t__enumvalues', 'cef_event_flags_t',
    'cef_event_flags_t__enumvalues', 'cef_execute_process',
    'cef_file_dialog_callback_t', 'cef_file_dialog_mode_t',
    'cef_file_dialog_mode_t__enumvalues', 'cef_find_handler_t',
    'cef_focus_handler_t', 'cef_focus_source_t',
    'cef_focus_source_t__enumvalues',
    'cef_format_url_for_security_display', 'cef_frame_handler_t',
    'cef_frame_t', 'cef_gesture_command_t',
    'cef_gesture_command_t__enumvalues',
    'cef_get_current_platform_thread_handle',
    'cef_get_current_platform_thread_id', 'cef_get_exit_code',
    'cef_get_extensions_for_mime_type', 'cef_get_mime_type',
    'cef_get_path', 'cef_get_temp_directory',
    'cef_horizontal_alignment_t',
    'cef_horizontal_alignment_t__enumvalues', 'cef_image_create',
    'cef_image_t', 'cef_initialize', 'cef_insets_t',
    'cef_is_cert_status_error', 'cef_is_rtl',
    'cef_jsdialog_callback_t', 'cef_jsdialog_handler_t',
    'cef_jsdialog_type_t', 'cef_jsdialog_type_t__enumvalues',
    'cef_json_parser_options_t',
    'cef_json_parser_options_t__enumvalues',
    'cef_json_writer_options_t',
    'cef_json_writer_options_t__enumvalues', 'cef_key_event_t',
    'cef_key_event_type_t', 'cef_key_event_type_t__enumvalues',
    'cef_keyboard_handler_t', 'cef_launch_process',
    'cef_life_span_handler_t', 'cef_linux_window_properties_t',
    'cef_list_value_create', 'cef_list_value_t',
    'cef_load_crlsets_file', 'cef_load_handler_t', 'cef_log_items_t',
    'cef_log_items_t__enumvalues', 'cef_log_severity_t',
    'cef_log_severity_t__enumvalues', 'cef_main_args_t',
    'cef_media_access_callback_t',
    'cef_media_access_permission_types_t',
    'cef_media_access_permission_types_t__enumvalues',
    'cef_media_observer_t', 'cef_media_route_connection_state_t',
    'cef_media_route_connection_state_t__enumvalues',
    'cef_media_route_create_callback_t',
    'cef_media_route_create_result_t',
    'cef_media_route_create_result_t__enumvalues',
    'cef_media_route_t', 'cef_media_router_get_global',
    'cef_media_router_t', 'cef_media_sink_device_info_callback_t',
    'cef_media_sink_device_info_t', 'cef_media_sink_icon_type_t',
    'cef_media_sink_icon_type_t__enumvalues', 'cef_media_sink_t',
    'cef_media_source_t', 'cef_menu_anchor_position_t',
    'cef_menu_anchor_position_t__enumvalues', 'cef_menu_color_type_t',
    'cef_menu_color_type_t__enumvalues', 'cef_menu_id_t',
    'cef_menu_id_t__enumvalues', 'cef_menu_item_type_t',
    'cef_menu_item_type_t__enumvalues', 'cef_menu_model_create',
    'cef_menu_model_delegate_t', 'cef_menu_model_t',
    'cef_message_loop_type_t', 'cef_message_loop_type_t__enumvalues',
    'cef_mouse_button_type_t', 'cef_mouse_button_type_t__enumvalues',
    'cef_mouse_event_t', 'cef_navigation_entry_t',
    'cef_navigation_entry_visitor_t', 'cef_navigation_type_t',
    'cef_navigation_type_t__enumvalues',
    'cef_now_from_system_trace_time', 'cef_paint_element_type_t',
    'cef_paint_element_type_t__enumvalues', 'cef_parse_json',
    'cef_parse_json_buffer', 'cef_parse_jsonand_return_error',
    'cef_parse_url', 'cef_path_key_t', 'cef_path_key_t__enumvalues',
    'cef_pdf_print_callback_t', 'cef_pdf_print_margin_type_t',
    'cef_pdf_print_margin_type_t__enumvalues',
    'cef_pdf_print_settings_t', 'cef_permission_handler_t',
    'cef_permission_prompt_callback_t',
    'cef_permission_request_result_t',
    'cef_permission_request_result_t__enumvalues',
    'cef_permission_request_types_t',
    'cef_permission_request_types_t__enumvalues',
    'cef_platform_thread_handle_t', 'cef_platform_thread_id_t',
    'cef_point_t', 'cef_pointer_type_t',
    'cef_pointer_type_t__enumvalues', 'cef_popup_features_t',
    'cef_post_data_create', 'cef_post_data_element_create',
    'cef_post_data_element_t', 'cef_post_data_t',
    'cef_post_delayed_task', 'cef_post_task',
    'cef_postdataelement_type_t',
    'cef_postdataelement_type_t__enumvalues',
    'cef_preference_manager_get_global', 'cef_preference_manager_t',
    'cef_preference_registrar_t', 'cef_preferences_type_t',
    'cef_preferences_type_t__enumvalues',
    'cef_print_dialog_callback_t', 'cef_print_handler_t',
    'cef_print_job_callback_t', 'cef_print_settings_create',
    'cef_print_settings_t', 'cef_process_id_t',
    'cef_process_id_t__enumvalues', 'cef_process_message_create',
    'cef_process_message_t', 'cef_quick_menu_edit_state_flags_t',
    'cef_quick_menu_edit_state_flags_t__enumvalues',
    'cef_quit_message_loop', 'cef_range_t', 'cef_read_handler_t',
    'cef_rect_t', 'cef_referrer_policy_t',
    'cef_referrer_policy_t__enumvalues', 'cef_register_extension',
    'cef_register_scheme_handler_factory', 'cef_registration_t',
    'cef_remove_cross_origin_whitelist_entry', 'cef_render_handler_t',
    'cef_render_process_handler_t',
    'cef_request_context_create_context',
    'cef_request_context_get_global_context',
    'cef_request_context_handler_t', 'cef_request_context_settings_t',
    'cef_request_context_t', 'cef_request_create',
    'cef_request_handler_t', 'cef_request_t',
    'cef_resolve_callback_t', 'cef_resolve_url',
    'cef_resource_bundle_get_global', 'cef_resource_bundle_handler_t',
    'cef_resource_bundle_t', 'cef_resource_handler_t',
    'cef_resource_read_callback_t', 'cef_resource_request_handler_t',
    'cef_resource_skip_callback_t', 'cef_resource_type_t',
    'cef_resource_type_t__enumvalues', 'cef_response_create',
    'cef_response_filter_status_t',
    'cef_response_filter_status_t__enumvalues',
    'cef_response_filter_t', 'cef_response_t', 'cef_resultcode_t',
    'cef_resultcode_t__enumvalues', 'cef_return_value_t',
    'cef_return_value_t__enumvalues',
    'cef_run_context_menu_callback_t',
    'cef_run_file_dialog_callback_t', 'cef_run_message_loop',
    'cef_run_quick_menu_callback_t', 'cef_runtime_style_t',
    'cef_runtime_style_t__enumvalues', 'cef_scale_factor_t',
    'cef_scale_factor_t__enumvalues', 'cef_scheme_handler_factory_t',
    'cef_scheme_options_t', 'cef_scheme_options_t__enumvalues',
    'cef_scheme_registrar_t', 'cef_screen_info_t',
    'cef_select_client_certificate_callback_t', 'cef_server_create',
    'cef_server_handler_t', 'cef_server_t',
    'cef_set_cookie_callback_t', 'cef_set_crash_key_value',
    'cef_settings_t', 'cef_shared_memory_region_t',
    'cef_shared_process_message_builder_create',
    'cef_shared_process_message_builder_t', 'cef_show_state_t',
    'cef_show_state_t__enumvalues', 'cef_shutdown', 'cef_size_t',
    'cef_ssl_content_status_t',
    'cef_ssl_content_status_t__enumvalues', 'cef_ssl_version_t',
    'cef_ssl_version_t__enumvalues', 'cef_sslinfo_t',
    'cef_sslstatus_t', 'cef_state_t', 'cef_state_t__enumvalues',
    'cef_storage_type_t', 'cef_storage_type_t__enumvalues',
    'cef_stream_reader_create_for_data',
    'cef_stream_reader_create_for_file',
    'cef_stream_reader_create_for_handler', 'cef_stream_reader_t',
    'cef_stream_writer_create_for_file',
    'cef_stream_writer_create_for_handler', 'cef_stream_writer_t',
    'cef_string_ascii_to_utf16', 'cef_string_ascii_to_wide',
    'cef_string_list_alloc', 'cef_string_list_append',
    'cef_string_list_clear', 'cef_string_list_copy',
    'cef_string_list_free', 'cef_string_list_size',
    'cef_string_list_t', 'cef_string_list_value',
    'cef_string_map_alloc', 'cef_string_map_append',
    'cef_string_map_clear', 'cef_string_map_find',
    'cef_string_map_free', 'cef_string_map_key',
    'cef_string_map_size', 'cef_string_map_t', 'cef_string_map_value',
    'cef_string_multimap_alloc', 'cef_string_multimap_append',
    'cef_string_multimap_clear', 'cef_string_multimap_enumerate',
    'cef_string_multimap_find_count', 'cef_string_multimap_free',
    'cef_string_multimap_key', 'cef_string_multimap_size',
    'cef_string_multimap_t', 'cef_string_multimap_value',
    'cef_string_t', 'cef_string_userfree_t',
    'cef_string_userfree_utf16_alloc',
    'cef_string_userfree_utf16_free', 'cef_string_userfree_utf16_t',
    'cef_string_userfree_utf8_alloc', 'cef_string_userfree_utf8_free',
    'cef_string_userfree_utf8_t', 'cef_string_userfree_wide_alloc',
    'cef_string_userfree_wide_free', 'cef_string_userfree_wide_t',
    'cef_string_utf16_clear', 'cef_string_utf16_cmp',
    'cef_string_utf16_set', 'cef_string_utf16_t',
    'cef_string_utf16_to_lower', 'cef_string_utf16_to_upper',
    'cef_string_utf16_to_utf8', 'cef_string_utf16_to_wide',
    'cef_string_utf8_clear', 'cef_string_utf8_cmp',
    'cef_string_utf8_set', 'cef_string_utf8_t',
    'cef_string_utf8_to_utf16', 'cef_string_utf8_to_wide',
    'cef_string_visitor_t', 'cef_string_wide_clear',
    'cef_string_wide_cmp', 'cef_string_wide_set', 'cef_string_wide_t',
    'cef_string_wide_to_utf16', 'cef_string_wide_to_utf8',
    'cef_task_info_t', 'cef_task_manager_get', 'cef_task_manager_t',
    'cef_task_runner_get_for_current_thread',
    'cef_task_runner_get_for_thread', 'cef_task_runner_t',
    'cef_task_t', 'cef_task_type_t', 'cef_task_type_t__enumvalues',
    'cef_termination_status_t',
    'cef_termination_status_t__enumvalues', 'cef_test_cert_type_t',
    'cef_test_cert_type_t__enumvalues', 'cef_text_field_commands_t',
    'cef_text_field_commands_t__enumvalues', 'cef_text_input_mode_t',
    'cef_text_input_mode_t__enumvalues', 'cef_text_style_t',
    'cef_text_style_t__enumvalues', 'cef_thread_create',
    'cef_thread_id_t', 'cef_thread_id_t__enumvalues',
    'cef_thread_priority_t', 'cef_thread_priority_t__enumvalues',
    'cef_thread_t', 'cef_time_delta', 'cef_time_from_basetime',
    'cef_time_from_doublet', 'cef_time_from_timet', 'cef_time_now',
    'cef_time_t', 'cef_time_to_basetime', 'cef_time_to_doublet',
    'cef_time_to_timet', 'cef_touch_event_t',
    'cef_touch_event_type_t', 'cef_touch_event_type_t__enumvalues',
    'cef_touch_handle_state_flags_t',
    'cef_touch_handle_state_flags_t__enumvalues',
    'cef_touch_handle_state_t', 'cef_transition_type_t',
    'cef_transition_type_t__enumvalues',
    'cef_unresponsive_process_callback_t', 'cef_uri_unescape_rule_t',
    'cef_uri_unescape_rule_t__enumvalues', 'cef_uridecode',
    'cef_uriencode', 'cef_urlparts_t', 'cef_urlrequest_client_t',
    'cef_urlrequest_create', 'cef_urlrequest_flags_t',
    'cef_urlrequest_flags_t__enumvalues', 'cef_urlrequest_status_t',
    'cef_urlrequest_status_t__enumvalues', 'cef_urlrequest_t',
    'cef_v8_propertyattribute_t',
    'cef_v8_propertyattribute_t__enumvalues', 'cef_v8accessor_t',
    'cef_v8array_buffer_release_callback_t',
    'cef_v8context_get_current_context',
    'cef_v8context_get_entered_context', 'cef_v8context_in_context',
    'cef_v8context_t', 'cef_v8exception_t', 'cef_v8handler_t',
    'cef_v8interceptor_t', 'cef_v8stack_frame_t',
    'cef_v8stack_trace_get_current', 'cef_v8stack_trace_t',
    'cef_v8value_create_array', 'cef_v8value_create_array_buffer',
    'cef_v8value_create_array_buffer_with_copy',
    'cef_v8value_create_bool', 'cef_v8value_create_date',
    'cef_v8value_create_double', 'cef_v8value_create_function',
    'cef_v8value_create_int', 'cef_v8value_create_null',
    'cef_v8value_create_object', 'cef_v8value_create_promise',
    'cef_v8value_create_string', 'cef_v8value_create_uint',
    'cef_v8value_create_undefined', 'cef_v8value_t',
    'cef_value_create', 'cef_value_t', 'cef_value_type_t',
    'cef_value_type_t__enumvalues', 'cef_version_info',
    'cef_waitable_event_create', 'cef_waitable_event_t',
    'cef_window_info_t', 'cef_window_open_disposition_t',
    'cef_window_open_disposition_t__enumvalues',
    'cef_write_handler_t', 'cef_write_json',
    'cef_x509cert_principal_t', 'cef_x509certificate_t',
    'cef_xml_encoding_type_t', 'cef_xml_encoding_type_t__enumvalues',
    'cef_xml_node_type_t', 'cef_xml_node_type_t__enumvalues',
    'cef_xml_reader_create', 'cef_xml_reader_t', 'cef_zip_directory',
    'cef_zip_reader_create', 'cef_zip_reader_t', 'cef_zoom_command_t',
    'cef_zoom_command_t__enumvalues', 'int32_t', 'int64_t', 'size_t',
    'struct___darwin_pthread_handler_rec',
    'struct__cef_accelerated_paint_info_t',
    'struct__cef_accessibility_handler_t', 'struct__cef_app_t',
    'struct__cef_audio_handler_t', 'struct__cef_audio_parameters_t',
    'struct__cef_auth_callback_t', 'struct__cef_base_ref_counted_t',
    'struct__cef_base_scoped_t', 'struct__cef_basetime_t',
    'struct__cef_before_download_callback_t',
    'struct__cef_binary_value_t', 'struct__cef_box_layout_settings_t',
    'struct__cef_browser_host_t',
    'struct__cef_browser_process_handler_t',
    'struct__cef_browser_settings_t', 'struct__cef_browser_t',
    'struct__cef_callback_t', 'struct__cef_client_t',
    'struct__cef_command_handler_t', 'struct__cef_command_line_t',
    'struct__cef_completion_callback_t',
    'struct__cef_composition_underline_t',
    'struct__cef_context_menu_handler_t',
    'struct__cef_context_menu_params_t',
    'struct__cef_cookie_access_filter_t',
    'struct__cef_cookie_manager_t', 'struct__cef_cookie_t',
    'struct__cef_cookie_visitor_t', 'struct__cef_cursor_info_t',
    'struct__cef_delete_cookies_callback_t',
    'struct__cef_dev_tools_message_observer_t',
    'struct__cef_dialog_handler_t', 'struct__cef_dictionary_value_t',
    'struct__cef_display_handler_t', 'struct__cef_domdocument_t',
    'struct__cef_domnode_t', 'struct__cef_domvisitor_t',
    'struct__cef_download_handler_t',
    'struct__cef_download_image_callback_t',
    'struct__cef_download_item_callback_t',
    'struct__cef_download_item_t', 'struct__cef_drag_data_t',
    'struct__cef_drag_handler_t', 'struct__cef_draggable_region_t',
    'struct__cef_end_tracing_callback_t',
    'struct__cef_file_dialog_callback_t',
    'struct__cef_find_handler_t', 'struct__cef_focus_handler_t',
    'struct__cef_frame_handler_t', 'struct__cef_frame_t',
    'struct__cef_image_t', 'struct__cef_insets_t',
    'struct__cef_jsdialog_callback_t',
    'struct__cef_jsdialog_handler_t', 'struct__cef_key_event_t',
    'struct__cef_keyboard_handler_t',
    'struct__cef_life_span_handler_t',
    'struct__cef_linux_window_properties_t',
    'struct__cef_list_value_t', 'struct__cef_load_handler_t',
    'struct__cef_main_args_t', 'struct__cef_media_access_callback_t',
    'struct__cef_media_observer_t',
    'struct__cef_media_route_create_callback_t',
    'struct__cef_media_route_t', 'struct__cef_media_router_t',
    'struct__cef_media_sink_device_info_callback_t',
    'struct__cef_media_sink_device_info_t',
    'struct__cef_media_sink_t', 'struct__cef_media_source_t',
    'struct__cef_menu_model_delegate_t', 'struct__cef_menu_model_t',
    'struct__cef_mouse_event_t', 'struct__cef_navigation_entry_t',
    'struct__cef_navigation_entry_visitor_t',
    'struct__cef_pdf_print_callback_t',
    'struct__cef_pdf_print_settings_t',
    'struct__cef_permission_handler_t',
    'struct__cef_permission_prompt_callback_t', 'struct__cef_point_t',
    'struct__cef_popup_features_t', 'struct__cef_post_data_element_t',
    'struct__cef_post_data_t', 'struct__cef_preference_manager_t',
    'struct__cef_preference_registrar_t',
    'struct__cef_print_dialog_callback_t',
    'struct__cef_print_handler_t', 'struct__cef_print_job_callback_t',
    'struct__cef_print_settings_t', 'struct__cef_process_message_t',
    'struct__cef_range_t', 'struct__cef_read_handler_t',
    'struct__cef_rect_t', 'struct__cef_registration_t',
    'struct__cef_render_handler_t',
    'struct__cef_render_process_handler_t',
    'struct__cef_request_context_handler_t',
    'struct__cef_request_context_settings_t',
    'struct__cef_request_context_t', 'struct__cef_request_handler_t',
    'struct__cef_request_t', 'struct__cef_resolve_callback_t',
    'struct__cef_resource_bundle_handler_t',
    'struct__cef_resource_bundle_t', 'struct__cef_resource_handler_t',
    'struct__cef_resource_read_callback_t',
    'struct__cef_resource_request_handler_t',
    'struct__cef_resource_skip_callback_t',
    'struct__cef_response_filter_t', 'struct__cef_response_t',
    'struct__cef_run_context_menu_callback_t',
    'struct__cef_run_file_dialog_callback_t',
    'struct__cef_run_quick_menu_callback_t',
    'struct__cef_scheme_handler_factory_t',
    'struct__cef_scheme_registrar_t', 'struct__cef_screen_info_t',
    'struct__cef_select_client_certificate_callback_t',
    'struct__cef_server_handler_t', 'struct__cef_server_t',
    'struct__cef_set_cookie_callback_t', 'struct__cef_settings_t',
    'struct__cef_shared_memory_region_t',
    'struct__cef_shared_process_message_builder_t',
    'struct__cef_size_t', 'struct__cef_sslinfo_t',
    'struct__cef_sslstatus_t', 'struct__cef_stream_reader_t',
    'struct__cef_stream_writer_t', 'struct__cef_string_list_t',
    'struct__cef_string_map_t', 'struct__cef_string_multimap_t',
    'struct__cef_string_utf16_t', 'struct__cef_string_utf8_t',
    'struct__cef_string_visitor_t', 'struct__cef_string_wide_t',
    'struct__cef_task_info_t', 'struct__cef_task_manager_t',
    'struct__cef_task_runner_t', 'struct__cef_task_t',
    'struct__cef_thread_t', 'struct__cef_time_t',
    'struct__cef_touch_event_t', 'struct__cef_touch_handle_state_t',
    'struct__cef_unresponsive_process_callback_t',
    'struct__cef_urlparts_t', 'struct__cef_urlrequest_client_t',
    'struct__cef_urlrequest_t', 'struct__cef_v8accessor_t',
    'struct__cef_v8array_buffer_release_callback_t',
    'struct__cef_v8context_t', 'struct__cef_v8exception_t',
    'struct__cef_v8handler_t', 'struct__cef_v8interceptor_t',
    'struct__cef_v8stack_frame_t', 'struct__cef_v8stack_trace_t',
    'struct__cef_v8value_t', 'struct__cef_value_t',
    'struct__cef_waitable_event_t', 'struct__cef_window_info_t',
    'struct__cef_write_handler_t', 'struct__cef_x509cert_principal_t',
    'struct__cef_x509certificate_t', 'struct__cef_xml_reader_t',
    'struct__cef_zip_reader_t', 'struct__opaque_pthread_t', 'time_t',
    'uint16_t', 'uint32_t']
