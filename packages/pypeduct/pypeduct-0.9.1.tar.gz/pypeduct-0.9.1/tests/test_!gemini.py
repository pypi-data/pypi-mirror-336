"""Tests generated by gemini."""

from __future__ import annotations

import pytest

from pypeduct import pyped


def test_lshift_not_transformed():
    @pyped(verbose=True)
    def lshift_operation(value):
        return value << 2

    input_value = 5
    expected_result = input_value << 2  # Standard left shift behavior: 5 << 2 = 20
    actual_result = lshift_operation(input_value)
    assert actual_result == expected_result


def test_assignment_in_pipeline():
    @pyped
    def assignment_pipeline() -> int:
        x = 5
        y = (x := x + 5) >> (lambda val: val * 2)
        return x + y

    assert assignment_pipeline() == 30  # x becomes 10, y becomes 20, 10 + 20 = 30


def test_complex_pipeline():
    @pyped
    def complex_pipeline(x, y, z):
        return x >> (lambda val: val + y) >> (lambda val: val * z)

    assert complex_pipeline(5, 3, 2) == 16  # (5 + 3) * 2 = 16


def test_multi_arg_lambda_pipeline():
    @pyped
    def multi_arg_lambda(x, y):
        return x >> (lambda a, b: a + b)(y)

    assert multi_arg_lambda(5, 3) == 8  # 5 + 3 = 8


def test_mixed_args_pipeline():
    @pyped
    def mixed_args_pipeline(x, y):
        return x >> (lambda a, factor=2: a * factor)(y)

    assert mixed_args_pipeline(5, 3) == 15  # 5 * 3 = 15 (y overrides default factor)


def test_nested_exception_handling_pipe():
    def inner_error_func(x):
        raise TypeError("Inner Exception")

    def outer_func(x):
        try:
            return x >> inner_error_func
        except TypeError as e:
            raise ValueError("Outer Exception") from e

    @pyped
    def nested_exception_pipeline(x):
        try:
            return x >> outer_func
        except ValueError as e:
            return str(e)

    assert nested_exception_pipeline(5) == "Outer Exception"


def test_lambda_in_pipeline():
    @pyped
    def lambda_pipeline(x):
        return x >> (lambda val: val * 2)

    assert lambda_pipeline(0) == 0
    assert lambda_pipeline(1) == 2


def test_method_chaining_pipe():
    @pyped
    class StringProcessor:
        def __init__(self, value):
            self.value = value

        def prepend(self, text):
            return StringProcessor(f"{self.value} {text}")

        def get_value(self, _):
            return self.value

        def process_string(self, text):
            return text >> str.upper >> self.prepend >> str

        def __str__(self) -> str:
            return self.value

    processor = StringProcessor("hello")
    assert processor.process_string("world") == "hello WORLD"


def test_operator_precedence_pipe():
    @pyped
    def precedence_pipeline(x):
        return x + 5 >> (lambda val: val * 2)

    assert precedence_pipeline(5) == 20  # (5 + 5) * 2 = 20 (addition before pipeline)


def test_complex_operator_precedence_pipe():
    @pyped
    def complex_precedence_pipeline(x, y, z):
        return x * y + 5 >> (lambda val: val / z)

    assert complex_precedence_pipeline(5, 3, 2) == 10  # (5 * 3 + 5) / 2 = 10


def test_list_unpacking_pipe():
    def unpack_list(x):
        return [*x, 4]

    @pyped
    def list_unpack_pipeline(x):
        return x >> unpack_list

    assert list_unpack_pipeline([1, 2, 3]) == [1, 2, 3, 4]  # List unpacking in pipeline


def test_dict_unpacking_pipe():
    def unpack_dict(x):
        return {**x, "d": 4}

    @pyped
    def dict_unpack_pipeline(x):
        return x >> unpack_dict

    assert dict_unpack_pipeline({"a": 1, "b": 2, "c": 3}) == {
        "a": 1,
        "b": 2,
        "c": 3,
        "d": 4,
    }  # Dict unpacking in pipeline


def test_set_unpacking_pipe():
    def unpack_set(x):
        return {*x, 4}

    @pyped
    def set_unpack_pipeline(x):
        return x >> unpack_set

    assert set_unpack_pipeline({1, 2, 3}) == {1, 2, 3, 4}  # Set unpacking in pipeline


def test_tuple_unpacking_pipe():
    def unpack_tuple(x):
        return (*x, 4)

    @pyped
    def tuple_unpack_pipeline(x):
        return x >> unpack_tuple

    assert tuple_unpack_pipeline((1, 2, 3)) == (
        1,
        2,
        3,
        4,
    )  # Tuple unpacking in pipeline


def test_class_methods_pipeline():
    class Calculator:
        def __init__(self, value):
            self.value = value

        def add(self, amount):
            return self.__class__(self.value + amount)

        def multiply(self, factor):
            return self.__class__(self.value * factor)

        @classmethod
        @pyped
        def create_and_add(cls, initial_value, amount):
            return (
                initial_value >> (lambda x: cls(x)) >> (lambda calc: calc.add(amount))
            )

    calc = Calculator.create_and_add(5, 3)
    assert calc.value == 8


def test_staticmethod_pipeline():
    class MathUtils:
        @staticmethod
        @pyped
        def multiply_and_add(x, factor, amount):
            return x >> (lambda val: val * factor) >> (lambda val: val + amount)

    assert MathUtils.multiply_and_add(5, 2, 3) == 13  # (5 * 2) + 3 = 13


def test_property_assignment_in_pipeline():
    class MyClass:
        def __init__(self):
            self._value = 0

        @property
        def value(self):
            return self._value

        @pyped
        def set_value_pipeline(self, x):
            return x >> (lambda val: setattr(self, "_value", val) or self.value)

    instance = MyClass()
    assert instance.set_value_pipeline(10) == 10


def test_delete_statement_in_pipeline():
    @pyped
    def delete_pipeline(data):
        y = data["y"]
        del data["y"]
        return data >> (lambda d: d["x"] + y)

    data = {"x": 5, "y": 10}
    assert delete_pipeline(data.copy()) == 15


def test_pass_statement_in_pipeline():
    @pyped
    def pass_pipeline(x):
        pass
        return x >> (lambda val: val + 1)

    assert pass_pipeline(5) == 6


def test_break_statement_in_pipeline():
    @pyped
    def break_pipeline(x):
        for i in range(3):
            if i == 1:
                break
            pass
        return x >> (lambda val: val + i)

    assert break_pipeline(5) == 6  # i is 1 after break, 5 + 1 = 6


def test_continue_statement_in_pipeline():
    @pyped
    def continue_pipeline(x):
        total = 0
        for i in range(3):
            if i == 1:
                continue
            total += i
        return x >> (lambda val: val + total)

    assert continue_pipeline(5) == 7  # total is 2, 5 + 2 = 7


def test_raise_statement_in_pipeline():
    @pyped
    def raise_pipeline(x):
        if x < 0:
            raise ValueError("Input cannot be negative")
        return x >> (lambda val: val + 1)

    with pytest.raises(ValueError, match="Input cannot be negative"):
        raise_pipeline(-1)
    assert raise_pipeline(5) == 6


def test_try_except_finally_in_pipeline():
    @pyped
    def try_except_finally_pipeline(x):
        result = 0
        try:
            if x < 0:
                raise ValueError("Negative input")
            result = x >> (lambda val: val + 1)
        except ValueError:
            result = -1
        finally:
            pass
        return result

    assert try_except_finally_pipeline(-1) == -1  # Returns -1 when ValueError is caught
    assert try_except_finally_pipeline(5) == 6


def test_while_loop_in_pipeline():
    @pyped
    def while_loop_pipeline(x):
        count = 0
        while count < 3:
            x = x >> (lambda val: val + 1)
            count += 1
        return x

    assert while_loop_pipeline(5) == 8


def test_for_loop_in_pipeline():
    @pyped
    def for_loop_pipeline(x):
        for _ in range(3):
            x = x >> (lambda val: val + 1)
        return x

    assert for_loop_pipeline(5) == 8


def test_function_call_in_pipeline():
    def add_one(x):
        return x + 1

    @pyped
    def function_call_pipeline(x):
        return x >> add_one

    assert function_call_pipeline(5) == 6


def test_method_call_in_pipeline():
    class Calculator:
        def __init__(self, value):
            self.value = value

        def add_one(self, _):
            return self.value + 1

    instance = Calculator(5)

    @pyped
    def method_call_pipeline(instance):
        return instance >> instance.add_one

    assert method_call_pipeline(instance) == 6


def test_class_init_call_in_pipeline():
    class MyValue:
        def __init__(self, value):
            self.value = value

    @pyped
    def class_init_pipeline(x):
        return x >> MyValue

    instance = class_init_pipeline(5)
    assert instance.value == 5


def test_lambda_with_varargs_in_pipeline():
    @pyped
    def lambda_varargs_pipeline(x):
        return x >> (lambda val, *args: val + sum(args))(1, 2, 3)

    assert lambda_varargs_pipeline(5) == 11


def test_lambda_positional_only_args_pipe():
    @pyped
    def lambda_pos_only_pipeline(x):
        return x >> (lambda val, /, inc: val + inc)(inc=1)

    assert lambda_pos_only_pipeline(5) == 6


def test_lambda_keyword_only_args_pipe():
    @pyped
    def lambda_kw_only_pipeline(x):
        return x >> (lambda val, *, inc: val + inc)(inc=1)

    assert lambda_kw_only_pipeline(5) == 6  # Keyword-only lambda argument


def test_lambda_mixed_args_complex_pipe():
    @pyped
    def lambda_mixed_complex_pipeline(x):
        return x >> (
            lambda pos_only, val, *, kw_only, **kwargs: pos_only
            + val
            + kw_only
            + sum(kwargs.values())
        )(1, kw_only=2, other=3, another=4)

    assert lambda_mixed_complex_pipeline(5) == 15  # Complex lambda arg signature


def test_string_pipeline():
    @pyped
    def string_pipeline():
        return "hello" >> (lambda x: x.upper())

    assert string_pipeline() == "HELLO"  # String as initial pipeline value


def test_bytes_pipeline():
    @pyped
    def bytes_pipeline():
        return b"hello" >> (lambda x: x.upper())

    assert bytes_pipeline() == b"HELLO"  # Bytes as initial pipeline value


def test_frozenset_pipeline():
    @pyped
    def frozenset_pipeline():
        return frozenset({1, 2, 3}) >> (lambda x: sum(x))

    assert frozenset_pipeline() == 6  # Frozenset as initial pipeline value


def test_range_pipeline():
    @pyped
    def range_pipeline():
        return range(5) >> (lambda x: sum(x))

    assert range_pipeline() == 10  # Range object as initial pipeline value


def test_memoryview_pipeline():
    @pyped
    def memoryview_pipeline():
        return memoryview(b"hello") >> (lambda x: x.tobytes().upper())

    assert memoryview_pipeline() == b"HELLO"  # Memoryview as initial pipeline value


def test_enumerate_pipeline():
    @pyped
    def enumerate_pipeline():
        return enumerate(["a", "b", "c"]) >> (
            lambda x: [(index, value) for index, value in x]
        )

    assert enumerate_pipeline() == [
        (0, "a"),
        (1, "b"),
        (2, "c"),
    ]  # Enumerate object as initial value


def test_zip_pipeline():
    @pyped
    def zip_pipeline():
        return zip(["a", "b", "c"], [1, 2, 3]) >> (lambda x: list(x))

    assert zip_pipeline() == [
        ("a", 1),
        ("b", 2),
        ("c", 3),
    ]  # Zip object as initial value


def test_map_pipeline():
    @pyped
    def map_pipeline():
        return map(lambda x: x * 2, [1, 2, 3]) >> (lambda x: list(x))

    assert map_pipeline() == [2, 4, 6]  # Map object as initial value


def test_filter_pipeline():
    @pyped
    def filter_pipeline():
        return filter(lambda x: x > 1, [1, 2, 3]) >> (lambda x: list(x))

    assert filter_pipeline() == [2, 3]  # Filter object as initial value


def test_reversed_pipeline():
    @pyped
    def reversed_pipeline():
        return reversed([1, 2, 3]) >> (lambda x: list(x))

    assert reversed_pipeline() == [3, 2, 1]  # Reversed object as initial value


def test_complex_lambda_body_pipeline():
    @pyped
    def complex_lambda_body_pipeline(x):
        return x >> (lambda val: [i * val for i in range(3) if i > 0])

    assert complex_lambda_body_pipeline(5) == [
        5,
        10,
    ]  # Complex lambda body with comprehension and condition


def test_generator_function_pipeline():
    def number_generator(n):
        for i in range(n):
            yield i

    @pyped
    def generator_func_pipeline():
        return number_generator(3) >> (lambda gen: list(gen))

    assert generator_func_pipeline() == [0, 1, 2]  # Generator function as initial value


def test_async_for_loop_pipeline():
    import asyncio

    @pyped
    async def async_for_loop_pipeline(x):
        results = []
        async for i in async_number_generator(3):
            results.append(i)
        return x >> (lambda val: results)

    async def run_async_for_loop_pipeline():
        return await async_for_loop_pipeline(5)

    async def async_number_generator(n):  # Define generator within test for scope
        for i in range(n):
            await asyncio.sleep(0.01)
            yield i

    assert asyncio.run(run_async_for_loop_pipeline()) == [
        0,
        1,
        2,
    ]  # Async for loop in pipeline


def test_long_pipeline():  # To test performance with long pipelines
    @pyped
    def long_pipeline(x):
        pipeline = x
        for _ in range(1000):  # Long pipeline
            pipeline = pipeline >> (lambda v: v + 1)
        return pipeline

    assert long_pipeline(0) == 1000  # Long pipeline test


def test_class_with_pipes_in_multiple_methods():
    @pyped
    class PipelineClassMethods:
        def method1(self, x):
            return x >> (lambda v: v + 1)

        def method2(self, x):
            return x >> (lambda v: v * 2)

        def combined_method(self, x):
            return x >> self.method1 >> self.method2

    instance = PipelineClassMethods()
    assert instance.combined_method(5) == 12


def test_pipe_with_f_string():
    @pyped
    def fstring_pipeline(name):
        greeting = "Hello"
        return name >> (lambda x: f"{greeting}, {x}!")

    assert fstring_pipeline("World") == "Hello, World!"


def test_pipe_with_bytes_string_concat():
    @pyped
    def bytes_concat_pipeline():
        return b"hello" >> (lambda x: x + b" world")

    assert bytes_concat_pipeline() == b"hello world"


def test_pipe_with_unicode_string_concat():
    @pyped
    def unicode_concat_pipeline():
        return "hello" >> (lambda x: x + " world")

    assert unicode_concat_pipeline() == "hello world"


def test_pipe_with_list_concat():
    @pyped
    def list_concat_pipeline():
        return [1, 2] >> (lambda x: x + [3, 4])

    assert list_concat_pipeline() == [1, 2, 3, 4]


def test_pipe_with_set_union():
    @pyped
    def set_union_pipeline():
        return {1, 2} >> (lambda x: x | {3, 4})

    assert set_union_pipeline() == {1, 2, 3, 4}


def test_pipe_with_dict_update():
    @pyped
    def dict_update_pipeline():
        return {"a": 1, "b": 2} >> (lambda x: {**x, "c": 3})

    assert dict_update_pipeline() == {"a": 1, "b": 2, "c": 3}


def test_pipe_with_complex_data_structure():
    @pyped
    def complex_data_pipeline():
        data = {"list": [1, 2], "tuple": (3, 4)}
        return data >> (lambda x: {"list": x["list"] + [3], "tuple": x["tuple"] + (5,)})

    assert complex_data_pipeline() == {
        "list": [1, 2, 3],
        "tuple": (3, 4, 5),
    }


def test_pipe_with_empty_lambda():
    @pyped
    def empty_lambda_pipeline(x):
        return x >> (lambda c: None)

    assert empty_lambda_pipeline(5) is None


def test_pipe_with_lambda_returning_none():
    @pyped
    def lambda_none_return_pipeline(x):
        return x >> (lambda val: None if val < 10 else val)

    assert lambda_none_return_pipeline(5) is None


def test_pipe_with_lambda_returning_itself():
    @pyped
    def lambda_self_return_pipeline(x):
        return (x >> (lambda val: lambda: val))()

    assert lambda_self_return_pipeline(5) == 5


def test_pipe_with_lambda_returning_constant():
    @pyped
    def lambda_constant_return_pipeline(x):
        return x >> (lambda val: "constant string")

    assert lambda_constant_return_pipeline(5) == "constant string"


def test_pipe_with_lambda_returning_input():
    @pyped
    def lambda_input_return_pipeline(x):
        return x >> (lambda val: val)

    assert lambda_input_return_pipeline(5) == 5  # Lambda simply returning its input


def test_pipe_with_lambda_side_effects():
    side_effect_list = []

    @pyped
    def lambda_side_effect_pipeline(x):
        return x >> (
            lambda val: side_effect_list.append(val) or val + 1
        )  # Lambda with side effect

    assert lambda_side_effect_pipeline(5) == 6
    assert side_effect_list == [5]  # Side effect list is updated


def test_pipe_with_lambda_no_return_statement():
    @pyped
    def lambda_no_return_pipeline(x):
        return x >> (lambda val: ...)

    assert lambda_no_return_pipeline(5) is ...


def test_pipe_with_class_instance_as_input():
    class DataContainer:
        def __init__(self, value):
            self.value = value

        def increment(self):
            self.value += 1
            return self

        def get_value(self):
            return self.value

    data_obj = DataContainer(5)

    @pyped
    def class_instance_input_pipeline(data):
        return data >> (lambda obj: obj.increment()) >> (lambda obj: obj.get_value())

    assert class_instance_input_pipeline(data_obj) == 6


def test_pipe_with_generator_comprehension():
    @pyped
    def generator_comprehension_pipeline():
        return (x * 2 for x in range(3)) >> (lambda gen: sum(gen))

    assert generator_comprehension_pipeline() == 6


def test_pipe_with_set_literal():
    @pyped
    def set_literal_pipeline():
        return {1, 2, 3} >> (lambda x: sum(x))

    assert set_literal_pipeline() == 6  # Set literal as initial value


def test_pipe_with_dict_literal():
    @pyped
    def dict_literal_pipeline():
        return {"a": 1, "b": 2, "c": 3} >> (lambda x: sum(x.values()))

    assert dict_literal_pipeline() == 6


def test_pipe_with_list_literal():
    @pyped
    def list_literal_pipeline():
        return [1, 2, 3] >> (lambda x: sum(x))

    assert list_literal_pipeline() == 6


def test_pipe_with_numeric_literal():
    @pyped
    def numeric_literal_pipeline():
        return 5 >> (lambda x: x * 2)

    assert numeric_literal_pipeline() == 10


def test_pipe_with_boolean_literal():
    @pyped
    def boolean_literal_pipeline():
        return True >> (lambda x: not x)

    assert boolean_literal_pipeline() is False


def test_pipe_with_none_literal():
    @pyped
    def none_literal_pipeline():
        return None >> (lambda x: x is None)

    assert none_literal_pipeline() is True


def test_pipe_with_name_constant_true():  # Alias for True
    @pyped
    def true_constant_pipeline():
        return True >> (lambda x: not x)

    assert true_constant_pipeline() is False  # NameConstant True as initial value


def test_pipe_with_name_constant_false():  # Alias for False
    @pyped
    def false_constant_pipeline():
        return False >> (lambda x: not x)

    assert false_constant_pipeline() is True  # NameConstant False as initial value


def test_pipe_with_name_constant_none():  # Alias for None
    @pyped
    def none_constant_pipeline():
        return None >> (lambda x: x is None)

    assert none_constant_pipeline() is True  # NameConstant None as initial value


def test_pipe_with_list_of_lambdas():
    @pyped
    def list_lambda_pipeline(x):
        funcs = [(lambda v: v + 1), (lambda v: v * 2)]
        pipeline = x
        for func in funcs:
            pipeline = pipeline >> func
        return pipeline

    assert list_lambda_pipeline(5) == 12  # Pipeline with list of lambdas


def test_pipe_with_dict_of_lambdas():
    @pyped
    def dict_lambda_pipeline(x):
        funcs = {"add": (lambda v: v + 1), "multiply": (lambda v: v * 2)}
        return x >> funcs["add"] >> funcs["multiply"]

    assert dict_lambda_pipeline(5) == 12


def test_pipe_with_tuple_of_lambdas():
    @pyped
    def tuple_lambda_pipeline(x):
        funcs = ((lambda v: v + 1), (lambda v: v * 2))
        pipeline = x
        for func in funcs:
            pipeline = pipeline >> func
        return pipeline

    assert tuple_lambda_pipeline(5) == 12


def test_pipe_with_generator_of_lambdas():
    def lambda_generator():
        yield lambda v: v + 1
        yield lambda v: v * 2

    @pyped
    def generator_lambda_pipeline(x):
        pipeline = x
        for func in lambda_generator():
            pipeline = pipeline >> func
        return pipeline

    assert generator_lambda_pipeline(5) == 12


def test_pipe_with_partial_objects():
    from functools import partial

    add_partial = partial(lambda x, y: x + y, y=1)  # Partial object

    @pyped
    def partial_object_pipeline(x):
        return x >> add_partial

    assert partial_object_pipeline(5) == 6  # Pipeline with partial object


def test_pipe_with_class_as_callable():
    class Adder:
        def __call__(self, x):
            return x + 1

    adder_instance = Adder()

    @pyped
    def class_callable_pipeline(x):
        return x >> adder_instance

    assert class_callable_pipeline(5) == 6


def test_pipe_with_builtin_function():
    @pyped
    def builtin_pipeline(x):
        return x >> str  # Using builtin function str as pipeline step

    assert builtin_pipeline(5) == "5"  # Pipeline with builtin function


def test_pipe_with_builtin_method():
    @pyped
    def builtin_method_pipeline():
        return "hello" >> str.upper

    assert builtin_method_pipeline() == "HELLO"


def test_pipe_with_external_function():
    import math

    @pyped
    def external_func_pipeline(x):
        return x >> math.sqrt  # Using external math.sqrt function

    assert external_func_pipeline(25) == 5.0  # Pipeline with external function


def test_pipe_with_user_defined_function():
    def add_five(x):
        return x + 5

    @pyped
    def user_func_pipeline(x):
        return x >> add_five  # Using user-defined function

    assert user_func_pipeline(5) == 10  # Pipeline with user-defined function


def test_pipe_with_type_error_handling():
    @pyped
    def type_error_pipeline():
        return "hello" >> (lambda x: 1 / x)

    with pytest.raises(TypeError):
        type_error_pipeline()


def test_pipe_with_value_error_handling():
    @pyped
    def value_error_pipeline():
        return -1 >> (lambda x: math.sqrt(x))

    with pytest.raises(NameError):
        value_error_pipeline()


def test_pipe_with_index_error_handling():
    @pyped
    def index_error_pipeline():
        return [] >> (lambda x: x[0])

    with pytest.raises(IndexError):
        index_error_pipeline()


def test_pipe_with_key_error_handling():
    @pyped
    def key_error_pipeline():
        return {} >> (
            lambda x: x["key"]
        )  # Accessing non-existent key in dict - should raise KeyError

    with pytest.raises(KeyError):
        key_error_pipeline()  # Expect KeyError to be raised


def test_pipe_with_attribute_error_handling():
    class MyClass:
        pass

    instance = MyClass()

    @pyped
    def attribute_error_pipeline(instance):
        return instance >> (
            lambda x: x.non_existent_attribute
        )  # Accessing non-existent attribute - should raise AttributeError

    with pytest.raises(AttributeError):
        attribute_error_pipeline(instance)  # Expect AttributeError to be raised


def test_pipe_with_zero_division_error_handling():
    @pyped
    def zero_division_pipeline():
        return 1 >> (
            lambda x: x / 0
        )  # Division by zero - should raise ZeroDivisionError

    with pytest.raises(ZeroDivisionError):
        zero_division_pipeline()  # Expect ZeroDivisionError to be raised


def test_pipe_with_syntax_error_handling():
    @pyped
    def syntax_error_pipeline():
        return 5 >> (lambda x: eval("syntax error"))

    with pytest.raises(SyntaxError):
        syntax_error_pipeline()


def test_pipe_with_unicode_decode_error_handling():  # UnicodeDecodeError is runtime
    @pyped
    def unicode_decode_error_pipeline():
        return b"\xc2\x00" >> (lambda x: x.decode("utf-8"))

    with pytest.raises(UnicodeDecodeError):
        unicode_decode_error_pipeline()


def test_pipe_with_unicode_encode_error_handling():  # UnicodeEncodeError is runtime
    @pyped
    def unicode_encode_error_pipeline():
        return "€" >> (
            lambda x: x.encode("ascii")
        )  # Unicode char not in ASCII - should raise UnicodeEncodeError

    with pytest.raises(UnicodeEncodeError):
        unicode_encode_error_pipeline()  # Expect UnicodeEncodeError


def test_pipe_with_generator_exit_handling():
    def generator_with_exit():
        try:
            yield 1
            yield 2
        except GeneratorExit:
            print(
                "Generator exited"
            )  # To show GeneratorExit handling, if test runner captures stdout
            raise
        finally:
            print(
                "Generator finally"
            )  # To show finally block execution, if test runner captures stdout

    @pyped
    def generator_exit_pipeline():
        gen = generator_with_exit()
        next(gen)  # Start generator
        gen.close()  # Trigger GeneratorExit
        return 5 >> (lambda x: "Generator closed")

    assert generator_exit_pipeline() == "Generator closed"


def test_pipe_with_system_exit_handling():  # SystemExit is a special case, usually not caught like regular exceptions
    @pyped
    def system_exit_pipeline():
        return 5 >> (lambda x: exit(0))

    with pytest.raises(SystemExit):
        system_exit_pipeline()


def test_pipe_with_generator_return_handling():
    def generator_with_return():
        yield 1
        return "Generator return value"
        yield 2  # Unreachable, sic!

    @pyped
    def generator_return_pipeline():
        gen = generator_with_return()
        return gen >> (lambda x: list(x))

    assert generator_return_pipeline() == [1]


def test_pipe_with_stop_iteration_handling():
    class MyIterator:
        def __iter__(self):
            return self

        def __next__(self):
            raise StopIteration

    @pyped
    def stop_iteration_pipeline():
        return MyIterator() >> (lambda x: list(x))

    assert stop_iteration_pipeline() == []


def test_pipe_with_closure_over_loop_variable():
    def create_incrementor(inc):
        return lambda x: x + inc  # Closure factory

    @pyped
    def closure_loop_variable_pipeline():
        funcs = []
        for i in range(3):
            funcs.append(create_incrementor(i))  # Create closures capturing i
        pipeline = 0
        for func in funcs:
            pipeline = pipeline >> func
        return pipeline

    assert (
        closure_loop_variable_pipeline() == 3
    )  # Closure over loop variable, expected sum is 0 + 0 + 1 + 2 = 3


def test_pipe_with_default_argument_lambda():
    @pyped
    def default_lambda_arg_pipeline(x=(lambda: 10)()):
        return x >> (lambda val: val)

    assert default_lambda_arg_pipeline() == 10


def test_pipe_with_nested_function_as_step():
    def outer_func():
        def inner_func(x):
            return x + 1

        return inner_func

    increment_func = outer_func()

    @pyped
    def nested_func_pipeline(x):
        return x >> increment_func

    assert nested_func_pipeline(5) == 6


def test_pipe_with_closure_as_step():
    def create_incrementor_closure(inc):
        def incrementor(x):
            return x + inc

        return incrementor

    increment_by_3 = create_incrementor_closure(3)

    @pyped
    def closure_step_pipeline(x):
        return x >> increment_by_3

    assert closure_step_pipeline(5) == 8


def test_pipe_with_class_method():
    class Calculator:
        def __init__(self, value):
            self.value = value

        @classmethod
        def create_with_value(cls, value):
            return cls(value)

    @pyped
    def class_method_pipeline(x):
        return x >> Calculator.create_with_value

    instance = class_method_pipeline(5)
    assert instance.value == 5


def test_pipe_with_staticmethod():
    class MathUtils:
        @staticmethod
        def increment(x):
            return x + 1

    @pyped
    def static_method_pipeline(x):
        return x >> MathUtils.increment  # Static method as pipeline step

    assert static_method_pipeline(5) == 6  # Static method in pipeline


def test_pipe_with_lambda_assignment():
    @pyped
    def lambda_assignment_pipeline(x):
        increment = lambda val: val + 1
        return x >> increment

    assert lambda_assignment_pipeline(5) == 6


def test_pipe_with_function_assignment():
    def increment_func(x):
        return x + 1

    increment = increment_func

    @pyped
    def function_assignment_pipeline(x):
        return x >> increment

    assert function_assignment_pipeline(5) == 6


def test_pipe_with_class_method_assignment():
    class Calculator:
        def __init__(self, value):
            self.value = value

        @classmethod
        def create_with_value_method(cls, x):
            return cls(x)

    create_with_value = (
        Calculator.create_with_value_method
    )  # Class method assigned to variable

    @pyped
    def class_method_assignment_pipeline(x):
        return x >> create_with_value  # Class method assigned to variable in pipeline

    instance = class_method_assignment_pipeline(5)
    assert instance.value == 5  # Class method assigned to variable in pipeline


def test_pipe_with_staticmethod_assignment():
    class MathUtils:
        @staticmethod
        def increment_static_method(x):
            return x + 1

    increment = MathUtils.increment_static_method  # Static method assigned to variable

    @pyped
    def static_method_assignment_pipeline(x):
        return x >> increment  # Static method assigned to variable in pipeline

    assert (
        static_method_assignment_pipeline(5) == 6
    )  # Static method assigned to variable in pipeline


def test_pipe_with_nested_scopes():
    def outer_function(factor):
        def inner_function(x):
            return x * factor  # Closure over factor from outer scope

        return inner_function

    multiplier = outer_function(3)

    @pyped
    def nested_scope_pipeline(x):
        local_factor = 2  # Local variable in pipeline function scope
        return (
            x >> multiplier >> (lambda val: val + local_factor)
        )  # Accessing both closure and local scope

    assert nested_scope_pipeline(5) == 17  # Nested scopes test, (5 * 3) + 2 = 17


def test_pipe_with_global_variable():
    GLOBAL_FACTOR = 4  # Global variable

    @pyped
    def global_variable_pipeline(x):
        return x >> (
            lambda val: val * GLOBAL_FACTOR
        )  # Accessing global variable in lambda

    assert global_variable_pipeline(5) == 20  # Global variable access test


def test_pipe_with_nonlocal_variable():
    def outer_function():
        nonlocal_factor = 5  # Nonlocal variable

        @pyped
        def nonlocal_pipeline(x):
            return x >> (
                lambda val: val * nonlocal_factor
            )  # Accessing nonlocal variable

        return nonlocal_pipeline

    nonlocal_pipeline_func = outer_function()
    assert nonlocal_pipeline_func(5) == 25


def test_pipe_with_enclosing_function_variable():
    def enclosing_function(factor):
        @pyped
        def enclosing_scope_pipeline(x):
            return x >> (
                lambda val: val * factor
            )  # Accessing variable from enclosing function scope

        return enclosing_scope_pipeline

    enclosing_pipeline_func = enclosing_function(6)
    assert enclosing_pipeline_func(5) == 30  # Enclosing function scope variable access


def test_pipe_with_builtin_scope():
    @pyped
    def builtin_scope_pipeline(x):
        return x >> len  # Using builtin function len directly from builtin scope

    assert builtin_scope_pipeline([1, 2, 3]) == 3  # Builtin scope access test


def test_pipe_with_same_name_scopes():
    factor = 10  # Global factor

    def outer_function(factor):  # Parameter factor shadows global factor
        @pyped
        def same_name_pipeline(x):
            factor = 2  # Local factor shadows parameter factor
            return x >> (lambda val: val * factor)  # Accessing local factor

        return same_name_pipeline

    same_name_pipeline_func = outer_function(
        5
    )  # Passing 5 as parameter factor, but local factor should take precedence
    assert (
        same_name_pipeline_func(5) == 10
    )  # Same name scopes test, local factor (2) should be used


def test_pipe_with_free_variable_assignment():
    factor = 3  # Free variable

    @pyped
    def free_variable_assign_pipeline(x):
        factor = 5  # Re-assigning free variable in pipeline function scope
        return x >> (
            lambda val: val * factor
        )  # Lambda should capture re-assigned free variable

    assert (
        free_variable_assign_pipeline(5) == 25
    )  # Free variable reassignment test, lambda should capture new value (5)


def test_pipe_with_loop_variable_reassignment():
    @pyped
    def loop_variable_reassign_pipeline(x):
        for i in range(3):
            i = 10  # Re-assigning loop variable - usually bad practice, but testing scope
            pass
        return x >> (
            lambda val: val + i
        )  # Lambda should capture re-assigned loop variable value

    assert (
        loop_variable_reassign_pipeline(5) == 15
    )  # Loop variable reassignment test, i is 2 after loop, then reassigned to 10. So 5 + 10 = 15.


def test_pipe_with_conditional_variable_assignment():
    @pyped
    def conditional_var_assign_pipeline(flag, x):
        if flag:
            var = 5  # Conditional variable assignment
        else:
            var = 10  # Conditional variable assignment - different value
        return x >> (
            lambda val: val + var
        )  # Lambda should capture conditionally assigned variable

    assert (
        conditional_var_assign_pipeline(True, 5) == 10
    )  # Conditional var assignment test, flag=True, var=5, 5 + 5 = 10
    assert (
        conditional_var_assign_pipeline(False, 5) == 15
    )  # Conditional var assignment test, flag=False, var=10, 5 + 10 = 15


def test_pipe_with_try_except_variable_assignment():
    @pyped
    def try_except_var_assign_pipeline(flag, x):
        try:
            if flag:
                var = 5  # Variable assignment in try block
            else:
                raise ValueError("Flag is False")
        except ValueError:
            var = 10  # Variable assignment in except block
        return x >> (
            lambda val: val + var
        )  # Lambda should capture variable assigned in try or except

    assert (
        try_except_var_assign_pipeline(True, 5) == 10
    )  # Try-except var assignment, flag=True, var=5, 5 + 5 = 10
    assert (
        try_except_var_assign_pipeline(False, 5) == 15
    )  # Try-except var assignment, flag=False, var=10, 5 + 10 = 15


def test_pipe_with_with_statement_variable_assignment():
    class ContextManager:
        def __enter__(self):
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            pass

        def __init__(self):
            self.var = 0

    @pyped
    def with_statement_var_assign_pipeline(x):
        with ContextManager() as cm:
            cm.var = 7  # Variable assignment in with statement
        return x >> (
            lambda val: val + cm.var
        )  # Lambda should capture variable assigned in with

    assert (
        with_statement_var_assign_pipeline(5) == 12
    )  # With statement var assignment, cm.var = 7, 5 + 7 = 12


def test_pipe_with_function_argument_shadowing():
    def outer_function(factor):
        @pyped
        def arg_shadowing_pipeline(
            factor, x
        ):  # Argument 'factor' shadows outer 'factor'
            return x >> (
                lambda val: val * factor
            )  # Lambda should capture argument 'factor'

        return arg_shadowing_pipeline

    shadowing_pipeline_func = outer_function(
        10
    )  # Outer factor is 10, but argument factor will shadow it
    assert (
        shadowing_pipeline_func(2, 5) == 10
    )  # Argument shadowing test, argument factor (2) should be used, 5 * 2 = 10, initial x=5 is piped in.


def test_pipe_with_global_keyword():
    global GLOBAL_VAR  # Declare global variable

    GLOBAL_VAR = 20  # Initialize global variable

    @pyped
    def global_keyword_pipeline(x):
        global GLOBAL_VAR  # Use global keyword to modify global variable
        GLOBAL_VAR += 1
        return x >> (
            lambda val: val + GLOBAL_VAR
        )  # Lambda should capture modified global variable

    assert (
        global_keyword_pipeline(5) == 26
    )  # Global keyword test, GLOBAL_VAR becomes 21, 5 + 21 = 26


def test_named_expression_as_pipeline_step():
    def increment(x):
        return x + 1

    @pyped
    def named_expression_pipeline(x):
        return x >> (incremented := lambda val: val + 1) >> increment

    assert named_expression_pipeline(5) == 7


def test_named_expression_in_conditional_pipeline():
    @pyped
    def named_expression_conditional_pipeline(flag, x):
        if flag:
            op = (incremented := lambda val: val + 1)
        else:
            op = (doubled := lambda val: val * 2)
        return x >> op

    assert named_expression_conditional_pipeline(True, 5) == 6
    assert named_expression_conditional_pipeline(False, 5) == 10


def test_named_expression_in_loop_pipeline():
    @pyped
    def named_expression_loop_pipeline(x):
        pipeline = x
        for i in range(3):
            op_name = f"op_{i}"
            pipeline = pipeline >> (
                op := lambda val: val + i
            )  # Named expression in loop
        return pipeline

    assert named_expression_loop_pipeline(5) == 8
