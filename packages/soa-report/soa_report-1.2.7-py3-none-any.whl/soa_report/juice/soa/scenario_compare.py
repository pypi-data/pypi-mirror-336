"""
Created on October 2023

@author: Claudio Munoz Crego (ESAC)

This Module allows to compare two scenarios (eps_output) generated by MAPPS/OSVE
"""

import os
import sys
import logging
import numpy as np
import datetime
import pandas as pd
import copy
from tabulate import tabulate

from soa_report.juice.eps_data.data_rate_avg import DataRateAverage
from soa_report.juice.eps_data.power_avg import PowerAverage
from soa_report.juice.eps_data.data_rate_avg import DfDataRateAverage

from soa_report.juice.soa.power_metrics import get_power_profiles_metrics, get_energy_profiles_metrics, \
    get_power_profiles_metrics_percent, calculate_power_status


class ScenarioCompare(object):
    """
    Scenario Handler for comparison
    """

    def __init__(self, scenarios, bat_capacity, output_dir="./"):

        self.output_dir = output_dir

        self.scenarios = scenarios
        self.load_and_setup_scenario(bat_capacity=bat_capacity)

    def load_and_setup_scenario(self, bat_capacity):
        """
        Read scenario files and set up scenarios structures
        """

        scenarios = self.scenarios

        for i in scenarios:

            data_avg_file_path = os.path.join(scenarios[i]['root_path'], 'data_rate_avg.out')
            power_avg_file_path = os.path.join(scenarios[i]['root_path'], 'power_avg.out')

            if os.path.exists(data_avg_file_path):
                data_avg = DataRateAverage(data_avg_file_path)
                scenarios[i]['data_avg_file_path'] = data_avg_file_path
                scenarios[i]['dv_df'] = data_avg.df
                scenarios[i]['dv'] = DataVolume(scenarios[i]['dv_df'], data_avg)
            else:
                logging.error(f'File {data_avg_file_path} does not exist for scenario {i}')
                logging.error('Please fix it!')
                sys.exit()

            if os.path.exists(power_avg_file_path):

                df_power = PowerAverage(power_avg_file_path, bat_capacity=bat_capacity)
                scenarios[i]['power_avg_file_path'] = power_avg_file_path
                scenarios[i]['pw_df'] = df_power.df
                scenarios[i]['pw'] = Power(scenarios[i]['pw_df'], df_power)

            else:

                logging.error(f'File {power_avg_file_path} does not exist for scenario {i}')
                logging.error('Please fix it!')
                sys.exit()

    def check_scenario_periods(self):

        scenario_win_ref = self.scenarios[1]['dv']
        scenario_win_to_cmp = self.scenarios[2]['dv']
        if [scenario_win_ref.end, scenario_win_ref.start] == [scenario_win_to_cmp.end, scenario_win_to_cmp.start]:
            print(f'Both scenarios cover the same periods [{scenario_win_ref.end} - {scenario_win_ref.start}]')
            return True

        else:
            print('\nBoth scenarios do not cover the same periods!')
            print(f'Scenario 1:  [{scenario_win_ref.start} - {scenario_win_ref.end}]')
            print(f'Scenario 2:  [{scenario_win_to_cmp.start} - {scenario_win_to_cmp.end}]')
            return False

    def check_same_experiments_in_scenarios(self):

        scenario_win_ref = self.scenarios[1]['dv']
        scenario_win_to_cmp = self.scenarios[2]['dv']

        flag = True

        if scenario_win_to_cmp.experiments != scenario_win_ref.experiments:
            print('Both scenarios do not have same experiments!')
            print(f'Scenario 1: {scenario_win_ref.experiments}')
            print(f'Scenario 2: {scenario_win_to_cmp.experiments}')
            flag = False

            if scenario_win_to_cmp.science_experiments != scenario_win_to_cmp.science_experiments:
                print('\nBoth scenarios do not have same science experiments!')
                print(f'Scenario 1: {scenario_win_ref.science_experiments}')
                print(f'Scenario 2: {scenario_win_to_cmp.science_experiments}')

        return flag

    def check_dv_metrics(self):

        scenario_win_ref = self.scenarios[1]['dv']
        scenario_win_to_cmp = self.scenarios[2]['dv']

        self.check_dv_generated(scenario_win_ref, scenario_win_to_cmp)
        self.check_downlink_capacity(scenario_win_ref, scenario_win_to_cmp)
        self.check_downlink_to_ground(scenario_win_ref, scenario_win_to_cmp)
        self.check_ssmm(scenario_win_ref, scenario_win_to_cmp)

    def check_power_and_energy_metrics(self, ):

        scenario_win_ref = self.scenarios[1]['dv']
        scenario_win_to_cmp = self.scenarios[2]['dv']

        self.check_energy_instrument(scenario_win_ref, scenario_win_to_cmp)

        # self.power = get_power_profiles_metrics(self.pw_experiment)
        # self.battery = get_energy_profiles_metrics(self.pw_platform)
        # self.energy_platform = get_energy_profiles_metrics(self.pw_platform)
        # self.energy_instrument = get_energy_profiles_metrics(self.pw_experiment)

        # self.check_dv_generated(scenario_win_ref, scenario_win_to_cmp)

    def check_energy_instrument(self, scenario_win_ref, scenario_win_to_cmp):

        energy_ref = scenario_win_ref.energy_instrument
        energy_to_cmp = scenario_win_ref.energy_instrument
        if energy_to_cmp.power_instrument_total == energy_ref.power_instrument_total:

            print(f'Both scenarios generate the same Energy in Wh'
                  f'\n\t initial: {float((energy_ref.power_instrument[-1][1]))} [Wh]'
                  f'\n\t End: {float((energy_ref.power_instrument[-1][2]))} [Wh]'
                  f'\n\t Delta: {float((energy_ref.power_instrument[-1][3]))} [Wh]')
            return True

            # check by experiments:

            metrics = []

            for instr_to_cmp in scenario_win_to_cmp.science_experiments:

                if instr_to_cmp in scenario_win_ref.science_experiments:

                    ref = scenario_win_ref.generated_dv_total_instr[instr_to_cmp]

                    to_cmp = scenario_win_to_cmp.generated_dv_total_instr[instr_to_cmp]

                    if to_cmp != ref:
                        metrics.append([instr_to_cmp, ref, to_cmp])

            if metrics:
                print('\nThe following table list the instrument with different generated DV in Gbits')

                metrics.insert(0, ['Instrument', 'Scenario 1', 'Scenario 2'])

                print(tabulate(metrics[1:], headers=metrics[0]))

    def check_dv_generated(self, scenario_win_ref, scenario_win_to_cmp):

        # Compare Generated data Volume (total)
        if scenario_win_to_cmp.generated_dv_total == scenario_win_ref.generated_dv_total:
            print(f'Both scenarios generate the same DV: {scenario_win_ref.generated_dv_total} [Gbits]')
            return True
        else:
            print(f'\nBoth scenarios do not generate the same DV!')
            print(f'Scenario 1:  {scenario_win_ref.generated_dv_total} [gbits]')
            print(f'Scenario 2:  {scenario_win_to_cmp.generated_dv_total} [gbits]')

            # check by experiments:
            metrics = []
            for instr_to_cmp in scenario_win_to_cmp.science_experiments:

                if instr_to_cmp in scenario_win_ref.science_experiments:

                    ref = scenario_win_ref.generated_dv_total_instr[instr_to_cmp]
                    to_cmp = scenario_win_to_cmp.generated_dv_total_instr[instr_to_cmp]

                    if to_cmp != ref:
                        metrics.append([instr_to_cmp, ref, to_cmp])

            if metrics:
                print('\nThe following table list the instrument with different generated DV in Gbits')
                metrics.insert(0, ['Instrument', 'Scenario 1', 'Scenario 2'])
                print(tabulate(metrics[1:], headers=metrics[0]))

    def check_downlink_capacity(self, scenario_win_ref, scenario_win_to_cmp):

        # Compare data volume downlink capacity allowed to ground station

        if scenario_win_to_cmp.downlink_capacity_total == scenario_win_ref.downlink_capacity_total:
            print(f'Both scenarios have the same downlink capacity:'
                  f'\n\t XB_link: {scenario_win_ref.downlink_capacity_xb} [Gbits]'
                  f'\n\t KAB_link: {scenario_win_ref.downlink_capacity_kab} [Gbits]'
                  f'\n\t Total: {scenario_win_ref.downlink_capacity_total} [Gbits]')
            return True
        else:
            print('\nThe following table list the downlink capacity to ground stations in Gbits')
            metrics = [['Downlink', 'Scenario 1', 'Scenario 2'],
                       ['XB_link', scenario_win_ref.downlink_capacity_xb, scenario_win_to_cmp.downlink_capacity_xb],
                       ['KAB_link', scenario_win_ref.downlink_capacity_kab, scenario_win_to_cmp.downlink_capacity_kab],
                       ['Total', scenario_win_ref.downlink_capacity_total, scenario_win_to_cmp.downlink_capacity_total]
                       ]
            print(tabulate(metrics[1:], headers=metrics[0]))
            return False

    def check_downlink_to_ground(self, scenario_win_ref, scenario_win_to_cmp):

        # Compare data volume downlink to ground station

        if scenario_win_to_cmp.downlink_to_ground_total == scenario_win_ref.downlink_to_ground_total:
            print(f'Both scenarios have the same DV downlink to ground:'
                  f'\n\t XB_link: {scenario_win_ref.downlink_to_ground_xb} [Gbits]'
                  f'\n\t KAB_link: {scenario_win_ref.downlink_to_ground_kab} [Gbits]'
                  f'\n\t Total: {scenario_win_ref.downlink_to_ground_total} [Gbits]')
            return True
        else:
            print('\nThe following table list the DV downlink to ground stations in Gbits')
            metrics = [['Downlink', 'Scenario 1', 'Scenario 2'],
                       ['XB_link', scenario_win_ref.downlink_to_ground_xb, scenario_win_to_cmp.downlink_to_ground_xb],
                       ['KAB_link', scenario_win_ref.downlink_to_ground_kab,
                        scenario_win_to_cmp.downlink_to_ground_kab],
                       ['Total', scenario_win_ref.downlink_to_ground_total,
                        scenario_win_to_cmp.downlink_to_ground_total]
                       ]
            print(tabulate(metrics[1:], headers=metrics[0]))
            return False

    def check_ssmm(self, scenario_win_ref, scenario_win_to_cmp):

        # Compare data volume downlink to ground station

        if scenario_win_to_cmp.ssmm_last_value == scenario_win_ref.ssmm_last_value \
                and scenario_win_to_cmp.ssmm_initial_value == scenario_win_ref.ssmm_initial_value:
            print(f'Both scenarios have the same SSMM value at the beginning and end of scenario:'
                  f'\n\t initial: {scenario_win_ref.ssmm_initial_value} [Gbits]'
                  f'\n\t End: {scenario_win_ref.ssmm_last_value} [Gbits]')
            return True
        else:
            print('\nThe following table list the initial and final values of SSMM in  Gbits')
            metrics = [['Downlink', 'Scenario 1', 'Scenario 2'],
                       ['initial', scenario_win_ref.ssmm_initial_value, scenario_win_to_cmp.ssmm_initial_value],
                       ['End', scenario_win_ref.ssmm_last_value, scenario_win_to_cmp.ssmm_last_value],
                       ]
            print(tabulate(metrics[1:], headers=metrics[0]))
            return False


class DataVolume(object):
    """
    This class allows to store data rate and Data Volume metrics
    """

    def __init__(self, dv_df, data_avg):
        self.start = dv_df['datetime (UTC)'][0]
        self.end = dv_df['datetime (UTC)'].iloc[-1]
        self.experiments, self.science_experiments = self.get_dv_list_of_experiment(dv_df)
        self.df_generated_science = dv_df[self.science_experiments]
        self.df_total_generated_science = self.df_generated_science.sum(axis=1)
        self.generated_dv_total = self.df_total_generated_science.iloc[-1] - self.df_total_generated_science[0]
        self.generated_dv_total_instr = \
            {k: self.df_generated_science[k].iloc[-1] - self.df_generated_science[k][0] for k in
             self.science_experiments}

        downlink_capacity = self.get_downlink_capacity(data_avg)
        self.downlink_capacity_xb = downlink_capacity['XB_LINK:Downlink']
        self.downlink_capacity_kab = downlink_capacity['KAB_LINK:Downlink']
        self.downlink_capacity_total = downlink_capacity['XB_LINK:Downlink'] + downlink_capacity['KAB_LINK:Downlink']

        self.downlink_to_ground_xb = dv_df['XB_LINK:Accum'].iloc[-1] - dv_df['XB_LINK:Accum'][0]
        self.downlink_to_ground_kab = dv_df['KAB_LINK:Accum'].iloc[-1] - dv_df['KAB_LINK:Accum'][0]
        self.downlink_to_ground_total = self.downlink_to_ground_xb + self.downlink_to_ground_kab

        self.ssmm_last_value = data_avg.get_ssmm_last_value('SSMM')
        self.ssmm_initial_value = data_avg.get_ssmm_initial_value('SSMM')

    def get_dv_list_of_experiment(self, dv_df):

        experiments = [k for k in dv_df.keys() if 'Accum' in k and 'SSMM' not in k and 'B_LINK' not in k]
        science_experiments = [k for k in experiments if 'PLATFORM' not in k and 'NAVIGATION' not in k]

        return experiments, science_experiments

    def get_downlink_capacity(self, data_avg):
        downlink_capacity = {'KAB_LINK:Downlink': round(data_avg.get_total_downlink('KAB_LINK'), 2),
                             'XB_LINK:Downlink': round(data_avg.get_total_downlink('XB_LINK'), 2)}

        return downlink_capacity


class Power(object):
    """
    This class allows to store Power metrics
    """

    def __init__(self, pw_df, df_power):

        self.start = pw_df['datetime (UTC)'][0]
        self.end = pw_df['datetime (UTC)'].iloc[-1]

        self.pw_platform, self.pw_experiment, self.pw_bat_per = self.pw_metrrics(pw_df)

        self.power_platform = get_power_profiles_metrics(self.pw_platform)
        self.power_instrument = get_power_profiles_metrics(self.pw_experiment)
        self.power_instrument_total = float((self.power_instrument[-1][-1]))
        self.battery = get_energy_profiles_metrics(self.pw_platform)
        self.energy_platform = get_energy_profiles_metrics(self.pw_platform)
        self.energy_instrument = get_energy_profiles_metrics(self.pw_experiment)

    def pw_metrrics(self, pw_df):

        bat_percent = [label for label in pw_df.keys() if '%' in label]
        inst_platform = \
            ['Available:Watts', 'Available_power_for_science:Watts', 'Batt. DoD:Watts', 'Batt.:Watts',
             'XB_LINK:Watts', 'KAB_LINK:Watts', 'NAVCAM:Watts', 'SSMM:Watts', 'JUICE:Watts',
             'Batt_discharges:Watts']
        no_intruments = bat_percent + inst_platform
        inst_experiment = [label for label in pw_df.keys() if label not in no_intruments and "Watts" in label]
        inst_platform = [label for label in inst_platform if label in pw_df.keys()]

        pw_platform = calculate_power_status(pw_df, inst_filter=inst_platform)
        pw_experiment = calculate_power_status(pw_df, inst_filter=inst_experiment)
        pw_bat_per = calculate_power_status(pw_df, inst_filter=bat_percent)

        return pw_platform, pw_experiment, pw_bat_per