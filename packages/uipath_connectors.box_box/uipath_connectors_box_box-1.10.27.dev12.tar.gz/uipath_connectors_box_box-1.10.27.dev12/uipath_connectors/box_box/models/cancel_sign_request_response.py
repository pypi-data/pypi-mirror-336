from pydantic import BaseModel, ConfigDict, Field
from typing import Any, Dict, Optional, Type

from ..models.cancel_sign_request_response_parent_folder import (
    CancelSignRequestResponseParentFolder,
)
from ..models.cancel_sign_request_response_prefill_tags_array_item_ref import (
    CancelSignRequestResponsePrefillTagsArrayItemRef,
)
from ..models.cancel_sign_request_response_sign_files import (
    CancelSignRequestResponseSignFiles,
)
from ..models.cancel_sign_request_response_signers_array_item_ref import (
    CancelSignRequestResponseSignersArrayItemRef,
)
from ..models.cancel_sign_request_response_signing_log import (
    CancelSignRequestResponseSigningLog,
)
from ..models.cancel_sign_request_response_source_files_array_item_ref import (
    CancelSignRequestResponseSourceFilesArrayItemRef,
)
from ..models.cancel_sign_request_response_status import CancelSignRequestResponseStatus
from ..models.cancel_sign_request_response_type import CancelSignRequestResponseType
import datetime


class CancelSignRequestResponse(BaseModel):
    """
    Attributes:
        are_reminders_enabled (Optional[bool]): Reminds signers to sign a document on day 3, 8, 13 and 18. Reminders are
                only sent to outstanding signers.
        are_text_signatures_enabled (Optional[bool]): Disables the usage of signatures generated by typing (text)
        auto_expire_at (Optional[datetime.datetime]): Uses `days_valid` to calculate the date and time, in GMT, the sign
                request will expire if unsigned.
        days_valid (Optional[int]): Number of days after which this request will automatically expire if not completed
        email_message (Optional[str]): Message to include in sign request email. The field is cleaned through
                sanitization of specific characters. However, some html tags are allowed. Links included in the message are also
                converted to hyperlinks in the email. The message may contain the following html tags including `a`, `abbr`,
                `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to
                html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed. If
                this field is not passed, a default message will be used.
        email_subject (Optional[str]): Subject of sign request email. This is cleaned by sign request. If this field is
                not passed, a default subject will be used.
        external_id (Optional[str]): This can be used to reference an ID in an external system that the sign request is
                related to.
        id (Optional[str]): Sign request ID
        is_document_preparation_needed (Optional[bool]): Indicates if the sender should receive a `prepare_url` in the
                response to complete document preparation via UI.
        parent_folder (Optional[CancelSignRequestResponseParentFolder]):
        prefill_tags (Optional[list['CancelSignRequestResponsePrefillTagsArrayItemRef']]):
        prepare_url (Optional[str]): This URL is returned if `is_document_preparation_needed` is
                set to `true` in the request. It is used to prepare the sign request
                via UI. The sign request is not sent until preparation is complete.
        sign_files (Optional[CancelSignRequestResponseSignFiles]):
        signers (Optional[list['CancelSignRequestResponseSignersArrayItemRef']]):
        signing_log (Optional[CancelSignRequestResponseSigningLog]):
        source_files (Optional[list['CancelSignRequestResponseSourceFilesArrayItemRef']]):
        status (Optional[CancelSignRequestResponseStatus]): Describes the status of the sign request
        type_ (Optional[CancelSignRequestResponseType]): object type
    """

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    are_reminders_enabled: Optional[bool] = Field(
        alias="are_reminders_enabled", default=None
    )
    are_text_signatures_enabled: Optional[bool] = Field(
        alias="are_text_signatures_enabled", default=None
    )
    auto_expire_at: Optional[datetime.datetime] = Field(
        alias="auto_expire_at", default=None
    )
    days_valid: Optional[int] = Field(alias="days_valid", default=None)
    email_message: Optional[str] = Field(alias="email_message", default=None)
    email_subject: Optional[str] = Field(alias="email_subject", default=None)
    external_id: Optional[str] = Field(alias="external_id", default=None)
    id: Optional[str] = Field(alias="id", default=None)
    is_document_preparation_needed: Optional[bool] = Field(
        alias="is_document_preparation_needed", default=None
    )
    parent_folder: Optional["CancelSignRequestResponseParentFolder"] = Field(
        alias="parent_folder", default=None
    )
    prefill_tags: Optional[list["CancelSignRequestResponsePrefillTagsArrayItemRef"]] = (
        Field(alias="prefill_tags", default=None)
    )
    prepare_url: Optional[str] = Field(alias="prepare_url", default=None)
    sign_files: Optional["CancelSignRequestResponseSignFiles"] = Field(
        alias="sign_files", default=None
    )
    signers: Optional[list["CancelSignRequestResponseSignersArrayItemRef"]] = Field(
        alias="signers", default=None
    )
    signing_log: Optional["CancelSignRequestResponseSigningLog"] = Field(
        alias="signing_log", default=None
    )
    source_files: Optional[list["CancelSignRequestResponseSourceFilesArrayItemRef"]] = (
        Field(alias="source_files", default=None)
    )
    status: Optional["CancelSignRequestResponseStatus"] = Field(
        alias="status", default=None
    )
    type_: Optional["CancelSignRequestResponseType"] = Field(alias="type", default=None)

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump(exclude_none=True, by_alias=True)

    @classmethod
    def from_dict(cls: Type["CancelSignRequestResponse"], src_dict: Dict[str, Any]):
        return cls.model_validate(src_dict)

    @property
    def additional_keys(self) -> list[str]:
        base_fields = self.model_fields.keys()
        return [k for k in self.__dict__ if k not in base_fields]

    def __getitem__(self, key: str) -> Any:
        if key in self.__dict__:
            return self.__dict__[key]
        raise KeyError(key)

    def __setitem__(self, key: str, value: Any) -> None:
        self.__dict__[key] = value

    def __delitem__(self, key: str) -> None:
        if key in self.__dict__:
            del self.__dict__[key]
        else:
            raise KeyError(key)

    def __contains__(self, key: str) -> bool:
        return key in self.__dict__
