from pydantic import BaseModel, ConfigDict, Field
from typing import Any, Dict, Optional, Type

from ..models.list_sign_request_parent_folder import ListSignRequestParentFolder
from ..models.list_sign_request_prefill_tags_array_item_ref import (
    ListSignRequestPrefillTagsArrayItemRef,
)
from ..models.list_sign_request_sign_files import ListSignRequestSignFiles
from ..models.list_sign_request_signers_array_item_ref import (
    ListSignRequestSignersArrayItemRef,
)
from ..models.list_sign_request_signing_log import ListSignRequestSigningLog
from ..models.list_sign_request_source_files_array_item_ref import (
    ListSignRequestSourceFilesArrayItemRef,
)
from ..models.list_sign_request_status import ListSignRequestStatus
from ..models.list_sign_request_type import ListSignRequestType
import datetime


class ListSignRequest(BaseModel):
    """
    Attributes:
        are_reminders_enabled (Optional[bool]): Reminds signers to sign a document on day 3, 8, 13 and 18. Reminders are
                only sent to outstanding signers.
        are_text_signatures_enabled (Optional[bool]): Disables the usage of signatures generated by typing (text)
        auto_expire_at (Optional[datetime.datetime]): Uses `days_valid` to calculate the date and time, in GMT, the sign
                request will expire if unsigned.
        days_valid (Optional[int]): Number of days after which this request will automatically expire if not completed
        email_message (Optional[str]): Message to include in sign request email. The field is cleaned through
                sanitization of specific characters. However, some html tags are allowed. Links included in the message are also
                converted to hyperlinks in the email. The message may contain the following html tags including `a`, `abbr`,
                `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to
                html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed. If
                this field is not passed, a default message will be used.
        email_subject (Optional[str]): Subject of sign request email. This is cleaned by sign request. If this field is
                not passed, a default subject will be used.
        external_id (Optional[str]): This can be used to reference an ID in an external system that the sign request is
                related to.
        id (Optional[str]): Sign request ID
        is_document_preparation_needed (Optional[bool]): Indicates if the sender should receive a `prepare_url` in the
                response to complete document preparation via UI.
        name (Optional[str]): Sign request name
        parent_folder (Optional[ListSignRequestParentFolder]):
        prefill_tags (Optional[list['ListSignRequestPrefillTagsArrayItemRef']]):
        prepare_url (Optional[str]): This URL is returned if `is_document_preparation_needed` is
                set to `true` in the request. It is used to prepare the sign request
                via UI. The sign request is not sent until preparation is complete.
        sign_files (Optional[ListSignRequestSignFiles]):
        signers (Optional[list['ListSignRequestSignersArrayItemRef']]):
        signing_log (Optional[ListSignRequestSigningLog]):
        source_files (Optional[list['ListSignRequestSourceFilesArrayItemRef']]):
        status (Optional[ListSignRequestStatus]): The status of the sign request
        type_ (Optional[ListSignRequestType]): object type
    """

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    are_reminders_enabled: Optional[bool] = Field(
        alias="are_reminders_enabled", default=None
    )
    are_text_signatures_enabled: Optional[bool] = Field(
        alias="are_text_signatures_enabled", default=None
    )
    auto_expire_at: Optional[datetime.datetime] = Field(
        alias="auto_expire_at", default=None
    )
    days_valid: Optional[int] = Field(alias="days_valid", default=None)
    email_message: Optional[str] = Field(alias="email_message", default=None)
    email_subject: Optional[str] = Field(alias="email_subject", default=None)
    external_id: Optional[str] = Field(alias="external_id", default=None)
    id: Optional[str] = Field(alias="id", default=None)
    is_document_preparation_needed: Optional[bool] = Field(
        alias="is_document_preparation_needed", default=None
    )
    name: Optional[str] = Field(alias="name", default=None)
    parent_folder: Optional["ListSignRequestParentFolder"] = Field(
        alias="parent_folder", default=None
    )
    prefill_tags: Optional[list["ListSignRequestPrefillTagsArrayItemRef"]] = Field(
        alias="prefill_tags", default=None
    )
    prepare_url: Optional[str] = Field(alias="prepare_url", default=None)
    sign_files: Optional["ListSignRequestSignFiles"] = Field(
        alias="sign_files", default=None
    )
    signers: Optional[list["ListSignRequestSignersArrayItemRef"]] = Field(
        alias="signers", default=None
    )
    signing_log: Optional["ListSignRequestSigningLog"] = Field(
        alias="signing_log", default=None
    )
    source_files: Optional[list["ListSignRequestSourceFilesArrayItemRef"]] = Field(
        alias="source_files", default=None
    )
    status: Optional["ListSignRequestStatus"] = Field(alias="status", default=None)
    type_: Optional["ListSignRequestType"] = Field(alias="type", default=None)

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump(exclude_none=True, by_alias=True)

    @classmethod
    def from_dict(cls: Type["ListSignRequest"], src_dict: Dict[str, Any]):
        return cls.model_validate(src_dict)

    @property
    def additional_keys(self) -> list[str]:
        base_fields = self.model_fields.keys()
        return [k for k in self.__dict__ if k not in base_fields]

    def __getitem__(self, key: str) -> Any:
        if key in self.__dict__:
            return self.__dict__[key]
        raise KeyError(key)

    def __setitem__(self, key: str, value: Any) -> None:
        self.__dict__[key] = value

    def __delitem__(self, key: str) -> None:
        if key in self.__dict__:
            del self.__dict__[key]
        else:
            raise KeyError(key)

    def __contains__(self, key: str) -> bool:
        return key in self.__dict__
