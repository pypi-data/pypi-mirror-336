# coding: utf-8

"""
    RAGsys API

     RAGSys API is an innovative AI retrieval engine developed by Crossing Minds to enhance  Large Language Model (LLM) performance without the need for traditional fine-tuning.  By integrating Retrieval-Augmented Generation (RAG) techniques, RAGSys enables seamless adaptation  of LLMs to various tasks and domains, offering a cost-effective and scalable solution for  enterprises.   Key Features of RAGSys:  - **Seamless Integration**: Compatible with any LLM, including those from Anthropic, OpenAI, and open-source alternatives, allowing effortless switching between models without losing optimizations.  - **Enhanced Retrieval with RAG Embeddings**: Utilizes proprietary RAG embeddings to ensure better understanding and rapid information retrieval, even with massive datasets, resulting in more contextually relevant and accurate LLM outputs.  - **Groundbreaking Accuracy Improvements**: Consistently outperforms traditional fine-tuning, achieving up to a 76% improvement on key benchmarks, with significant enhancements in truthfulness, emotion detection, and commonsense reasoning across various LLMs.  - **Scalable Architecture**: Designed for enterprise-scale deployment, efficiently handling large datasets and complex retrieval tasks, ensuring consistent performance as AI needs grow.   By leveraging RAGSys, organizations can rapidly adapt LLMs to new tasks or domains, saving computational resources and accelerating deployment cycles, all while maintaining high levels of accuracy and relevance in AI outputs.  

    The version of the OpenAPI document: 1.0.0
    Contact: contact@crossingminds.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from ragsys.models.message_content import MessageContent
from ragsys.models.retrieval import Retrieval
from typing import Optional, Set
from typing_extensions import Self

class CompletionBody(BaseModel):
    """
    CompletionBody
    """ # noqa: E501
    messages: List[MessageContent] = Field(description="List of messages to be processed.                                The retrieval feature can be enabled when a message with a `system` role is placed in              the first position, and a prompt utilizing Jinja2 template syntax may be              incorporated within this message.               Note: The final message must have the ``user`` role.             ")
    retrieval: Optional[Retrieval] = None
    model: Optional[StrictStr] = None
    max_tokens: Optional[Annotated[int, Field(strict=True, ge=0)]] = None
    temperature: Optional[Union[Annotated[float, Field(le=2.0, strict=True, ge=0.0)], Annotated[int, Field(le=2, strict=True, ge=0)]]] = None
    __properties: ClassVar[List[str]] = ["messages", "retrieval", "model", "max_tokens", "temperature"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CompletionBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
        _items = []
        if self.messages:
            for _item_messages in self.messages:
                if _item_messages:
                    _items.append(_item_messages.to_dict())
            _dict['messages'] = _items
        # override the default output from pydantic by calling `to_dict()` of retrieval
        if self.retrieval:
            _dict['retrieval'] = self.retrieval.to_dict()
        # set to None if retrieval (nullable) is None
        # and model_fields_set contains the field
        if self.retrieval is None and "retrieval" in self.model_fields_set:
            _dict['retrieval'] = None

        # set to None if model (nullable) is None
        # and model_fields_set contains the field
        if self.model is None and "model" in self.model_fields_set:
            _dict['model'] = None

        # set to None if max_tokens (nullable) is None
        # and model_fields_set contains the field
        if self.max_tokens is None and "max_tokens" in self.model_fields_set:
            _dict['max_tokens'] = None

        # set to None if temperature (nullable) is None
        # and model_fields_set contains the field
        if self.temperature is None and "temperature" in self.model_fields_set:
            _dict['temperature'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CompletionBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "messages": [MessageContent.from_dict(_item) for _item in obj["messages"]] if obj.get("messages") is not None else None,
            "retrieval": Retrieval.from_dict(obj["retrieval"]) if obj.get("retrieval") is not None else None,
            "model": obj.get("model"),
            "max_tokens": obj.get("max_tokens"),
            "temperature": obj.get("temperature")
        })
        return _obj


