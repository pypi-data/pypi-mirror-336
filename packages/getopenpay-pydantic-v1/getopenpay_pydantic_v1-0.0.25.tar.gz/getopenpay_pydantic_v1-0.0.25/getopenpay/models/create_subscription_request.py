# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import datetime
from typing import Any, Dict, List, Optional

from getopenpay.models.checkout_preferences import CheckoutPreferences
from getopenpay.models.collection_method_enum import CollectionMethodEnum
from getopenpay.models.selected_price_quantity import SelectedPriceQuantity
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist


class CreateSubscriptionRequest(BaseModel):
  """
    CreateSubscriptionRequest
    """
  attach_to_checkout_attempt_id: Optional[StrictStr] = None
  cancel_at_end: Optional[StrictBool] = Field(
    False,
    description=
    'Boolean indicating whether this subscription should cancel at the end of the current period.'
  )
  checkout_preferences: Optional[CheckoutPreferences] = None
  collection_method: Optional[CollectionMethodEnum] = Field(
    None,
    description=
    'Invoices generated by this subscription can either be charged automatically or can be sent to customer for payment. The latter is not automatically charged.'
  )
  coupon_id: Optional[StrictStr] = None
  custom_fields: Optional[Dict[str, Any]] = None
  customer_id: StrictStr = Field(..., description='Unique Identifier of the customer.')
  description: Optional[StrictStr] = None
  is_preview: Optional[StrictBool] = Field(
    False,
    description="Whether the request is in preview mode (subscriptions won't actually be created)"
  )
  net_d: Optional[StrictInt] = None
  payment_method_id: Optional[StrictStr] = None
  promotion_code: Optional[StrictStr] = None
  selected_product_price_quantity: conlist(SelectedPriceQuantity) = Field(...)
  skip_invoice_payment: Optional[StrictBool] = Field(
    False,
    description=
    'Whether to skip invoice payment for this subscription. Setting this to true will leave the invoices open.'
  )
  total_amount_atom: Optional[StrictInt] = None
  trial_end: Optional[datetime] = None
  trial_from_price: Optional[StrictBool] = Field(
    True,
    description=
    "Indicates if a price's trial_period_days should be applied to the subscription. Setting trial_end per subscription is preferred, and this defaults to false. Setting this flag to true together with trial_end is not allowed. In case of subscription containing multiple prices and the trial period of them are not same, minimum of trial days will be used."
  )
  trial_period_days: Optional[StrictInt] = None
  __properties = [
    'attach_to_checkout_attempt_id', 'cancel_at_end', 'checkout_preferences', 'collection_method',
    'coupon_id', 'custom_fields', 'customer_id', 'description', 'is_preview', 'net_d',
    'payment_method_id', 'promotion_code', 'selected_product_price_quantity',
    'skip_invoice_payment', 'total_amount_atom', 'trial_end', 'trial_from_price',
    'trial_period_days'
  ]

  class Config:
    """Pydantic configuration"""
    allow_population_by_field_name = True
    validate_assignment = True

  def to_str(self) -> str:
    """Returns the string representation of the model using alias"""
    return pprint.pformat(self.dict(by_alias=True))

  def to_json(self) -> str:
    """Returns the JSON representation of the model using alias"""
    return json.dumps(self.to_dict())

  @classmethod
  def from_json(cls, json_str: str) -> CreateSubscriptionRequest:
    """Create an instance of CreateSubscriptionRequest from a JSON string"""
    return cls.from_dict(json.loads(json_str))

  def to_dict(self):
    """Returns the dictionary representation of the model using alias"""
    _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
    # override the default output from pydantic by calling `to_dict()` of checkout_preferences
    if self.checkout_preferences:
      _dict['checkout_preferences'] = self.checkout_preferences.to_dict()
    # override the default output from pydantic by calling `to_dict()` of each item in selected_product_price_quantity (list)
    _items = []
    if self.selected_product_price_quantity:
      for _item in self.selected_product_price_quantity:
        if _item:
          _items.append(_item.to_dict())
      _dict['selected_product_price_quantity'] = _items
    # set to None if attach_to_checkout_attempt_id (nullable) is None
    # and __fields_set__ contains the field
    if self.attach_to_checkout_attempt_id is None and 'attach_to_checkout_attempt_id' in self.__fields_set__:
      _dict['attach_to_checkout_attempt_id'] = None

    # set to None if checkout_preferences (nullable) is None
    # and __fields_set__ contains the field
    if self.checkout_preferences is None and 'checkout_preferences' in self.__fields_set__:
      _dict['checkout_preferences'] = None

    # set to None if coupon_id (nullable) is None
    # and __fields_set__ contains the field
    if self.coupon_id is None and 'coupon_id' in self.__fields_set__:
      _dict['coupon_id'] = None

    # set to None if custom_fields (nullable) is None
    # and __fields_set__ contains the field
    if self.custom_fields is None and 'custom_fields' in self.__fields_set__:
      _dict['custom_fields'] = None

    # set to None if description (nullable) is None
    # and __fields_set__ contains the field
    if self.description is None and 'description' in self.__fields_set__:
      _dict['description'] = None

    # set to None if net_d (nullable) is None
    # and __fields_set__ contains the field
    if self.net_d is None and 'net_d' in self.__fields_set__:
      _dict['net_d'] = None

    # set to None if payment_method_id (nullable) is None
    # and __fields_set__ contains the field
    if self.payment_method_id is None and 'payment_method_id' in self.__fields_set__:
      _dict['payment_method_id'] = None

    # set to None if promotion_code (nullable) is None
    # and __fields_set__ contains the field
    if self.promotion_code is None and 'promotion_code' in self.__fields_set__:
      _dict['promotion_code'] = None

    # set to None if total_amount_atom (nullable) is None
    # and __fields_set__ contains the field
    if self.total_amount_atom is None and 'total_amount_atom' in self.__fields_set__:
      _dict['total_amount_atom'] = None

    # set to None if trial_end (nullable) is None
    # and __fields_set__ contains the field
    if self.trial_end is None and 'trial_end' in self.__fields_set__:
      _dict['trial_end'] = None

    # set to None if trial_period_days (nullable) is None
    # and __fields_set__ contains the field
    if self.trial_period_days is None and 'trial_period_days' in self.__fields_set__:
      _dict['trial_period_days'] = None

    return _dict

  @classmethod
  def from_dict(cls, obj: dict) -> CreateSubscriptionRequest:
    """Create an instance of CreateSubscriptionRequest from a dict"""
    if obj is None:
      return None

    if not isinstance(obj, dict):
      return CreateSubscriptionRequest.parse_obj(obj)

    _obj = CreateSubscriptionRequest.parse_obj(
      {
        'attach_to_checkout_attempt_id': obj.get('attach_to_checkout_attempt_id'),
        'cancel_at_end': obj.get('cancel_at_end')
                         if obj.get('cancel_at_end') is not None else False,
        'checkout_preferences':
          CheckoutPreferences.from_dict(obj.get('checkout_preferences'))
          if obj.get('checkout_preferences') is not None else None,
        'collection_method': obj.get('collection_method'),
        'coupon_id': obj.get('coupon_id'),
        'custom_fields': obj.get('custom_fields'),
        'customer_id': obj.get('customer_id'),
        'description': obj.get('description'),
        'is_preview': obj.get('is_preview') if obj.get('is_preview') is not None else False,
        'net_d': obj.get('net_d'),
        'payment_method_id': obj.get('payment_method_id'),
        'promotion_code': obj.get('promotion_code'),
        'selected_product_price_quantity':
          [
            SelectedPriceQuantity.from_dict(_item)
            for _item in obj.get('selected_product_price_quantity')
          ] if obj.get('selected_product_price_quantity') is not None else None,
        'skip_invoice_payment':
          obj.get('skip_invoice_payment') if obj.get('skip_invoice_payment') is not None else False,
        'total_amount_atom': obj.get('total_amount_atom'),
        'trial_end': obj.get('trial_end'),
        'trial_from_price':
          obj.get('trial_from_price') if obj.get('trial_from_price') is not None else True,
        'trial_period_days': obj.get('trial_period_days')
      }
    )
    return _obj
