# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _libbatch
else:
    import _libbatch

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class Job(object):
    r"""Proxy of C++ Batch::Job class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""
        __init__(Job self) -> Job
        __init__(Job self, Batch::Parametre param) -> Job
        __init__(Job self, Batch::Environnement env) -> Job
        __init__(Job self, Batch::Parametre param, Batch::Environnement env) -> Job
        """
        _libbatch.Job_swiginit(self, _libbatch.new_Job(*args))
    __swig_destroy__ = _libbatch.delete_Job

    def getParametre(self) -> "Batch::Parametre":
        r"""getParametre(Job self) -> Batch::Parametre"""
        return _libbatch.Job_getParametre(self)

    def setParametre(self, arg2: "Batch::Parametre const &") -> "void":
        r"""setParametre(Job self, Batch::Parametre const & arg2)"""
        return _libbatch.Job_setParametre(self, arg2)

    def getEnvironnement(self) -> "Batch::Environnement":
        r"""getEnvironnement(Job self) -> Batch::Environnement"""
        return _libbatch.Job_getEnvironnement(self)

    def setEnvironnement(self, arg2: "Batch::Environnement const &") -> "void":
        r"""setEnvironnement(Job self, Batch::Environnement const & arg2)"""
        return _libbatch.Job_setEnvironnement(self, arg2)

    def __str__(self) -> "std::string":
        r"""__str__(Job self) -> std::string"""
        return _libbatch.Job___str__(self)

    def __repr__(self) -> "std::string":
        r"""__repr__(Job self) -> std::string"""
        return _libbatch.Job___repr__(self)

# Register Job in _libbatch:
_libbatch.Job_swigregister(Job)

class JobId(object):
    r"""Proxy of C++ Batch::JobId class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _libbatch.delete_JobId

    def __init__(self, *args):
        r"""
        __init__(JobId self) -> JobId
        __init__(JobId self, BatchManager arg2, std::string const & ref) -> JobId
        __init__(JobId self, JobId arg2) -> JobId
        """
        _libbatch.JobId_swiginit(self, _libbatch.new_JobId(*args))

    def getReference(self) -> "std::string":
        r"""getReference(JobId self) -> std::string"""
        return _libbatch.JobId_getReference(self)

    def setReference(self, new_reference: "std::string const &") -> "void":
        r"""setReference(JobId self, std::string const & new_reference)"""
        return _libbatch.JobId_setReference(self, new_reference)

    def deleteJob(self) -> "void":
        r"""deleteJob(JobId self)"""
        return _libbatch.JobId_deleteJob(self)

    def holdJob(self) -> "void":
        r"""holdJob(JobId self)"""
        return _libbatch.JobId_holdJob(self)

    def releaseJob(self) -> "void":
        r"""releaseJob(JobId self)"""
        return _libbatch.JobId_releaseJob(self)

    def alterJob(self, *args) -> "void":
        r"""
        alterJob(JobId self, Batch::Parametre const & param, Batch::Environnement const & env)
        alterJob(JobId self, Batch::Parametre const & param)
        alterJob(JobId self, Batch::Environnement const & env)
        """
        return _libbatch.JobId_alterJob(self, *args)

    def setParametre(self, param: "Batch::Parametre const &") -> "void":
        r"""setParametre(JobId self, Batch::Parametre const & param)"""
        return _libbatch.JobId_setParametre(self, param)

    def setEnvironnement(self, env: "Batch::Environnement const &") -> "void":
        r"""setEnvironnement(JobId self, Batch::Environnement const & env)"""
        return _libbatch.JobId_setEnvironnement(self, env)

    def queryJob(self) -> "Batch::JobInfo":
        r"""queryJob(JobId self) -> JobInfo"""
        return _libbatch.JobId_queryJob(self)

    def __str__(self) -> "std::string":
        r"""__str__(JobId self) -> std::string"""
        return _libbatch.JobId___str__(self)

    def __repr__(self) -> "std::string":
        r"""__repr__(JobId self) -> std::string"""
        return _libbatch.JobId___repr__(self)

# Register JobId in _libbatch:
_libbatch.JobId_swigregister(JobId)

class JobInfo(object):
    r"""Proxy of C++ Batch::JobInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _libbatch.delete_JobInfo

    def __init__(self, *args):
        r"""
        __init__(JobInfo self) -> JobInfo
        __init__(JobInfo self, JobInfo jinfo) -> JobInfo
        """
        _libbatch.JobInfo_swiginit(self, _libbatch.new_JobInfo(*args))

    def getParametre(self) -> "Batch::Parametre":
        r"""getParametre(JobInfo self) -> Batch::Parametre"""
        return _libbatch.JobInfo_getParametre(self)

    def getEnvironnement(self) -> "Batch::Environnement":
        r"""getEnvironnement(JobInfo self) -> Batch::Environnement"""
        return _libbatch.JobInfo_getEnvironnement(self)

    @staticmethod
    def Tokenize(*args) -> "void":
        r"""Tokenize(std::string const & str, std::vector< std::string > & tokens, std::string const & delimiters=" ")"""
        return _libbatch.JobInfo_Tokenize(*args)

    def __str__(self) -> "std::string":
        r"""__str__(JobInfo self) -> std::string"""
        return _libbatch.JobInfo___str__(self)

    def __repr__(self) -> "std::string":
        r"""__repr__(JobInfo self) -> std::string"""
        return _libbatch.JobInfo___repr__(self)

# Register JobInfo in _libbatch:
_libbatch.JobInfo_swigregister(JobInfo)

def JobInfo_Tokenize(*args) -> "void":
    r"""JobInfo_Tokenize(std::string const & str, std::vector< std::string > & tokens, std::string const & delimiters=" ")"""
    return _libbatch.JobInfo_Tokenize(*args)

SH = _libbatch.SH

SSH = _libbatch.SSH

RSH = _libbatch.RSH

RSYNC = _libbatch.RSYNC

class CommunicationProtocol(object):
    r"""Proxy of C++ Batch::CommunicationProtocol class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libbatch.delete_CommunicationProtocol

    @staticmethod
    def getInstance(protocolType: "Batch::CommunicationProtocolType") -> "Batch::CommunicationProtocol const &":
        r"""getInstance(Batch::CommunicationProtocolType protocolType) -> CommunicationProtocol"""
        return _libbatch.CommunicationProtocol_getInstance(protocolType)

    def getExecCommand(self, subCommand: "std::string const &", host: "std::string const &", user: "std::string const &") -> "std::string":
        r"""getExecCommand(CommunicationProtocol self, std::string const & subCommand, std::string const & host, std::string const & user) -> std::string"""
        return _libbatch.CommunicationProtocol_getExecCommand(self, subCommand, host, user)

    def getExecCommandArgs(self, subCommand: "std::string const &", host: "std::string const &", user: "std::string const &") -> "std::vector< std::string >":
        r"""getExecCommandArgs(CommunicationProtocol self, std::string const & subCommand, std::string const & host, std::string const & user) -> std::vector< std::string >"""
        return _libbatch.CommunicationProtocol_getExecCommandArgs(self, subCommand, host, user)

    def copyFile(self, sourcePath: "std::string const &", sourceHost: "std::string const &", sourceUser: "std::string const &", destinationPath: "std::string const &", destinationHost: "std::string const &", destinationUser: "std::string const &") -> "int":
        r"""copyFile(CommunicationProtocol self, std::string const & sourcePath, std::string const & sourceHost, std::string const & sourceUser, std::string const & destinationPath, std::string const & destinationHost, std::string const & destinationUser) -> int"""
        return _libbatch.CommunicationProtocol_copyFile(self, sourcePath, sourceHost, sourceUser, destinationPath, destinationHost, destinationUser)

    def removeFile(self, path: "std::string const &", host: "std::string const &", user: "std::string const &") -> "int":
        r"""removeFile(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_removeFile(self, path, host, user)

    def removeDirectory(self, path: "std::string const &", host: "std::string const &", user: "std::string const &") -> "int":
        r"""removeDirectory(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_removeDirectory(self, path, host, user)

    def makeDirectory(self, path: "std::string const &", host: "std::string const &", user: "std::string const &") -> "int":
        r"""makeDirectory(CommunicationProtocol self, std::string const & path, std::string const & host, std::string const & user) -> int"""
        return _libbatch.CommunicationProtocol_makeDirectory(self, path, host, user)

    def getType(self) -> "Batch::CommunicationProtocolType":
        r"""getType(CommunicationProtocol self) -> Batch::CommunicationProtocolType"""
        return _libbatch.CommunicationProtocol_getType(self)

# Register CommunicationProtocol in _libbatch:
_libbatch.CommunicationProtocol_swigregister(CommunicationProtocol)

def CommunicationProtocol_getInstance(protocolType: "Batch::CommunicationProtocolType") -> "Batch::CommunicationProtocol const &":
    r"""CommunicationProtocol_getInstance(Batch::CommunicationProtocolType protocolType) -> CommunicationProtocol"""
    return _libbatch.CommunicationProtocol_getInstance(protocolType)

class BatchManager(object):
    r"""Proxy of C++ Batch::BatchManager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        r"""__init__(BatchManager self, FactBatchManager parent, char const * host="localhost", char const * username="", Batch::CommunicationProtocolType protocolType=SSH, char const * mpiImpl="nompi") -> BatchManager"""
        _libbatch.BatchManager_swiginit(self, _libbatch.new_BatchManager(*args))
    __swig_destroy__ = _libbatch.delete_BatchManager

    def __repr__(self) -> "std::string":
        r"""__repr__(BatchManager self) -> std::string"""
        return _libbatch.BatchManager___repr__(self)

    def getJobIdByReference(self, ref: "char const *") -> "Batch::JobId const":
        r"""getJobIdByReference(BatchManager self, char const * ref) -> JobId"""
        return _libbatch.BatchManager_getJobIdByReference(self, ref)

    def submitJob(self, job: "Job") -> "Batch::JobId const":
        r"""submitJob(BatchManager self, Job job) -> JobId"""
        return _libbatch.BatchManager_submitJob(self, job)

    def deleteJob(self, jobid: "JobId") -> "void":
        r"""deleteJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_deleteJob(self, jobid)

    def holdJob(self, jobid: "JobId") -> "void":
        r"""holdJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_holdJob(self, jobid)

    def releaseJob(self, jobid: "JobId") -> "void":
        r"""releaseJob(BatchManager self, JobId jobid)"""
        return _libbatch.BatchManager_releaseJob(self, jobid)

    def alterJob(self, *args) -> "void":
        r"""
        alterJob(BatchManager self, JobId jobid, Batch::Parametre const & param, Batch::Environnement const & env)
        alterJob(BatchManager self, JobId jobid, Batch::Parametre const & param)
        alterJob(BatchManager self, JobId jobid, Batch::Environnement const & env)
        """
        return _libbatch.BatchManager_alterJob(self, *args)

    def queryJob(self, jobid: "JobId") -> "Batch::JobInfo":
        r"""queryJob(BatchManager self, JobId jobid) -> JobInfo"""
        return _libbatch.BatchManager_queryJob(self, jobid)

    def addJob(self, job: "Job", reference: "std::string const &") -> "Batch::JobId const":
        r"""addJob(BatchManager self, Job job, std::string const & reference) -> JobId"""
        return _libbatch.BatchManager_addJob(self, job, reference)

    def waitForJobEnd(self, jobid: "JobId", timeout: "long"=-1, initSleepTime: "long"=1, maxSleepTime: "long"=600) -> "std::string":
        r"""waitForJobEnd(BatchManager self, JobId jobid, long timeout=-1, long initSleepTime=1, long maxSleepTime=600) -> std::string"""
        return _libbatch.BatchManager_waitForJobEnd(self, jobid, timeout, initSleepTime, maxSleepTime)

    def importOutputFiles(self, job: "Job", directory: "std::string const") -> "void":
        r"""importOutputFiles(BatchManager self, Job job, std::string const directory)"""
        return _libbatch.BatchManager_importOutputFiles(self, job, directory)

    def importDumpStateFile(self, job: "Job", directory: "std::string const") -> "bool":
        r"""importDumpStateFile(BatchManager self, Job job, std::string const directory) -> bool"""
        return _libbatch.BatchManager_importDumpStateFile(self, job, directory)

    def importWorkFile(self, job: "Job", work_file: "std::string const &", directory: "std::string const &") -> "bool":
        r"""importWorkFile(BatchManager self, Job job, std::string const & work_file, std::string const & directory) -> bool"""
        return _libbatch.BatchManager_importWorkFile(self, job, work_file, directory)

    def clearWorkingDir(self, job: "Job") -> "void":
        r"""clearWorkingDir(BatchManager self, Job job)"""
        return _libbatch.BatchManager_clearWorkingDir(self, job)

    def getProtocol(self) -> "Batch::CommunicationProtocol const &":
        r"""getProtocol(BatchManager self) -> CommunicationProtocol"""
        return _libbatch.BatchManager_getProtocol(self)

    def exportInputFiles(self, job: "Job") -> "void":
        r"""exportInputFiles(BatchManager self, Job job)"""
        return _libbatch.BatchManager_exportInputFiles(self, job)

# Register BatchManager in _libbatch:
_libbatch.BatchManager_swigregister(BatchManager)

class BatchManagerCatalog(object):
    r"""Proxy of C++ Batch::BatchManagerCatalog class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    @staticmethod
    def getInstance() -> "Batch::BatchManagerCatalog &":
        r"""getInstance() -> BatchManagerCatalog"""
        return _libbatch.BatchManagerCatalog_getInstance()

    def addFactBatchManager(self, type: "char const *", pFBM: "FactBatchManager") -> "void":
        r"""addFactBatchManager(BatchManagerCatalog self, char const * type, FactBatchManager pFBM)"""
        return _libbatch.BatchManagerCatalog_addFactBatchManager(self, type, pFBM)

    def hasFactBatchManager(self, type: "char const *") -> "bool":
        r"""hasFactBatchManager(BatchManagerCatalog self, char const * type) -> bool"""
        return _libbatch.BatchManagerCatalog_hasFactBatchManager(self, type)

    def __call__(self, type: "char const *") -> "Batch::FactBatchManager *":
        r"""__call__(BatchManagerCatalog self, char const * type) -> FactBatchManager"""
        return _libbatch.BatchManagerCatalog___call__(self, type)

    def dict(self) -> "std::map< std::string,Batch::FactBatchManager * > *":
        r"""dict(BatchManagerCatalog self) -> std::map< std::string,Batch::FactBatchManager * > *"""
        return _libbatch.BatchManagerCatalog_dict(self)

    def __repr__(self) -> "std::string":
        r"""__repr__(BatchManagerCatalog self) -> std::string"""
        return _libbatch.BatchManagerCatalog___repr__(self)

# Register BatchManagerCatalog in _libbatch:
_libbatch.BatchManagerCatalog_swigregister(BatchManagerCatalog)

def BatchManagerCatalog_getInstance() -> "Batch::BatchManagerCatalog &":
    r"""BatchManagerCatalog_getInstance() -> BatchManagerCatalog"""
    return _libbatch.BatchManagerCatalog_getInstance()

class FactBatchManager(object):
    r"""Proxy of C++ Batch::FactBatchManager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __swig_destroy__ = _libbatch.delete_FactBatchManager

    def __call__(self, *args) -> "Batch::BatchManager *":
        r"""__call__(FactBatchManager self, char const * hostname, char const * username="", Batch::CommunicationProtocolType protocolType=SSH, char const * mpi="nompi") -> BatchManager"""
        return _libbatch.FactBatchManager___call__(self, *args)

    def getType(self) -> "std::string const &":
        r"""getType(FactBatchManager self) -> std::string const &"""
        return _libbatch.FactBatchManager_getType(self)

    def __repr__(self) -> "std::string":
        r"""__repr__(FactBatchManager self) -> std::string"""
        return _libbatch.FactBatchManager___repr__(self)

# Register FactBatchManager in _libbatch:
_libbatch.FactBatchManager_swigregister(FactBatchManager)


cvar = _libbatch.cvar
ARGUMENTS = cvar.ARGUMENTS
ASSIGNEDHOSTNAMES = cvar.ASSIGNEDHOSTNAMES
EXECUTABLE = cvar.EXECUTABLE
ID = cvar.ID
INFILE = cvar.INFILE
MAXCPUTIME = cvar.MAXCPUTIME
MAXDISKSIZE = cvar.MAXDISKSIZE
MAXRAMSIZE = cvar.MAXRAMSIZE
MAXWALLTIME = cvar.MAXWALLTIME
NAME = cvar.NAME
NBPROC = cvar.NBPROC
NBPROCPERNODE = cvar.NBPROCPERNODE
OUTFILE = cvar.OUTFILE
QUEUE = cvar.QUEUE
STATE = cvar.STATE
WORKDIR = cvar.WORKDIR
EXCLUSIVE = cvar.EXCLUSIVE
MEMPERCPU = cvar.MEMPERCPU
WCKEY = cvar.WCKEY
EXTRAPARAMS = cvar.EXTRAPARAMS
PREPROCESS = cvar.PREPROCESS
PARTITION = cvar.PARTITION
NBNODE = cvar.NBNODE
LAUNCHER_FILE = cvar.LAUNCHER_FILE
LAUNCHER_ARGS = cvar.LAUNCHER_ARGS
CREATED = cvar.CREATED
IN_PROCESS = cvar.IN_PROCESS
QUEUED = cvar.QUEUED
RUNNING = cvar.RUNNING
PAUSED = cvar.PAUSED
FINISHED = cvar.FINISHED
FAILED = cvar.FAILED

