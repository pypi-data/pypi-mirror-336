# -*- coding: utf-8 -*-
"""QVP2_20250325_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P1_mRc5U2o2rDbDorRWcJzH-Bj7rGylC

# QuickViper2
Condaå®Ÿè¡Œç’°å¢ƒæ¨©é™ä¸è¶³ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€

1. conda-packã§ä»®æƒ³ç’°å¢ƒã®åœ§ç¸®æ›¸åº«ã‚’ä½œæˆ
2. 1.ã§ã§ããŸåœ§ç¸®æ›¸åº«ã‚’tarã§æŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€ã«è§£å‡
3. conda-unpackã§ã€ã‚³ãƒ”ãƒ¼ã«ä¼´ã„ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã«ç™ºç”Ÿã™ã‚‹ä¸å…·åˆã‚’ä¿®æ­£

ã‚’è¡Œã†ã€‚



```
2025/03/22 0.1.0 å®Œæˆ
2025/03/22 0.1.1 ãƒã‚°ä¿®æ­£
2025/03/23 0.1.3 DebugHelperã¨ã®ä¾å­˜é–¢ä¿‚ä¿®å¾©ã®ãŸã‚
2025/03/23 0.1.6 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.7 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.8 å„ç¨®ä¿®æ­£ã¨æ”¹è‰¯ã€‚UniqueEnvVar ã‚’å°å…¥
2025/03/26 0.2.0 ãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—ã€‚EasyVen, DebugHelper.installerå°å…¥
```

# QuickViper2

## 1. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©
"""

# @title a. GDriveæ¥ç¶šã¨condacolabè¨­å®š1
if __name__ == '__main__':
    get_ipython().system( "pip install an_CondaInitializer" )
    from an_condainitializer import CondaInitializer

    condainitializer = CondaInitializer()

# @title b. QuickViper2 å®šç¾©
import os
import re
import json
import yaml
import shutil
import subprocess

from pathlib import Path


get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper
get_ipython().system( "pip install an_EasyVen" )
from an_easyven import EasyVen
get_ipython().system( "pip install an_UniqueEnvVar" )
from an_uniqueenvvar import UniqueEnvVar


class QuickViper2:
    def __init__( self, venv_name, init_path = False ):
        from google.colab import drive
        drive.mount( '/content/drive' )

        self.debug = DebugHelper( instance_name = "QuickViper2" )
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        self.venv_name = venv_name
        self.even = EasyVen()
        [ self.bch_path,
          self.dst_path,
          self.cur_path,
          self.src_path,
          self.arc_path,
          self.lcl_path,
          self.bin_path,
          self.lib_path ] = self.even.setup( venv_name = self.venv_name )

        self.uniqueev = UniqueEnvVar( var_name = "LD_LIBRARY_PATH")

    def compress_venv( self ):
        self.debug.log_step( "compress_venv", success = None )

        # get_ipython().system( "conda install -c conda-forge conda-pack" )
        # conda-pack --prefix . --format tar --output /path/to/myenv.tar
        cd_cmd = f"cd { Path( self.src_path ).joinpath( self.venv_name ) }"
        # ex_cmd = f"conda-pack --prefix { self.src_path } --format tar.gz --output { self.arc_path }"
        # self.debug.log_step( f"cd_cmd : { cd_cmd }" )
        # self.debug.log_step( f"ex_cmd : { ex_cmd }" )
        get_ipython().system( cd_cmd )
        # get_ipython().system( ex_cmd )
        self.debug.installer( command = f"conda-pack --prefix { self.src_path } --format tar.gz --output { self.arc_path }", shell = True )

    def list_archive( self ):
        self.debug.log_step( "list_archive", success = None )
        get_ipython().system( f"tar tvf { self.arc_path }" )
        self.debug.installer( command = [ "tar", "tvf", str(self.arc_path ) ] )

    def delete_venv( self ):
        self.debug.log_step( "delete_venv", success = None )
        shutil.rmtree( self.lcl_path )

    def extract_venv( self ):
        self.debug.log_step( "extract_venv", success = None )
        os.chdir( self.cur_path )
        os.makedirs( self.lcl_path, exist_ok = True )
        # cmd = f"tar -xf { self.arc_path } -C {self.lcl_path}"
        # get_ipython().system( cmd )
        self.debug.installer( command = f"tar -xf { self.arc_path } -C {self.lcl_path}", shell = True, back = 1 )

    def conda_unpack( self ):
        self.debug.log_step( "conda_unpack", success = None )
        os.chdir( self.lcl_path )
        get_ipython().system( f"./bin/conda-unpack" )
        ### 2025/03/25 ã©ã†ã—ã¦ã‚‚ã“ã®æ–¹æ³•ã§ã¯ä»®æƒ³ç’°å¢ƒã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã§ããªã„ã®ã§ã€ã‚„ã‚ã«ã—ãŸã€‚
        # Colabã§ã¯ "source" ã‚’ä½¿ãˆãªã„ãŸã‚ã€bash -c çµŒç”±ã§ conda ã®åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ã†
        #            bash -c "source /usr/local/etc/profile.d/conda.sh && conda activate /content/cEnv/venv/kohya_env/contents && python -m pip --version"
        # command = f'bash -c "source /usr/local/etc/profile.d/conda.sh && conda activate { self.lcl_path } && exec bash"'
        # result, stdout, stderr = self.debug.run_command(command, stdout=True, stderr=True)
        # self.debug.log_step( f"result:\n{ result }", success = None)
        # self.debug.log_step( f"stdout:\n{ stdout }", success = None)
        # self.debug.log_step( f"stderr:\n{ stdout }", success = None)
        # if result == 0:
        #    self.debug.log_step(f"ç’°å¢ƒãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸã€‚", char="ğŸŒŸ")


    def set_executable( self ):
        self.debug.log_step( "set_executable", success = None )
        get_ipython().system( f"chmod 755 { self.bin_path / 'python3.10' }" )
        get_ipython().system( f"chmod 755 { self.bin_path / 'python' }" )
        get_ipython().system( f"ls -l { self.bin_path / 'python3.10' }" )
        get_ipython().system( f"ls -l { self.bin_path / 'python' }" )

    def set_ld_library_path( self ):
        self.debug.log_step( "set_ld_library_path", success = None )
        """
        æŒ‡å®šã—ãŸ new_path ã‚’æ—¢å­˜ã®LD_LIBRARY_PATHã®å…ˆé ­ã«è¿½åŠ ã—ã¾ã™ã€‚
        """
        # os.environ["LD_LIBRARY_PATH"] = f"{self.lib_path}:{ self.bkup_env }"
        self.uniqueev.add_value( new_value = str(self.lib_path) )
        self.debug.log_step(f"Updated LD_LIBRARY_PATH: {os.environ['LD_LIBRARY_PATH']}", success = None )

    def unlock( self, force_unlock = False ):
        self.debug.log_step( "unlock", success = None )
        if force_unlock and Path( self.lcl_path ).exists():
            shutil.rmtree( self.lcl_path )
        if not Path( self.lcl_path ).exists():
            self.extract_venv()
            self.conda_unpack()
            self.set_executable()
            self.set_ld_library_path()

    def executer( self, cmdlist = [ "pip", "--version" ] ):
        self.debug.log_step( "exe_python", success = None )
        os.chdir( self.bin_path )
        # ç¾åœ¨ã®ç’°å¢ƒå¤‰æ•°ã‚’ã‚³ãƒ”ãƒ¼
        env = os.environ.copy()
        # ã‚·ã‚§ãƒ«ã‚’ä½¿ã£ã¦ "env | grep LD_LIBRARY_PATH" ã‚’å®Ÿè¡Œã—ã€å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
        # result = subprocess.run(["env"], env=env, capture_output=True, text=True)
        result = subprocess.run("env | grep ^LD_LIBRARY_PATH=", shell=True, env=env, capture_output=True, text=True)
        self.debug.log_step( f"result : { result }", success = None )
        # å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§å®šç¾©
        cmd = [str(self.bin_path / "python"), "-m"]
        full_cmd = cmd + cmdlist
        self.debug.installer( command = full_cmd, back = 1 )
        ### self.debug.run.commandãŒä½¿ãˆãªã„ç†ç”±ã¯ã‚ã‹ã‚‰ãªã„ã€‚ã“ã‚Œã‚‚ä»®æƒ³ç’°å¢ƒçµ¡ã¿ã‹?
        ### result, stdout, stderr = self.debug.run_command( command = full_cmd, stdout = True, stderr = True )
        ### self.debug.log_step( f"stdout:\n{ stdout }", success = None)
        ### self.debug.log_step( f"stderr:\n{ stdout }", success = None)



if __name__ == "__main__":
    quick_viper2 = QuickViper2( venv_name = "kohya_env" )
    # quick_viper2.compress_venv( venv_name = "kohya_env" )
    # quick_viper2.list_archive( venv_name = "kohya_env" )
    quick_viper2.unlock( force_unlock = True )
    quick_viper2.executer( )